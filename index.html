<!DOCcolour html>
<html>
	<head>
		<meta name="theme-color" content="#101010" />
		<style>
			body {
				background-image: url("Resources/Background/Clouds_trans.png");
				background-size: 100% 100%;
				//opacity: 0.6;
				background-color: #181818;
				overflow-y: hidden;
				//background: linear-gradient(white,black);
			}
			html {
				margin-top: 0 px;
				margin-left: 0 px;
			}
			#drawSpace {
				//z-index: 10;
				position: absolute;
				//top: 0px;
				left: 0px;
				//border: 1px dotted gray;
				//pointer-events:none;
			}
			#selectionBox {
				//border: 1px dotted gray;
				position: absolute;
				background: radial-gradient(rgba(255,0,0,0) 60%,rgba(200,200,200,0.5) 65%, rgba(255,0,0,0) 70%); /* Standard syntax */
				//background: linear-gradient(to right	, rgba(200,200,200,0.5) 0%, rgba(255,0,0,0) 2%), 
				//			linear-gradient(to bottom	, rgba(200,200,200,0.5) 0%, rgba(255,0,0,0) 2%), 
				//			linear-gradient(to top		, rgba(200,200,200,0.5) 0%, rgba(255,0,0,0) 2%),
				//			linear-gradient(to left		, rgba(200,200,200,0.5) 0%, rgba(255,0,0,0) 2%)
				
			}
			button {
				color: #181818;
				background: white;
				border: 1px solid grey;
			}
			levelChooser {
				color: white;
			}
			.buttonMain {
				z-index: 1;
				background-color: rgba(0, 0, 0, 0.2);
				border: 1px solid rgba(255, 255, 255, 0.2);
				color: white;
				padding: 50px 50px;
				text-align: center;
				text-decoration: none;
				display: inline-block;
				font-size: 16px;
				margin: 4px 2px;
				cursor: pointer;
				border-radius: 4px;
				//position: absolute;
				//top: 50%;
			}
			.buttonMain:active {
				background-color: rgba(200, 200, 200, 0.2);
			}			
			.button {
				//z-index: 1;
				background-color: rgba(0, 0, 0, 0.2);
				border: 1px solid rgba(255, 255, 255, 0.2);
				color: white;
				padding: 32px 32px;
				text-align: center;
				text-decoration: none;
				display: inline-block;
				font-size: 16px;
				margin: 4px 2px;
				cursor: pointer;
				border-radius: 4px;
				position: relative;
			}
			.button:active {
				background-color: rgba(200, 200, 200, 0.2);
			}	
			.indicator {
				//z-index: 1;
				background-color: transparent;
				border: 1px solid rgba(255, 255, 255, 0.2);
				color: white;
				padding: 32px 16px;
				text-align: center;
				text-decoration: none;
				display: inline-block;
				font-size: 16px;
				margin: 0px 2px;
				border-radius: 4px;
				width: 32px;
				//cursor: pointer;
			}
			.menuCenter {
				text-align: center;
				
				//position: absolute;
				//top: 50%;
				//bottom: 25%
				//left: 25%;
				//right: 25%;
			}
			.title {
				max-width:100%;
				max-height:100%;
			}
			#background_canvas {
				//z-index: 0;
				position: absolute;
				top: 0px;
				left: 0px;
				//border: 1px dotted red;
			}
			.buttonsMenu {
				position: relative;
				z-index: 20;
			}
			.buttonsMenuInGame {
				position: absolute;
				z-index: 20;
			}
			.inGameMenu {
				background-color: rgba(0, 0, 0, 0.8);
				position: absolute;
				text-align: center;
				z-index:21;
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
				//display: table;
				margin: auto;
			}
			.outer {
				display: table;
				position: absolute;
				height: 100%;
				width: 100%;
			}

			.middle {
				display: table-cell;
				vertical-align: middle;
			}

			.inner {
				margin-left: auto;
				margin-right: auto; 
				width: /*whatever width you want*/;
			}
			.buttonsContainer {
				display: table;
				position: relative;
				text-align: center;
				height: 100%;
				width: 100%;
				//top:50%;
			}
			.buttonsContainer2 {
				display: table-cell;
				vertical-align: middle;
			}
			.buttonsContainer3 {
				margin-left: auto;
				margin-right: auto; 
				width: 250px;
				//background-color: rgba(0, 0, 0, 0.2);
				//border: 1px solid rgba(255, 255, 255, 0.2);
				//border-radius: 4px;
				padding-top: 20px;
				padding-bottom: 20px;
			}
			.buttonInGameMenu {
				width: 200px;
				
			}
		</style>
		<script src="https://use.fontawesome.com/b7c5ba548a.js"></script>
	</head>
	<div id="buffer" hidden>
		<img id="small_object_L" 	src="Resources\Background\small_object_L.png" 		width="32" height="32" 		>
		<img id="small_object_M" 	src="Resources\Background\small_object_M.png" 		width="16" height="16" 		>
		<img id="small_object_S" 	src="Resources\Background\small_object_S.png" 		width="16" height="16" 		>
		<img id="big_object_1" 		src="Resources\Background\big_object_1.png" 		width="512" height="512" 	>
		<img id="big_object_2" 		src="Resources\Background\big_object_2.png" 		width="256" height="256" 	>
		<img id="big_object_3" 		src="Resources\Background\big_object_3.png" 		width="512" height="512" 	>
		<img id="cell3D_S" 			src="Resources\Bases\cell3D_S.png" 						width="256" height="256" 	>
		<img id="cell3D_M" 			src="Resources\Bases\cell3D_M.png" 						width="256" height="256" 	>
		<img id="cell3D_L" 			src="Resources\Bases\cell3D_L.png" 						width="256" height="256" 	>
		<img id="fungus3D_S" 		src="Resources\Bases\fungus3D_S.png" 					width="256" height="256" 	>
		<img id="fungus3D_M" 		src="Resources\Bases\fungus3D_M.png" 					width="256" height="256" 	>
		<img id="fungus3D_L" 		src="Resources\Bases\fungus3D_L.png" 					width="256" height="256" 	>
		<img id="virus3D_S" 		src="Resources\Bases\virus3D_S.png" 					width="256" height="256" 	>
		<img id="virus3D_M" 		src="Resources\Bases\virus3D_M.png" 					width="256" height="256" 	>
		<img id="virus3D_L" 		src="Resources\Bases\virus3D_L.png" 					width="256" height="256" 	>
	</div>
	<div id="background" style="z-index:0">
		<canvas id="background_canvas" ></canvas>
	</div>
	<div id="LevelChooser" class="menuCenter buttonsMenu">
		<img class="title" id="Title" 		src="Resources\Title.png"> <br>
		<button class="buttonMain" onclick="startGame(1)">1</button> 
		<button class="buttonMain" onclick="startGame(2)">2</button> 
		<button class="buttonMain" onclick="startGame(3)">3</button> <br>
		<button class="buttonMain" onclick="startGame(4)">4</button> 
		<button class="buttonMain" onclick="startGame(5)">5</button> 
		<button class="buttonMain" onclick="startGame(6)">6</button> <br>
		<button class="buttonMain" onclick="startGame(7)">TEST</button>
	</div>

	<div id="gameUI" hidden>
		<span id="buttons" class="buttonsMenuInGame">
			<button id="inGameMenuButton" class="button" onclick="showMenu()">
				<i class="fa fa-bars" aria-hidden="true"></i>
			</button>

		</span>
		<span id="inGameMenu" class="inGameMenu" hidden>
			<div id="buttonsContainer" class="buttonsContainer">
				<div id="buttonsContainer2" class="buttonsContainer2">
					<div id="buttonsContainer3" class="buttonsContainer3">
						<button class="button" onclick="changeSpeed(-1)">
							<i class="fa fa-minus" aria-hidden="true"></i>
						</button> 
						<span class = "indicator" id="speedIndicator" >1x</span> 
						<button class="button" onclick="changeSpeed(1)">
							<i class="fa fa-plus" aria-hidden="true"></i>
						</button>
						<button class="button menuCenter buttonInGameMenu" onclick="hideMenu()">
							<i class="fa fa-arrow-left" aria-hidden="true"></i> Back to game
						</button>
						<button id="backToChoice" class="button menuCenter buttonInGameMenu" onclick="hideMenu(); backToChoice()">
							<i class="fa fa-home" aria-hidden="true"></i> Select level
						</button>
						<button class="button menuCenter buttonInGameMenu" onclick="hideMenu(); reStart()">
							<i class="fa fa-refresh" aria-hidden="true"></i> Restart
						</button>
					</div>
				</div>	
			</div>
		</span>
		<div id="mainCanvas" style="z-index:10">
			<div id="selectionBox" hidden></div>
			<canvas id="drawSpace"></canvas>
		</div>
	</div>

	<!--<div id="infoField"></div>-->
	<body id="body" onresize="placeCanvas()">
		<!--<script src="game.js"></script>-->
		<script>
		/* feature and bug list
1. Once a base has been upgraded, re-dispatch the units rather than have them continue to upgrade
2. Restrict the defense to a given perimeter
10. randomAI should move to another sun if sure it can do something with it
11. The healing should be an AI decision per turn, not a continuous thing
12. randomAI should move only to bases closer to ennemy
14. the objects can move outside the canvas
15. If canvas is centered, mouse events gets scerwed up
16. Use of offset X works better than eventX for getting rid of the 8px correction
17. Sizing to screen size
18. Bases definition: simplify - auto multiply by canvas size and auto add 100 units
19. Better AI
20. Better presentation
21. Use material design colors
22. Generate color variation for the units
23. Give some relief to the units and bases
24. Use pre-rendering - important!
25. Get the statements out of the for loops by assigning variables first
26. Experimental: use pixel manipuation: http://stackoverflow.com/questions/23468218/draw-10-000-objects-on-canvas-javascript
27. Expand canvas further for avoiding clicking outside of the canvas / selection
28. Auto size canvas
29. add music
30. add right click to deselct
31. Better victory screen
*/

// all the background is contained in the window onload function

window.onload = function() {
	var background_canvas = document.getElementById('background_canvas');
	var backround_ctx = background_canvas.getContext('2d');
	// size background_canvas
	background_canvas.width = window.innerWidth-2;
	background_canvas.height = window.innerHeight;
	window.onresize = function() {
		background_canvas.width = window.innerWidth-2;
		background_canvas.height = window.innerHeight;
	};
	// variables
	var nLargeObjects = 20;
	var nSmallObjects = 20;
	var largeObjects = [];
	var smallObjects = [];
	var objects = [];
	var globalSpeed = 0.5;
	
	var small_object_L = document.getElementById("small_object_L");
	var small_object_M = document.getElementById("small_object_M");
	var small_object_S = document.getElementById("small_object_S");
	var big_object_1 = document.getElementById("big_object_1");
	var big_object_2 = document.getElementById("big_object_2");
	var big_object_3 = document.getElementById("big_object_3");
	//console.log(big_object_2);
	// functions
	function getRandom(min, max) {
		return Math.random() * (max - min) + min;
	}
	function selectRandom3(x,y,z) {
		var selected = Math.round(getRandom(1,3));
		if (selected == 1){
			return x
		}
		else if (selected == 2) {
			return y
		}
		else if (selected == 3) {
			return z
		}
	}
	// create large objects
	for (var i=0; i<nLargeObjects;i++) {
		var imgL = selectRandom3(big_object_1, big_object_2, big_object_3);
		var x_init = getRandom(0, background_canvas.width);
		var y_init = getRandom(0, background_canvas.height);
		var theta = getRandom(0, Math.PI*2);
		var speed = getRandom(0.1,0.5);
		var largeObject = {
			x: x_init,
			y: y_init,
			img: imgL,
			theta: theta,
			speed: speed,
		}
		objects.push(largeObject);
	}
	// Create small objects
	for (var i=0; i<nSmallObjects;i++) {
		var imgS = selectRandom3(small_object_L, small_object_M, small_object_S);
		var x_init = getRandom(0, background_canvas.width);
		var y_init = getRandom(0, background_canvas.height);
		var theta = getRandom(0, Math.PI*2);
		var speed = getRandom(0.5,1);
		var smallObject = {
			x: x_init,
			y: y_init,
			img: imgS,
			theta: theta,
			speed: speed,
		}
		objects.push(smallObject);
	}
	animateBackground();
	function animateBackground() {
		requestAnimationFrame(animateBackground);
		// render objects
		backround_ctx.clearRect(0, 0, background_canvas.width, background_canvas.height);

		for (var i=0; i<objects.length; i++) {
		
			object = objects[i];
			var y_min = 0 - object.img.height;
			var x_min = 0 - object.img.width;
			var x_max = background_canvas.width;
			var y_max = background_canvas.height;
			// detect and re-initialize objects outside of canvas
			if (object.x < x_min) {object.x = x_max;}
			else if (object.y < y_min) {object.y = y_max;}
			else if (object.x > x_max) {object.x = x_min}
			else if (object.y > y_max) {object.y = y_min}
			//backround_ctx.beginPath();
			//backround_ctx.arc(object.x, object.y, 2, 0, Math.PI * 2);
			//backround_ctx.closePath();
			//backround_ctx.fillStyle = "red";
			//backround_ctx.fill();
			// image
			object.y += globalSpeed*object.speed*Math.sin(object.theta);
			object.x += globalSpeed*object.speed*Math.cos(object.theta);
			var y_center = object.y;
			var x_center = object.x;
			//y_center =1;
			var w = object.img.width;
			var h = w;
			backround_ctx.drawImage(object.img, x_center, y_center, w, h);
		}
	}	
}
// click events_______________________________________________________________________________________

var selectionBox = document.getElementById('selectionBox'), x_init = 0, y_init = 0, x2 = 0, y2 = 0, x_final = 0, y_final = 0;
function reCalc() {
    var x3 = Math.min(x_init,x2);
    var x4 = Math.max(x_init,x2);
    var y3 = Math.min(y_init,y2);
    var y4 = Math.max(y_init,y2);
    selectionBox.style.left = x3 + 'px';
    selectionBox.style.top = y3 + 'px';
    selectionBox.style.width = x4 - x3 + 'px';
    selectionBox.style.height = y4 - y3 + 'px';
}

var ondown = function(x, y) {
    selectionBox.hidden = 0;
    x_init = x;
    y_init = y;
	x2 = x;
	y2 = y;
    reCalc();
};
var onmove = function(x, y) {
    x2 = x;
    y2 = y;
    reCalc();
};
var onup = function(x, y) {
    selectionBox.hidden = 1;
    x_final = x;
    y_final = y;
	// correction of coordinates for canvas position
	x_init_canvas = x_init - drawSpace.offsetLeft +8;
	y_init_canvas = y_init - drawSpace.offsetTop+8;
	x_final_canvas = x_final - drawSpace.offsetLeft+8;
	y_final_canvas = y_final - drawSpace.offsetTop+8;
	//alert(x_final + " " + y_final + " " + x_init + " " + y_init);
    if (distance(x_final, y_final, x_init, y_init) < config.clickTol) {
    	//alert("this looks like a click");
		setTargetOnClick(x_final_canvas,y_final_canvas);
		releaseSelection();
    }
    else {
    	//alert("This looks like a selection");
		// note that the release selection could be implemented as part of hthe selection function
		releaseSelection();
		selectObjectsInRectangle(x_final_canvas, y_final_canvas, x_init_canvas, y_init_canvas);
    }
};

onmousedown = function(e) { ondown(e.clientX, e.clientY); };
onmousemove = function(e) { onmove(e.clientX, e.clientY); };
onmouseup = function(e) { onup(e.clientX, e.clientY); };
ontouchstart = function(e) { ondown(e.changedTouches["0"].clientX, e.changedTouches["0"].clientY);};
ontouchend = function(e) { onup(e.changedTouches["0"].clientX, e.changedTouches["0"].clientY); };
ontouchmove = function(e) { onmove(e.changedTouches["0"].clientX, e.changedTouches["0"].clientY); };

function initializePlayers() {
	var players = [];
	var cell3D_S = document.getElementById("cell3D_S");
	var cell3D_M = document.getElementById("cell3D_M");
	var cell3D_L = document.getElementById("cell3D_L");
	var fungus3D_S = document.getElementById("fungus3D_S");
	var fungus3D_M = document.getElementById("fungus3D_M");
	var fungus3D_L = document.getElementById("fungus3D_L");
	var virus3D_S = document.getElementById("virus3D_S");
	var virus3D_M = document.getElementById("virus3D_M");
	var virus3D_L = document.getElementById("virus3D_L");
	var playerNone = {
		playerName: "none",
		playerColour: "grey",
		controlType: 2,
	}
	players.push(playerNone);
	var player1 = {
		playerName: "Plasma Cells",
		playerColour: "#00BCC5",
		controlType: 0, // 0 for human, 1 for CPU, 2 for none
		imgBase: [cell3D_S,cell3D_M,cell3D_L],
		baseSize: [150,200,256],
	}
	players.push(player1);
	var player2 = {
		playerName: "Fungus",
		playerColour: "#A0F500",
		controlType: 1,
		imgBase: [fungus3D_S,fungus3D_M,fungus3D_L],
		baseSize: [256,300,350],
	}
	players.push(player2);
	var player3 = {
		playerName: "Virus",
		playerColour: "#FF0700",
		controlType: 1,
		imgBase: [virus3D_S,virus3D_M,virus3D_L],
		baseSize: [150,200,256],
	}
	players.push(player3);
	// create a dummy player, corresponding to no one
	// done this because I was putting "0" into the ownership before, have the feeling it leads to type mismatches later on

	return players;
}
function newInitializeBases(players, canvas, selectedLevel) {
	var bases = [];
	var w = canvas.width;
	var h = canvas.height;
	// level 1: cog
	if (selectedLevel == 1) {
		var base1 = {
			ownership: players[0],
			x: 0.5 * w,
			y: 0.3 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base1);
		var base2 = {
			ownership: players[0],
			x: 0.775 * w,
			y: 0.2 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base2);
		var base3 = {
			ownership: players[1],
			x: 0.9 * w,
			y: 0.425 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 100,
			}
		bases.push(base3);
		var base4 = {
			ownership: players[0],
			x: 0.675 * w,
			y: 0.6 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base4);
		var base5 = {
			ownership: players[0],
			x: 0.625 * w,
			y: 0.875 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base5);
		var base6 = {
			ownership: players[2],
			x: 0.375 * w,
			y: 0.875 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 100,
			}
		bases.push(base6);
		var base7 = {
			ownership: players[0],
			x: 0.325 * w,
			y: 0.6 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base7);
		var base8 = {
			ownership: players[0],
			x: 0.1 * w,
			y: 0.425 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base8);
		var base9 = {
			ownership: players[3],
			x: 0.225 * w,
			y: 0.2 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 100,
			}
		bases.push(base9);
		var base10 = {
			ownership: players[0],
			x: 0.5 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base10);
	}
	// level 2: Circle
	else if (selectedLevel == 2) {
		var base1 = {
			ownership: players[0],
			x: 0.5 * w,
			y: 0.1 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base1);
		var base2 = {
			ownership: players[0],
			x: 0.7 * w,
			y: 0.15 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base2);
		var base3 = {
			ownership: players[0],
			x: 0.85 * w,
			y: 0.3 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base3);
		var base4 = {
			ownership: players[3],
			x: 0.9 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 100,
			}
		bases.push(base4);
		var base5 = {
			ownership: players[0],
			x: 0.85 * w,
			y: 0.7 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base5);
		var base6 = {
			ownership: players[0],
			x: 0.7 * w,
			y: 0.85 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base6);
		var base7 = {
			ownership: players[0],
			x: 0.5 * w,
			y: 0.9 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base7);
		var base8 = {
			ownership: players[2],
			x: 0.3 * w,
			y: 0.85 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 100,
			}
		bases.push(base8);
		var base9 = {
			ownership: players[0],
			x: 0.15 * w,
			y: 0.7 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base9);
		var base10 = {
			ownership: players[0],
			x: 0.1 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
			}
		bases.push(base10);
		var base11 = {
			ownership: players[0],
			x: 0.15 * w,
			y: 0.3 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			}
		bases.push(base11);
		var base12 = {
			ownership: players[1],
			x: 0.3 * w,
			y: 0.15 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 100,
			}
		bases.push(base12);
	}
	// level 3: triangle
	else if (selectedLevel == 3) {
		var base1 = {
			ownership: players[1],
			x: 0.125 * w,
			y: 0.125 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 100,
			}
		bases.push(base1);
		var base2 = {
			ownership: players[0],
			x: 0.375 * w,
			y: 0.125 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base2);
		var base3 = {
			ownership: players[0], // 0 means not owned
			x: 0.625 * w,
			y: 0.125 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			
		}
		bases.push(base3);
		var base4 = {
			ownership: players[2], // 0 means not owned
			x: 0.875 * w,
			y: 0.125 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 100,
			
		}
		bases.push(base4);
		var base5 = {
			ownership: players[0], // 0 means not owned
			x: 0.25 * w,
			y: 0.375 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			
		}
		bases.push(base5);
		var base6 = {
			
			ownership: players[0], // 0 means not owned
			x: 0.5 * w,
			y: 0.375 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 0,
			
		}
		bases.push(base6);
		var base7 = {
			
			ownership: players[0], // 0 means not owned
			x: 0.75 * w,
			y: 0.375 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			
		}
		bases.push(base7);
		var base8 = {
			
			ownership: players[0], // 0 means not owned
			x: 0.375 * w,
			y: 0.625 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			
		}
		bases.push(base8);
		var base9 = {
			
			ownership: players[0], // 0 means not owned
			x: 0.625 * w,
			y: 0.625 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
			
		}
		bases.push(base9);
		var base10 = {
			
			ownership: players[3], // 0 means not owned
			x: 0.5 * w,
			y: 0.875 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 100,
			
		}
		bases.push(base10);
	}
	else if (selectedLevel == 4) {
		var base1 = {
			ownership: players[1],
			x: 0.9455 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 100,
		}
		bases.push(base1);
		var base2 = {
			ownership: players[0],
			x: 0.72275 * w,
			y: 0.11419 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base2);
		var base3 = {
			ownership: players[2],
			x: 0.27725 * w,
			y: 0.11419 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 100,
		}
		bases.push(base3);
		var base4 = {
			ownership: players[0],
			x: 0.0545 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base4);
		var base5 = {
			ownership: players[3],
			x: 0.27725 * w,
			y: 0.88581 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 100,
		}
		bases.push(base5);
		var base6 = {
			ownership: players[0],
			x: 0.72275 * w,
			y: 0.88581 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base6);
		var base7 = {
			ownership: players[0],
			x: 0.797 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base7);
		var base8 = {
			ownership: players[0],
			x: 0.6485 * w,
			y: 0.24279 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base8);
		var base9 = {
			ownership: players[0],
			x: 0.3515 * w,
			y: 0.24279 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base9);
		var base10 = {
			ownership: players[0],
			x: 0.203 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base10);
		var base11 = {
			ownership: players[0],
			x: 0.3515 * w,
			y: 0.75721 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base11);
		var base12 = {
			ownership: players[0],
			x: 0.6485 * w,
			y: 0.75721 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base12);
		var base13 = {
			ownership: players[0],
			x: 0.6485 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base13);
		var base14 = {
			ownership: players[0],
			x: 0.57425 * w,
			y: 0.3714 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base14);
		var base15 = {
			ownership: players[0],
			x: 0.42575 * w,
			y: 0.3714 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base15);
		var base16 = {
			ownership: players[0],
			x: 0.3515 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base16);
		var base17 = {
			ownership: players[0],
			x: 0.42575 * w,
			y: 0.6286 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base17);
		var base18 = {
			ownership: players[0],
			x: 0.57425 * w,
			y: 0.6286 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base18);
		var base19 = {
			ownership: players[0],
			x: 0.5 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 0,
		}
		bases.push(base19);
	}
	else if (selectedLevel == 5) {
		var base1 = {
			ownership: players[1],
			x: 0.797 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 100,
		}
		bases.push(base1);
		var base2 = {
			ownership: players[0],
			x: 0.6485 * w,
			y: 0.24279 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 0,
		}
		bases.push(base2);
		var base3 = {
			ownership: players[2],
			x: 0.3515 * w,
			y: 0.24279 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 100,
		}
		bases.push(base3);
		var base4 = {
			ownership: players[0],
			x: 0.203 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 0,
		}
		bases.push(base4);
		var base5 = {
			ownership: players[3],
			x: 0.3515 * w,
			y: 0.75721 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 100,
		}
		bases.push(base5);
		var base6 = {
			ownership: players[0],
			x: 0.6485 * w,
			y: 0.75721 * h,
			levelCurrent: 1,
			levelMax: 3,
			initUnits: 0,
		}
		bases.push(base6);
	}
	else if (selectedLevel == 6) {
		var base1 = {
			ownership: players[1],
			x: 0.1 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 5,
			initUnits: 100,
		}
		bases.push(base1);
		var base2 = {
			ownership: players[2],
			x: 0.85 * w,
			y: 0.93301 * h,
			levelCurrent: 1,
			levelMax: 5,
			initUnits: 100,
		}
		bases.push(base2);
		var base3 = {
			ownership: players[3],
			x: 0.85 * w,
			y: 0.06699 * h,
			levelCurrent: 1,
			levelMax: 5,
			initUnits: 100,
		}
		bases.push(base3);
		var base4 = {
			ownership: players[0],
			x: 0.2875 * w,
			y: 0.60825 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base4);
		var base5 = {
			ownership: players[0],
			x: 0.475 * w,
			y: 0.71651 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base5);
		var base6 = {
			ownership: players[0],
			x: 0.6625 * w,
			y: 0.82476 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base6);
		var base7 = {
			ownership: players[0],
			x: 0.85 * w,
			y: 0.71651 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base7);
		var base8 = {
			ownership: players[0],
			x: 0.85 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base8);
		var base9 = {
			ownership: players[0],
			x: 0.85 * w,
			y: 0.28349 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base9);
		var base10 = {
			ownership: players[0],
			x: 0.6625 * w,
			y: 0.17524 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base10);
		var base11 = {
			ownership: players[0],
			x: 0.475 * w,
			y: 0.28349 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base11);
		var base12 = {
			ownership: players[0],
			x: 0.2875 * w,
			y: 0.39175 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base12);
		var base13 = {
			ownership: players[0],
			x: 0.35 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base13);
		var base14 = {
			ownership: players[0],
			x: 0.725 * w,
			y: 0.71651 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base14);
		var base15 = {
			ownership: players[0],
			x: 0.725 * w,
			y: 0.28349 * h,
			levelCurrent: 1,
			levelMax: 1,
			initUnits: 0,
		}
		bases.push(base15);
		var base16 = {
			ownership: players[0],
			x: 0.6 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 0,
		}
		bases.push(base16);
		
	}
	else if (selectedLevel == 7) {
		var base1 = {
			ownership: players[1],
			x: 0.3 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 4,
		}
		bases.push(base1);
		var base2 = {
			ownership: players[2],
			x: 0.6 * w,
			y: 0.5 * h,
			levelCurrent: 1,
			levelMax: 2,
			initUnits: 4,
		}
		bases.push(base2);
	}
	return bases;
}


// config and states

function getConfig(selectedLevel) {
	var canvas = document.getElementById("drawSpace");
	var players = initializePlayers();
	var defaultBaseSize = 32;
	var levelSizeIncrease = 12;
	var defaultUnitSize = 3;
	var baseMinDist = defaultBaseSize + levelSizeIncrease * 2 + defaultUnitSize + 2 // minimum distance from the base after spawning
	var baseMaxDist = baseMinDist + 20 // max distance from the base after spawning
	
	return {
		level: selectedLevel,
		// canvas manipulation
		canvas: canvas,
		ctx: canvas.getContext("2d"),
		// players and bases
		bases: newInitializeBases(players, canvas, selectedLevel),
		players: players,
		// timings
		turnLength: 25,
		// sizes
		defaultBaseSize: defaultBaseSize,
		levelSizeIncrease: levelSizeIncrease,
		defaultUnitSize: defaultUnitSize,
		baseMinDist: baseMinDist,
		baseMaxDist: baseMaxDist,
		pulseSizeIncrease: 1,
		radiusRandom: 15,
		neighbourDistance: Math.round(canvas.width/3),
		imgBaseSize: 256,
		// tolerances
		collisionTol: 6, // tolerance for declaring collision
		maxUnits: 100000,
		clickTol: 20, // for declaring a click rather than a rectangle selection
		baseClickTol: 3 * defaultBaseSize,
		// base values
		minConquership: 100,
		maxHealth: 100,
		maxUpgradePoints: 100,
		backgroundColors1: 	["#181818", "white",	"#97FEA5",	"#C7EEFE",	"#D4BEFE",	"#FEAFD5"],
		backgroundColors2:	["#404040", "#E8E8E8",	"#97FED9",	"#C7D3FE",	"#F5BEFE",	"#FEB0AF"],
		textColors: 		["white", 	"#181818",	"#181818",	"#181818",	"#181818",	"#181818"],
	}
}


function getInitialState() {
	//var timePace = 2;
	//var spawnRate = 2000/timePace;
	
	return {
		objects: [],
		timePace: 1,
		spawnRate: function() { return 2000 / this.timePace; },
		speedUnit: function() { return 0.03 * this.timePace; },
		targetTol: function() { return 6 + Math.round(this.timePace/10)*6; }, // tolerance for declaring a unit on base - increase this if state.timePace increase, to allow the software to catch positions on time
		lastTurn: 0,
		// Game states
		gameWon: false,
		playerAlive: null,
		prevTime: Date.now(),
		themeID: 0,
		abandon: false,
		previousTimePace:1,
	};
}

function backToChoice() {
	state.abandon = true;
	document.getElementById('gameUI').hidden = true;
	document.getElementById('LevelChooser').hidden = false;
}
function showMenu() {
	document.getElementById('inGameMenu').hidden = false;
	pauseGame();
	
}
function hideMenu() {
	document.getElementById('inGameMenu').hidden = true;
	unPauseGame();
}

function placeCanvas() {
	// Size the canvas
	var buttons = document.getElementById('buttons');
	
	//console.log(buttons);
	//console.log(buttons.clientHeight);
	if (window.innerWidth > window.innerHeight) {

		
		
		drawSpace.height = window.innerHeight;//- buttons.clientHeight;
		drawSpace.width = drawSpace.height;

		//drawSpace.style.paddingLeft = 100;
	}
	else {
		drawSpace.width = window.innerWidth-8;
		drawSpace.height = drawSpace.width;
	}
	// Center the canvas using margins - so the click events are not confused...
	drawSpace.style.marginLeft = (window.innerWidth - drawSpace.width) /2;
	
}
function getArtworkBase() {
	return {
		cell3D_S: document.getElementById("cell3D_S"),
	}
}

function reStart() {
	startGame(config.level);
}

function setTheme() {
	//document.getElementById("body").style.backgroundColor = config.backgroundColors1[state.themeID];
	document.getElementById("body").style.background = "linear-gradient(" + config.backgroundColors1[state.themeID] + "," + config.backgroundColors2[state.themeID] + ")";
	document.getElementById("speedIndicator").style.color = config.textColors[state.themeID];
}
function setSpeedIndicator() {
	document.getElementById("speedIndicator").innerHTML = state.timePace + "x";
}
function startGame(level) {
	// hide the level choice UI and show the game div
	document.getElementById('LevelChooser').hidden = true;
	document.getElementById('gameUI').hidden = false;
	// determine canvas size and position
	placeCanvas();
	// Initialize the config and state
	config = getConfig(level);
	state = getInitialState();
	artworkBase = getArtworkBase();
	// Write the current speed
	setSpeedIndicator();
	// Complete the base definition and initializes them
	initializeBases();
	// Off we go
	animate();
}
function changeSpeed(increment) {
	if ((state.timePace == 1 && increment < 0) || (state.timePace == 5 && increment >0)) {
		//do nothing
	}
	else {
		state.previousTimePace = state.timePace;
		state.timePace = state.timePace + increment;
		if (state.timePace == 0) {
			document.getElementById("speedIndicator").innerHTML = "||"
		}
		else {
			setSpeedIndicator();
		}
	}
}
function pauseGame() {
	state.previousTimePace = state.timePace;
	state.timePace = 0;
	document.getElementById("speedIndicator").innerHTML = "||";
}
function unPauseGame() {
	state.timePace = state.previousTimePace;
	setSpeedIndicator();
}
function pauseUnPause() {
	
	if (state.timePace==0) {
		unPauseGame();
	}
	else {
		pauseGame();
	}
}
function changeTheme() {
	if (state.themeID < config.backgroundColors1.length - 1) {
		state.themeID += 1;
	}
	else {
		state.themeID = 0;
	}
	setTheme();
}

function releaseSelection() {
	for (var i = 0; i < state.objects.length; i++) {
        var object = state.objects[i];
		object.isSelected = false;
    }
}
function selectObjectsInRectangle(x_final, y_final, x_init, y_init){
	//alert("Started select function, received params " + x_final + "," + y_final + "," + x_init + "," + y_init);
	// the "-8" is there for correcting for browser margin - try to clean that later
	var x_top_left = Math.min(x_final,x_init);
	var y_top_left = Math.min(y_final,y_init);
	var x_bottom_right = Math.max(x_final,x_init);
	var y_bottom_right = Math.max(y_final,y_init);
	//alert("computed the following params for top left, bottom right: " + x_top_left + "," + y_top_left + "," + x_bottom_right + "," + y_bottom_right);
	for (var i = 0; i < state.objects.length; i++) {
        var object = state.objects[i];
		if (object.controlType == 0 && object.hasBeenHit == false) {
			//alert("identified object " + i + " as controlled by human");
			//alert("object x: " + object.x + ",y: " + object.y);
			//alert("object x: " + object.x + ",y: " + object.y + "x,y top left: " + x_top_left + "," + y_top_left + "x,y bottom right" + x_bottom_right + "," + y_bottom_right);
			if (object.x >= x_top_left && object.x <= x_bottom_right && object.y >= y_top_left && object.y <= y_bottom_right) {
				object.isSelected = true;
				//alert("detected within the selection");
			}
		}
		//alert("Completed a loop through object");
    }
}
function initializeBases() { // this function fills all base properties based on ownership
//initialisation of the variables of the bases according to ownership
// loop through bases
	for (var i = 0; i < config.bases.length; i++) {
		var base = config.bases[i];
		base.lastSpawn = -1;
		base.upgradePoints = 0;
		base.isUnderAttack = false;
		base.health = config.maxHealth;
		base.colour = base.ownership.playerColour;
		base.id = i;
		// if base is owned, inherit player properties
		if (base.ownership != config.players[0]) {
			base.controlType = base.ownership.controlType;
			base.conquership = config.minConquership;
			// spawn initial units
			for (j=0; j < base.initUnits/base.levelCurrent; j++) {
				spawnUnit(base);
			}
		}
		// if base is not owned, set colour to grey
		else {
			base.controlType = 2;
			base.conquership = 0;
		}
	}
}
function setTargetOnClick(x,y) {
	// correction 8 px of margin from the browser - try to clean that later
	//var x = event.pageX - 8;
	//var y = event.pageY - 8;
	x = x-8;
	y = y-8;
	var clickedBaseID = isClickOnBase(x,y);
	var base = config.bases[clickedBaseID];
	// loop through objects for giving them new target coordinates
	for (var i = 0; i < state.objects.length; i++) {
		var object = state.objects[i];
		
		// only do that for objects controlled by human and currently selected
		if (object.controlType == 0 && object.hasBeenHit == false && object.isSelected == true) 
		{
			object.defensiveMode = false;
			// if clicked on a base, set coordinates to base center
			if (clickedBaseID != -1) {
				//alert("clicked on base with ID " + clickedBaseID);
				object.targetY = base.y;
				object.targetX = base.x;
			}
			// otherwise set to mouse coordinates
			else {
				// introduce some randomness for not having all units on a single spot
				object.targetY = y + Math.random()*config.radiusRandom - Math.random()*config.radiusRandom;
				object.targetX = x + Math.random()*config.radiusRandom - Math.random()*config.radiusRandom;
			}
		}
	}
}
function isOnBase (object) { // this function returns the ID of the clicked base, or -1 if not clicked
	var baseID = -1;
	for (var b = 0; b < config.bases.length; b++) {
		var base = config.bases[b];
		if (distance(object.x, object.y, base.x, base.y) < config.defaultBaseSize && object.targetX == base.x && object.targetY == base.y) {
			baseID = b;
		}
	//alert("click X: " + objectX + " ,Y: " + objectY + "base X: " + base.x + ", Y: " + base.y + "selected base: " + base.colour + " statement: " + statement);
	}
return baseID;
}
function isClickOnBase (x,y) {
	var baseID = -1;
	for (var b = 0; b < config.bases.length; b++) {
		var base = config.bases[b];
		if (distance(x, y, base.x, base.y) < config.baseClickTol) {
			baseID = b;
		}
	//alert("click X: " + objectX + " ,Y: " + objectY + "base X: " + base.x + ", Y: " + base.y + "selected base: " + base.colour + " statement: " + statement);
	}
return baseID;
}
function spawnUnit(base) {
// go through the spawning loop as many times as there are levelCurrent
for (var i = 0; i < base.levelCurrent; i++) {
	
    // create the new object
    var object = {
		// start by inheriting a few properties from the mother base
		ownership: base.ownership,
        colour: base.colour,
        x: base.x,
        y: base.y,
		targetX: base.x,
		targetY: base.y,
		controlType: base.controlType,
        // choose a direction for spawning
        // theta: Math.random() * 2* Math.PI,
		// initialize the hasBeenHit property
		hasBeenHit: false,
		isSelected: false,
		defensiveMode: true,
		motherBase: base,
		isDefending: false,
		isHidden: false,
    }
	//console.log("spawning new " + object.colour + " object with coordinates " + object.x + ", " + object.y);
	setTargetAroundBase(object, base)
    // add the new object to the objects[] array
    state.objects.push(object);
    }
}
function setTargetAroundBase(object, base) {
	randomDist =  config.baseMinDist + (config.baseMaxDist-config.baseMinDist)*Math.random();
	randomAngle = Math.random() * 2* Math.PI;
	object.targetY = base.y + randomDist * Math.sin(randomAngle);
	object.targetX = base.x + randomDist * Math.cos(randomAngle);
	object.defensiveMode = true;
	object.motherBase = base;
}
//function distance(x1, y1, x2, y2) { return (Math.abs(x1-x2) + Math.abs(y1-y2))}
function distance(x1, y1, x2, y2) { return Math.sqrt(Math.pow(x1-x2, 2)+Math.pow(y1-y2,2)) }
function drawUnit(object) {
	if (object.hasBeenHit == false) {
		if (object.isSelected == false) {
			if (object.isHidden == true) {
					// draw the unit in green if has been hit for debugging purposes
			config.ctx.beginPath();
			config.ctx.arc(object.x, object.y, 3, 0, Math.PI * 2);
			config.ctx.closePath();
			//config.ctx.stroke();
			config.ctx.fillStyle = "green";
			//config.ctx.fill();
			}
			else {
			// draw the unit in the player color
			config.ctx.beginPath();
			config.ctx.arc(object.x, object.y, config.defaultUnitSize, 0, Math.PI * 2);
			config.ctx.closePath();
			config.ctx.strokeStyle = "black";
			config.ctx.lineWidth = 1;
			//config.ctx.shadowColor = 'black';
			//config.ctx.shadowBlur = 4;
			config.ctx.shadowOffsetX = 2;
			config.ctx.shadowOffsetY = 2;
			//config.ctx.stroke();
			config.ctx.fillStyle = object.colour;
			//config.ctx.fill();
			}
		}
		else {
			// draw the unit in yellow if selected
			config.ctx.beginPath();
			config.ctx.arc(object.x, object.y, config.defaultUnitSize, 0, Math.PI * 2);
			config.ctx.closePath();
			config.ctx.strokeStyle = "black";
			config.ctx.lineWidth = 1;
			//config.ctx.stroke();
			config.ctx.fillStyle = "yellow";
			//config.ctx.fill();
		}
	}
	else
	{
		// draw the unit in green if has been hit for debugging purposes
        config.ctx.beginPath();
        config.ctx.arc(object.x, object.y, 3, 0, Math.PI * 2);
        config.ctx.closePath();
        //config.ctx.stroke();
        config.ctx.fillStyle = "green";
        //config.ctx.fill();
	}
}
function drawTarget(object) {
			// draw the target when still moving
			config.ctx.beginPath();
			config.ctx.arc(object.targetX, object.targetY, 3, 0, Math.PI * 2);
			config.ctx.closePath();
			//config.ctx.stroke();
			config.ctx.fillStyle = "LightGrey";
			//config.ctx.fill();	
}
function drawExplosion(object) {
	x = object.x;
	y = object.y;
	xRand = Math.random()*100
	yRand = Math.random()*100
	config.ctx.beginPath();
	config.ctx.moveTo(x+xRand,y+yRand);
	config.ctx.lineTo(x-xRand,y-yRand);
	config.ctx.moveTo(x-xRand, y+yRand);
	config.ctx.lineTo(x+xRand,y-yRand);
	config.ctx.lineWidth = 1;
	config.ctx.strokeStyle = object.colour;
	config.ctx.stroke();
}
function drawBase(base) {
	var baseSize = 0;
	var level = null;
	// draw the new image
	if (base.ownership != config.players[0] && base.conquership == 100) {
		var imgBase = null;
		// cap the level to 3, afterwards draw base type 3 always
		if (base.levelCurrent >= 3) {level = 2}
		else {level = base.levelCurrent-1;}
		imgBase = base.ownership.imgBase[level]
		config.ctx.drawImage(imgBase, base.x-base.ownership.baseSize[level]/2, base.y-base.ownership.baseSize[level]/2, base.ownership.baseSize[level], base.ownership.baseSize[level]);
	}
	// draw the base a bit larger if it has just spawned - this gives a pulse
	if (base.hasJustSpawned == true) { baseSize = config.defaultBaseSize + config.pulseSizeIncrease; }
	else { baseSize = config.defaultBaseSize; }
	// size the bases according to their current level
	baseSize = baseSize + (base.levelCurrent - 1) * config.levelSizeIncrease;

	// MAX LEVEL: draw circles around the bases showing their maximum level
	for (var i = base.levelCurrent; i < base.levelMax; i++) {
		config.ctx.beginPath();
		config.ctx.arc(base.x, base.y, config.defaultBaseSize + i * config.levelSizeIncrease, 0, Math.PI * 2);
		//config.ctx.closePath();
		config.ctx.strokeStyle = 'rgba(255,255,255,0.4)';
		config.ctx.lineWidth = 3;
		config.ctx.stroke();
	}
	
	// UPGRADE status: show current upgrade status
	config.ctx.beginPath();
	config.ctx.arc(base.x, base.y, config.defaultBaseSize + base.levelCurrent * config.levelSizeIncrease, 0, Math.PI * 2 * base.upgradePoints/config.maxUpgradePoints);
	//config.ctx.closePath();
	config.ctx.strokeStyle = base.ownership.playerColour;
	config.ctx.lineWidth = 3;
	config.ctx.stroke();
	
	// actually draw the base
	if (base.ownership == config.players[0] || base.conquership != 100) {
		config.ctx.beginPath();
		config.ctx.arc(base.x, base.y, baseSize, 0, Math.PI * 2);
		config.ctx.closePath();
		config.ctx.strokeStyle = "black";
		config.ctx.lineWidth = 1;
		//config.ctx.stroke();
		config.ctx.fillStyle = 'rgba(150,150,150,0.4)';
		config.ctx.fill();
	}

	// CONQUERSHIP: draw a circle around the base representing the conquership
	if (base.conquership < config.minConquership) {
		config.ctx.beginPath();
		config.ctx.arc(base.x, base.y, baseSize + 1, 0, Math.PI * 2 * base.conquership/config.minConquership);
		//config.ctx.closePath();
		config.ctx.strokeStyle = base.ownership.playerColour;
		config.ctx.lineWidth = 3;
		config.ctx.stroke();
	}
	// HEALTH: draw a circle around the base is the health is not 100%
	if (base.health < config.maxHealth) {
		config.ctx.beginPath();
		config.ctx.arc(base.x, base.y, baseSize + 1, 0, Math.PI * 2 * (base.health/config.maxHealth));
		//config.ctx.closePath();
		config.ctx.strokeStyle = "red";
		config.ctx.lineWidth = 3;
		config.ctx.stroke();
	}
	// NEIGHBOUR DISTANCE: draw a circle showing the max distance for declaring a neighbour
	/*
	config.ctx.beginPath();
	config.ctx.arc(base.x, base.y, config.neighbourDistance, 0, Math.PI * 2);
	//config.ctx.closePath();
	config.ctx.strokeStyle = "LightGrey";
	config.ctx.setLineDash([3,3]);
	config.ctx.lineWidth = 1;
	config.ctx.stroke();
	config.ctx.setLineDash([]);
	*/

}
function goToCoordinates(object, timeDiff) {
// compute r and theta
		//var distFromCoord = distance(object.x, object.y, object.targetX, object.targetY);
		var angleFromCoord = Math.atan2(object.y-object.targetY, object.x-object.targetX); // In radians
		// move only if the next move gets you closer to your target
		// the issue was that the timeDiff kept increasing when the window lost focus (as code was paused), 
		// resulting in huge timeDiff when resuming, and the objects being sent super far
		var newObjectY = object.y -state.speedUnit() * timeDiff * Math.sin(angleFromCoord);
		var newObjectX = object.x -state.speedUnit() * timeDiff * Math.cos(angleFromCoord);
		var currentDist = distance(object.x, object.y, object.targetX, object.targetY);
		var nextDist = distance(newObjectX, newObjectY, object.targetX, object.targetY);
		if (nextDist < currentDist)
		{
			object.y = newObjectY;
			object.x = newObjectX;
			//console.log("increment for " + object.colour + " object" + (-speedUnit * timeDiff))
			// draw the target when still moving
			//drawTarget(object);
		}
}
function checkCollision (object) {
	for (var j = 0; j < state.objects.length; j++) {
		var collider = state.objects[j];
		var dist = distance(object.x, object.y, collider.x, collider.y);
		var justHid = false;
		// if there is someone
		if (dist < config.collisionTol && collider.hasBeenHit == false && object.hasBeenHit == false) {
			// if object not already hit & the other is an ennemy & the ennemy has not already been hit
			if (collider.colour !== object.colour) {
				killUnit(object);
				killUnit(collider);
			}
			// behaviour if the object is a friend
			/*
			else {
				//if (collider.isHidden == false) {
					object.isHidden = true;
					justHid = true;
				//}
			}
			*/
			
		}
		//else {object.isHidden = false;}
	}
	if (justHid == false) {
		object.isHidden = false;
	}
}
function killUnit(object) {
	object.hasBeenHit = true;
	drawExplosion(object);
}
function updateBaseProperties(base) {
	if (base.ownership != config.players[0]) {
		base.colour = base.ownership.playerColour;
		base.controlType = base.ownership.controlType;
		//base.health = 100;
		//base.conquership = 100;
	}
	// if base is not owned, set colour to grey
	else {
		base.colour = "grey";
		base.controlType = 2;
		base.ownership = config.players[0];
		//base.health = 0;
		//base.conquership = 0;
	}
}
function findClosestAttacker(object) {
	var prevDist = null;
	for (j=0; j < state.objects.length; j++) {
		var other = state.objects[j];
		// if ennemy targeted to mother base
		if (other.colour != object.colour) {// && other.targetX == object.motherBase.x && other.targetY == object.motherBase.y) {
			var dist = distance(object.motherBase.x, object.motherBase.y, other.x, other.y); + 0.1 * distance(object.x, object.y, other.x, other.y);
			if (dist < prevDist || prevDist == null) {
				var attacker = other;
				prevDist = dist;
			}	
		}
	}
	return attacker;
}
function setTarget(object, target) {
	object.targetX = target.x;
	object.targetY = target.y;
}
// AI functions from here
function randomAI(player) {
	//console.log(player.playerColour + " uses randomAI");
	for (var i=0; i<config.bases.length; i++) {
		base = config.bases[i];
		// for all bases owned by player
		if (base.colour == player.playerColour) {
			if (base.levelCurrent < base.levelMax) {
				if (Math.random() >= 0.5) {
					//console.log(player.playerColour + " decides to upgrade base " + i);
					upgrade(base);
				}
				else if (Math.random() >= 0.5) {
					//console.log(player.playerColour + " decides to stay idle");
				}
				else {
					//console.log(player.playerColour + " decides to move its unit from base " + i + " to other base");
					// move all soldiers to a base closer to the enemy
					moveToRandomNeighbour(base);
				}
			}
			else {
				if (Math.random() >= 0.5) {
					//console.log(player.playerColour + " decides to move its unit from base " + i + " to other base");
					// move all soldiers to a base closer to the enemy
					moveToRandomNeighbour(base);
				}
				else {//console.log(player.playerColour + "decides to stay idle");
				}
			}
		}
	}
}
function moveToRandomNeighbour(base) {
	// get the array of candidate neighbours
	var neighbours = findNeighboursCloserToEnnemy(base);
	var choosedNeighbourID = Math.round(Math.random() * (neighbours.length-1))
	var choosedNeighbour = neighbours[choosedNeighbourID];
	//console.log(choosedNeighbour.id);
	for (j = 0; j < state.objects.length; j++) {
		object = state.objects[j];
		// take all the objects having this base as motherbase
		if (object.motherBase == base) {
			//console.log("line 676, choosed neighbour is base " + choosedNeighbour.id + ". Position in neighbours vecotr is " + choosedNeighbourID);
			setTarget(object, choosedNeighbour);
			object.defensiveMode = false;
		}
	}
}
function upgrade(base) {
	// first, count the units currently defending the base
	var nDefenders = 0;
	for (var i=0; i<state.objects.length; i++) {
		var object = state.objects[i];
		if (object.motherBase == base && object.defensiveMode == true) {
			nDefenders = nDefenders + 1;
		}
	}
	// if enough units to upgrade the base, then select the exact amount required and upgrade
	if (nDefenders >= (config.maxUpgradePoints - base.upgradePoints)) {
		var nUpgraders = 0;
		for (var i=0; i<state.objects.length; i++) {
			var object = state.objects[i];
			if (object.motherBase == base && object.defensiveMode == true && nUpgraders < (config.maxUpgradePoints - base.upgradePoints)) {
				//console.log("line 697");
				setTarget(object, base);
				nUpgraders = nUpgraders + 1;
			}
		}
	}
	else {//console.log("Not enough units to upgrade base");
	}
	
}
function findNeighboursCloserToEnnemy(base) {
	var neighbours = [];
	for (var i = 0; i < config.bases.length; i++) {
		var otherBase = config.bases[i];
		var minDistToEnnemyFromOther = minDistToEnnemy(base.ownership, otherBase);
		var minDistToEnnemyFromThis = minDistToEnnemy(base.ownership, base);
		// if it is another base
		if (otherBase != base) {
			// if other base close enough for being a neighbour
			if (distance(base.x, base.y, otherBase.x, otherBase.y) <= config.neighbourDistance) {
				// and the other base is closer to the ennemy
				if (minDistToEnnemyFromOther <= minDistToEnnemyFromThis) {
					// add the base the the vector of neighbours
					neighbours.push(otherBase);
				}
			}
		}
	}
	return neighbours;
}
function minDistToEnnemy(player, base) {
	// make sure to consider when there is no enemy anymore
	var distToOther = null;
	var minDist = null;
	// Loop through bases
	for (var i=0 ; i < config.bases.length ; i++) {
		var otherBase = config.bases[i];
		// if base not owned by the player
		// AND the base is not unconquered
		// then it is an enemy base
		if (otherBase.ownership != player && otherBase.ownership != config.players[0]) {
			// compute the distance between the base and the ennemy base
			distToOther = distance(base.x, base.y, otherBase.x, otherBase.y);
			// if this distance is shorter than the previous one, replace it
			if (distToOther < minDist || minDist == null) {
				minDist = distToOther;
			}
		}
	}
	if (minDist == null) {minDist = 0; console.log("looks like there is no more enemies, so no minimum distance to enemy to calculate");}
	return minDist;
}
function animate(time) {
	// Behaviour at the end of the game
	if (state.gameWon == true) {
		console.log("Get out of the animate function since game won declared");
		var minutesWon = Math.floor(time/60000);
		var secondsWon = Math.round((time/1000) - (60 * minutesWon));
		config.ctx.clearRect(0, 0, config.canvas.width, config.canvas.height);
		config.ctx.fillStyle = state.playerAlive.playerColour;
		config.ctx.font = "30px Arial";
		config.ctx.textAlign = "center";
		config.ctx.textBaseline = "middle";
		//config.ctx.fillText(base.levelCurrent, base.x, base.y);
		config.ctx.fillText("Victory for " + state.playerAlive.playerName + " in " + minutesWon + " min, " + secondsWon + " sec", config.canvas.width/2, config.canvas.height/2);
		return;
	}
	if (state.abandon == true) {
		return;
	}
    // request another animation frame (always first call)
	// requestAnimationFrame pauses when the windows loses focus. If undesired, use setInterval instead
    requestAnimationFrame(animate);
	
	//var time = date.now();
	var timeDiff = time - state.prevTime;

	var newObjects = [];

	// Call the AI when it is time
	if (time > state.lastTurn + config.turnLength * state.spawnRate()) {
		for (var p = 1; p < config.players.length; p++) {
			player = config.players[p];
			if (player.controlType == 1) {
				//console.log("call AI move for player " + player.playerColour);
				randomAI(player);
			}
		}
		state.lastTurn = time;
	}

    // clear the canvas so all objects can be 
    // redrawn in new positions
    config.ctx.clearRect(0, 0, config.canvas.width, config.canvas.height);

	// loop through bases
	for (var i = 0; i < config.bases.length; i++) {
        var attackersNum = 0;
		var base = config.bases[i];
		base.hasJustSpawned = false;
		// check if the base is under attack
		for (var j = 0; j < state.objects.length; j++) {
			object = state.objects[j];
			// if ennemy with coordinates set to this base
			if (object.colour != base.colour && object.targetX == base.x && object.targetY == base.y) {
				attackersNum += 1;
			}
		}
		if (attackersNum > 0) { base.isUnderAttack = true; }
		else { base.isUnderAttack = false; }
		// update/upgrade
		if (base.upgradePoints == config.maxUpgradePoints) {
			base.levelCurrent = base.levelCurrent + 1;
			base.upgradePoints = 0;
			//console.log("Base " + i + ", owned by " + base.colour + " has upgraded to " + base.levelCurrent);
		}
		// Base death
		// if base health or conquership reaches 0, set it to not owned
		if (base.health == 0 || base.conquership == 0) {
			base.ownership = config.players[0];
			base.conquership = 0;
			base.health = config.maxHealth;
			base.levelCurrent = 1;
			base.upgradePoints = 0;
			updateBaseProperties(base);
		}
		// spawn the units
		// if the base is owned and conquered by someone
		if (base.ownership != config.players[0] && base.conquership >= config.minConquership) {
			// limit max number of objects
			if (state.objects.length < config.maxUnits) {
				// see if it is time to spawn a new object
				if (time > (base.lastSpawn + state.spawnRate())) 
				{
					base.lastSpawn = time;
					base.hasJustSpawned = true; // Comment for de-activating pulse
					spawnUnit(base);
				}
			}
		}
		// draw the base
		drawBase(base);
    }
    // loop through units
	// main loop containing logics
    for (var i = 0; i < state.objects.length; i++) {
        var object = state.objects[i];
		checkCollision(object);
		// do not compute anything for objects which are already "dead"
		if (object.hasBeenHit == false) {
			var distFromCoord = distance(object.x, object.y, object.targetX, object.targetY);
			var onBaseID = isOnBase(object);
			// first, let the defenders find an enemy if the base is attacked
			if (object.defensiveMode == true) {
				//console.log("detected a " + object.colour + " defender with mother base " + object.motherBase.isUnderAttack);
				if (object.motherBase.isUnderAttack == true) 
				{
					//console.log("a defenser sees base under attack");
					var attacker = findClosestAttacker(object);
					//console.log("line 818");
					setTarget(object, attacker);
					object.isDefending = true;
				}
				else {
					if (object.isDefending == true) {
						setTargetAroundBase(object, object.motherBase);
						object.isDefending = false;
					}
					// if the base has been wounded, and not all healers have yet been assigned
					/*
					if (object.motherBase.health < config.maxHealth) {// && healers < (config.maxHealth - object.motherBase.health)) {
						setTarget(object, object.motherBase);
					
					}
					*/
				}
			}
			// if not yet on position, move to target position
			if (distFromCoord > state.targetTol()) { goToCoordinates(object, timeDiff); }
			// if on position and on a base
			else if (onBaseID != -1) {
				var base = config.bases[onBaseID];
				// if friendly base
				if (base.ownership == object.ownership) {
					// if base is fully conquered
					if (base.conquership >= config.minConquership) {
						// if base health is not full, increase base health and kill unit
						if (base.health < config.maxHealth) {
							base.health = base.health + 1;
							killUnit(object);
						}
						// if the base is already at max level, just dispatch units around the base
						else if (base.levelCurrent == base.levelMax) {
							setTargetAroundBase(object, base);
							goToCoordinates(object, timeDiff);
						}
						// if the base can still evolve, add upgrade points
						else if (base.levelCurrent < base.levelMax && base.upgradePoints < config.maxUpgradePoints) {
							base.upgradePoints = base.upgradePoints + 1;
							killUnit(object);
						}
					}
					// if on a base that the player has started to conquer
					else {
						base.conquership = base.conquership + 1;
						killUnit(object);
						if (base.conquership == config.minConquership) {
							updateBaseProperties(base);
							//console.log("base "+ base.id +" has been conquered by " + base.colour);
						}
					}
				}
				// if on a base with no ownership, set ownership
				if (base.ownership == config.players[0]) 
				{
					base.ownership = object.ownership;
					killUnit(object);
					base.conquership = 1;
				}

				// if on an enemy base
				if (base.ownership != object.ownership) {
					// if the ennemy has only started to conquer, decrease his conquership
					if (base.conquership > 0 && base.conquership < config.minConquership) {
						base.conquership = base.conquership - 1;
						killUnit(object);
					}
					// if health, decrease health
					else if (base.health > 0) {
						base.health = base.health - 1;
						killUnit(object);
					}
					

				}
			}

		}			
    }
	// second loop for removing all dead objects from the objects vector
	for (var i = 0; i < state.objects.length; i++) {
        var object = state.objects[i];
		if (object.hasBeenHit == true) {
			//objects.splice(i, 1);
		}
		else {
			newObjects.push(object);
		}	
    }
	
	state.objects = newObjects;
	
	// third loop for drawing the remaining objects in the right position
	for (var i = 0; i < state.objects.length; i++) {
        var object = state.objects[i];
		drawUnit(object);
		//config.ctx.stroke();
		config.ctx.fill();
    }
	// victory condition
	var nAlive = 0;
	var nBases = 0;

	//document.getElementById("infoField").innerHTML = ""
	for (p=1;p<config.players.length;p++) {
		player = config.players[p];
		//console.log(player.playerName);
		for (b=0;b<config.bases.length;b++) {
			var base = config.bases[b];
			if (base.ownership == player && base.conquership == config.minConquership) {
				nBases = nBases + 1;
			}
		}
		//document.getElementById("infoField").innerHTML += player.playerName + " has " + nBases + " bases <br>";
		if (nBases > 0) {
			nAlive = nAlive + 1;
			state.playerAlive = player;
		}
		
		nBases = 0;
	}
	//document.getElementById("infoField").innerHTML += nAlive + " players are alive <br>";
	if (nAlive == 1) {
		//alert(state.playerAlive.playerName + " has won in " + (time/1000)/60 + " minutes");
		//document.getElementById("infoField").innerHTML += state.playerAlive.playerName + " has won!!!! <br>";
		state.gameWon = true;
	}
	
	// Update the previous timestamp
	state.prevTime = time;
}
</script>
	</body>
</html>
