<!doctype html>
<!--
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  PROCESS GRID v4.9.1
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  A web-based process simulation and flowsheet design tool.
  
  ARCHITECTURE OVERVIEW:
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  1. COMPONENT SYSTEM
     - ComponentRegistry: Stores chemical components with physical properties
     - Properties: MW, Tc, Pc, Tb, Ï‰, Antoine coefficients
     - Components: H2O, O2, H2, N2, Ar, CH4
  
  2. MODEL REGISTRY
     - Extensible physics kernel system
     - Model types: pvt_gas, pvt_liquid, thermo, vle, flash, units
     - Active model selection persisted with scene
     - Unit systems: SI, SI (bar), Imperial
  
  3. STREAM TYPES
     - MATERIAL: T, P, n (molar flows), phase, vaporFraction
     - HEAT: {capacity, actual, demand} in W (watts)
     - MECHANICAL: {capacity, actual, demand} in W (watts)
     - ELECTRICAL: {capacity, actual, demand, curtailmentFactor} in W (watts)
     
     Non-material stream semantics (v4.1.0):
       capacity = maximum the source can provide (set by producer)
       actual   = power actually transferred after demand resolution
       demand   = power the consumer wants (propagated backward)
       available = deprecated alias for capacity (read-only)
  
  4. UNIT OPERATIONS
     - Category-based organization with color coding
     - Extensible registry pattern
     - Current units: Source, Sink
     - Parameters automatically converted between unit systems
  
  5. THERMODYNAMICS
     - Flash calculations: TP flash with Rachford-Rice algorithm
     - VLE: Raoult's Law (ideal) with K-values
     - Antoine equation for vapor pressure
     - Phase constraints: V (vapor), L (liquid), VL (flash)
  
  6. SOLVER
     - Successive substitution with topological ordering
     - Automatic flash calculation on material streams
     - Stream type validation
     - Convergence checking
  
  7. UI ARCHITECTURE
     - Modal dialogs for Components, Models, Units
     - Grouped property display with unit conversions
     - Collapsible sections for organization
     - Real-time parameter updates with unit conversion
  
  8. DATA PERSISTENCE
     - JSON import/export
     - Active model settings saved with scene
     - Unit system preferences included
  
  INTERNAL UNITS (SI):
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - Temperature: K
  - Pressure: Pa
  - Molar flow: mol/s
  - Mass flow: kg/s
  - Volume flow: mÂ³/s
  
  All conversions handled transparently via unit system models.
  
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Process Grid â€” v4.9.1</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
      background: #0f1115; 
      color: #e7e7e7; 
      overflow: hidden; 
    }

    /* ===== LAYOUT ===== */
    .app { 
      height: 100vh; 
      display: grid; 
      grid-template-columns: 1fr 360px; 
    }
    
    .canvasWrap { 
      position: relative; 
    }
    
    #svg { 
      width: 100%; 
      height: 100%; 
      display: block;
      background: radial-gradient(1200px 700px at 40% 30%, #141a26 0%, #0f1115 55%, #0b0d12 100%);
      touch-action: none;
    }
    
    .rightPanel {
      border-left: 1px solid #2a2f3a;
      background: #0b0e14cc;
      backdrop-filter: blur(10px);
      overflow: auto;
      padding: 14px;
      display: flex;
      flex-direction: column;
    }
    
    .rightPanel h2 { 
      margin: 0 0 10px; 
      font-size: 14px; 
      letter-spacing: 0.3px; 
    }
    
    .card { 
      border: 1px solid #2a2f3a; 
      border-radius: 14px; 
      padding: 12px; 
      background: #0b0e14aa; 
    }
    
    .card + .card { 
      margin-top: 10px; 
    }

    /* ===== TOP BAR ===== */
    .topbar {
      position: absolute; 
      left: 10px; 
      top: 10px; 
      z-index: 5;
      display: flex; 
      gap: 10px; 
      align-items: center;
      background: #0b0e14cc; 
      border: 1px solid #2a2f3a; 
      border-radius: 14px; 
      padding: 8px 10px;
      backdrop-filter: blur(10px);
    }
    
    .btn {
      display: inline-flex; 
      align-items: center; 
      gap: 8px;
      background: #1c222e; 
      color: #e7e7e7; 
      border: 1px solid #2a2f3a;
      border-radius: 12px; 
      padding: 9px 12px; 
      cursor: pointer; 
      font-weight: 700;
      user-select: none;
    }
    
    .btn:hover { 
      border-color: #475068; 
    }
    
    .btn.primary { 
      background: #2563eb; 
      border-color: #2563eb; 
    }
    
    .btn.primary:hover { 
      filter: brightness(1.05); 
    }
    
    /* ===== PROCESS NAME INPUT ===== */
    #processNameInput {
      width: 160px;
      background: #0b0e14;
      color: #e7e7e7;
      border: 1px solid #2a2f3a;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s;
    }
    #processNameInput:focus {
      border-color: #2563eb;
    }
    #processNameInput::placeholder {
      color: #475569;
      font-weight: 400;
    }

    /* ===== STATUS INDICATOR ===== */
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      border: 2px solid;
      transition: all 0.3s ease;
    }
    
    .status-indicator.idle {
      background: #1e293b22;
      border-color: #475569;
      color: #94a3b8;
    }
    
    .status-indicator.running {
      background: #3b82f622;
      border-color: #3b82f6;
      color: #60a5fa;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .status-indicator.success {
      background: #22c55e22;
      border-color: #22c55e;
      color: #4ade80;
    }
    
    .status-indicator.warning {
      background: #fbbf2422;
      border-color: #fbbf24;
      color: #fbbf24;
    }
    
    .status-indicator.error {
      background: #f9731622;
      border-color: #f97316;
      color: #f97316;
    }
    
    .status-indicator.critical {
      background: #ef444422;
      border-color: #ef4444;
      color: #ef4444;
      animation: shake 0.5s ease-in-out;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    
    .status-icon {
      font-size: 16px;
      line-height: 1;
    }
    
    .status-text {
      white-space: nowrap;
    }
    
    .status-help {
      background: transparent;
      border: 1px solid currentColor;
      color: inherit;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      margin-left: 4px;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .status-help:hover {
      opacity: 1;
      background: currentColor;
      color: #0b0e14;
    }
    
    .pill { 
      padding: 2px 8px; 
      border-radius: 999px; 
      border: 1px solid #2a2f3a; 
      opacity: .9; 
      font-size: 12px; 
    }

    /* ===== MENUS ===== */
    .menuWrap { 
      position: relative; 
    }
    
    .menu {
      position: absolute; 
      top: 46px; 
      left: 0;
      min-width: 230px;
      background: #0b0e14f2;
      border: 1px solid #2a2f3a; 
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      padding: 8px;
      display: none;
      z-index: 10;
    }
    
    .menu.open { 
      display: block; 
    }
    
    .menu .item {
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    
    .menu .item:hover { 
      background: #1b2230; 
    }
    
    .menu .item .hint { 
      opacity: 0.75; 
      font-size: 12px; 
    }
    
    .menu .sep { 
      height: 1px; 
      background: #2a2f3a; 
      margin: 6px 4px; 
    }

    /* ===== MODELS DRAWER ===== */
    /* ===== MODALS ===== */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    
    .modal.open {
      display: flex;
    }
    
    .modalContent {
      background: #0b0e14;
      border: 1px solid #2a2f3a;
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      position: relative;
    }
    
    .modalContent h3 {
      margin: 0 0 8px 0;
      font-size: 18px;
      font-weight: 700;
    }
    
    .modalClose {
      position: absolute;
      top: 20px;
      right: 20px;
      background: transparent;
      border: none;
      color: #e7e7e7;
      font-size: 24px;
      cursor: pointer;
      opacity: 0.6;
      padding: 4px 8px;
      line-height: 1;
    }
    
    .modalClose:hover {
      opacity: 1;
    }

    /* ===== FORM CONTROLS ===== */
    .row { 
      display: grid; 
      grid-template-columns: 1fr 140px; 
      gap: 10px; 
      align-items: center; 
      margin: 10px 0; 
    }
    
    .row label { 
      font-size: 12px; 
      opacity: .9; 
    }
    
    /* Package selector cards */
    .pkg-card {
      border: 1px solid #2a2f3a;
      border-radius: 10px;
      padding: 10px 14px;
      margin: 6px 0;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
      display: grid;
      grid-template-columns: 24px 1fr;
      gap: 10px;
      align-items: start;
    }
    .pkg-card:hover { border-color: #4a90d9; background: #0d1520; }
    .pkg-card.active { border-color: #4a90d9; background: #0d1520; }
    .pkg-card .radio {
      width: 16px; height: 16px; border-radius: 50%;
      border: 2px solid #4a5568; margin-top: 2px;
      display: flex; align-items: center; justify-content: center;
    }
    .pkg-card.active .radio { border-color: #4a90d9; }
    .pkg-card.active .radio::after {
      content: ''; width: 8px; height: 8px;
      border-radius: 50%; background: #4a90d9;
    }
    .pkg-card .pkg-name { font-size: 13px; font-weight: 600; }
    .pkg-card .pkg-desc { font-size: 11px; opacity: 0.7; margin-top: 3px; line-height: 1.4; }
    .pkg-card .pkg-badge {
      display: inline-block; font-size: 9px; font-weight: 700; text-transform: uppercase;
      padding: 1px 6px; border-radius: 4px; margin-left: 6px; vertical-align: middle;
    }
    .pkg-badge.stable { background: #1a3a2a; color: #4ade80; }
    .pkg-badge.preview { background: #3a2a1a; color: #fbbf24; }
    .pkg-badge.experimental { background: #3a1a1a; color: #f87171; }
    
    .models-section { margin-top: 16px; }
    .models-section-title { 
      font-size: 11px; font-weight: 600; text-transform: uppercase; 
      letter-spacing: 0.5px; opacity: 0.5; margin-bottom: 8px; 
    }
    
    input, select, textarea {
      width: 100%; 
      background: #0b0e14; 
      color: #e7e7e7; 
      border: 1px solid #2a2f3a; 
      border-radius: 12px;
      padding: 8px 10px; 
      font-size: 12px;
    }
    
    .small { 
      font-size: 12px; 
      opacity: 0.85; 
      line-height: 1.35; 
    }
    
    .status { 
      white-space: pre-wrap; 
      font-size: 12px; 
      opacity: 0.9; 
    }

    /* ===== VISUALIZATIONS ===== */
    .bar { 
      height: 10px; 
      border: 1px solid #2a2f3a; 
      border-radius: 999px; 
      overflow: hidden; 
      background: #0b0e14; 
    }
    
    .bar > div { 
      height: 100%; 
      width: 0%; 
      background: #60a5fa; 
    }
    
    .kv { 
      display: flex; 
      justify-content: space-between; 
      font-size: 12px; 
      margin: 6px 0; 
      gap: 10px; 
    }
    
    .mono { 
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace; 
    }
    
    .swatch { 
      width: 10px; 
      height: 10px; 
      border-radius: 999px; 
      display: inline-block; 
      margin-right: 6px; 
      vertical-align: middle; 
    }

    /* ===== PROPERTIES PANEL ===== */
    .unitHeader {
      margin-bottom: 16px;
    }
    
    .unitTitle {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .unitTitle input {
      flex: 1;
      background: transparent;
      border: 1px solid transparent;
      padding: 4px 8px;
      font-size: 16px;
      font-weight: 700;
      color: #e7e7e7;
      border-radius: 6px;
    }
    
    .unitTitle input:hover {
      background: #1c222e;
      border-color: #2a2f3a;
    }
    
    .unitTitle input:focus {
      background: #1c222e;
      border-color: #60a5fa;
      outline: none;
    }
    
    .unitSubtitle {
      font-size: 12px;
      opacity: 0.6;
    }
    
    /* Bordered sections (Parameters, Properties) */
    .borderedSection {
      border: 1px solid #2a2f3a;
      border-radius: 12px;
      padding: 12px;
      background: transparent;
      margin-bottom: 10px;
    }
    
    .sectionHeader {
      font-size: 11px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
      margin-bottom: 12px;
      padding: 0;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .sectionHeader:hover {
      opacity: 1;
    }
    
    .sectionToggle {
      font-size: 10px;
      opacity: 0.5;
      transition: transform 0.2s;
    }
    
    .sectionToggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .sectionContent {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .sectionContent.collapsed {
      max-height: 0;
    }
    
    /* Subsections (Details inside Properties) */
    .subSection {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #2a2f3a;
    }
    
    .subSectionHeader {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.6;
      margin-bottom: 8px;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .subSectionHeader:hover {
      opacity: 0.8;
    }
    
    .subSectionToggle {
      font-size: 9px;
      opacity: 0.5;
      transition: transform 0.2s;
    }
    
    .subSectionToggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .subSectionContent {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .subSectionContent.collapsed {
      max-height: 0;
    }
    
    .propGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .propItem {
      background: #0f1420;
      border: 1px solid #2a2f3a;
      border-radius: 10px;
      padding: 8px 10px;
    }
    
    .propLabel {
      font-size: 10px;
      opacity: 0.7;
      margin-bottom: 2px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .propValue {
      font-size: 14px;
      font-weight: 700;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    
    .propUnit {
      font-size: 11px;
      opacity: 0.6;
      margin-left: 3px;
    }
    
    .compBadge {
      display: inline-block;
      background: #1c222e;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 11px;
      margin: 4px 4px 4px 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    
    .compBadge .spec { 
      font-weight: 700; 
    }
    
    .compBadge .pct { 
      opacity: 0.7; 
      margin-left: 4px; 
    }

    /* ===== CONTROLS SECTION ===== */
    .controlsSection {
      margin-top: auto;
      padding-top: 14px;
      border-top: 1px solid #2a2f3a;
    }
    
    .controlsGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 12px;
      font-size: 11px;
      line-height: 1.5;
    }
    
    .controlsGrid b {
      font-weight: 600;
      opacity: 0.9;
    }

    /* ===== UNIT LIBRARY IN RIGHT PANEL ===== */
    .unitLibraryGrid { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 10px; 
    }
    
    .unitLibraryCard {
      border: 1px solid #2a2f3a;
      border-radius: 12px;
      background: #0f1420;
      padding: 12px;
      cursor: grab;
      transition: all 0.2s;
      user-select: none;
    }
    
    .unitLibraryCard:active {
      cursor: grabbing;
    }
    
    .unitLibraryCard:hover {
      border-color: #475068;
      background: #1c222e;
    }
    
    .unitLibraryCard .name { 
      font-size: 12px; 
      font-weight: 800; 
      margin-bottom: 4px; 
    }
    
    .unitLibraryCard .desc { 
      font-size: 11px; 
      opacity: 0.75; 
      line-height: 1.2; 
    }
  </style>
</head>
<body>
<div class="app">
  <div class="canvasWrap">
    <!-- Top toolbar -->
    <div class="topbar">
      <button class="btn primary" id="btnRun">â–¶ Run</button>
      <button class="btn" id="btnAdd" style="background:#dc2626; border-color:#dc2626; color:#fff;">+ Add Unit</button>
      
      <input type="text" id="processNameInput" placeholder="Process nameâ€¦" spellcheck="false" autocomplete="off">
      
      <!-- Status Indicator -->
      <div id="statusIndicator" class="status-indicator" style="display:none;">
        <div class="status-icon"></div>
        <div class="status-text"></div>
        <button class="status-help" title="Diagnosis">?</button>
      </div>

      <div class="menuWrap">
        <button class="btn" id="btnMenu">â˜° Menu</button>
        <div class="menu" id="menuMain">
          <div class="item" id="mComponents">Components <span class="hint">view</span></div>
          <div class="item" id="mModels">Models <span class="hint">packages</span></div>
          <div class="item" id="mUnits">Units <span class="hint">display</span></div>
          <div class="sep"></div>
          <div class="item" id="mLoadDemo">Load demo</div>
          <div class="item" id="mClear">Clear scene</div>
          <div class="sep"></div>
          <div class="item" id="mRunTests">Run Tests <span class="hint">verify</span></div>
        </div>
      </div>

      <div class="menuWrap">
        <button class="btn" id="btnFile">ðŸ’¾ File</button>
        <div class="menu" id="menuFile">
          <div class="item" id="mExport">Save to fileâ€¦</div>
          <div class="item" id="mImport">Open fileâ€¦</div>
        </div>
      </div>
    </div>

    <!-- Models modal -->
    <div class="modal" id="modalModels">
      <div class="modalContent">
        <button class="modalClose" onclick="document.getElementById('modalModels').classList.remove('open')">Ã—</button>
        <h3>Thermodynamic Models</h3>
        <div class="small">Select the property package and auxiliary models for calculations.</div>
        <div id="modelsPanel" style="margin-top:10px;"></div>
      </div>
    </div>

    <!-- Units modal -->
    <div class="modal" id="modalUnits">
      <div class="modalContent">
        <button class="modalClose" onclick="document.getElementById('modalUnits').classList.remove('open')">Ã—</button>
        <h3>Unit System</h3>
        <div class="small">Choose display units for all properties.</div>
        <div class="card" id="unitsPanel" style="margin-top:10px;"></div>
      </div>
    </div>

    <!-- Components modal -->
    <div class="modal" id="modalComponents">
      <div class="modalContent">
        <button class="modalClose" onclick="document.getElementById('modalComponents').classList.remove('open')">Ã—</button>
        <h3>Components</h3>
        <div class="small">Available chemical components in the simulation.</div>
        <div class="card" id="componentsPanel" style="margin-top:10px; max-height:60vh; overflow-y:auto;"></div>
      </div>
    </div>

    <!-- Main SVG canvas -->
    <svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-label="process grid">
      <defs>
        <!-- Material Source -->
        <symbol id="ico-source" viewBox="0 0 64 64">
          <circle cx="20" cy="32" r="10" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M32 32h22" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M46 24l8 8-8 8" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Sink -->
        <symbol id="ico-sink" viewBox="0 0 64 64">
          <path d="M12 18h40" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M18 18v26c0 8 6 14 14 14s14-6 14-14V18" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M26 30h12" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
        </symbol>
        
        <!-- Electrical Source (Lightning/Grid) -->
        <symbol id="ico-electrical" viewBox="0 0 64 64">
          <path d="M36 6 16 36h16l-4 22 20-30H32z" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Mechanical Source (Gear/Shaft) -->
        <symbol id="ico-mechanical" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="14" fill="none" stroke="currentColor" stroke-width="4"/>
          <circle cx="32" cy="32" r="6" fill="currentColor"/>
          <path d="M32 10v8M32 46v8M10 32h8M46 32h8M18 18l6 6M40 40l6 6M18 46l6-6M40 24l6-6" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
        </symbol>
        
        <!-- Motor (Circle with M) -->
        <symbol id="ico-motor" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="22" fill="none" stroke="currentColor" stroke-width="4"/>
          <text x="32" y="42" text-anchor="middle" font-size="32" font-weight="bold" fill="currentColor">M</text>
        </symbol>
        
        <!-- Pump (Triangle with impeller) -->
        <symbol id="ico-pump" viewBox="0 0 64 64">
          <path d="M10 16 L54 32 L10 48 Z" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
          <path d="M20 32 A8 8 0 0 1 28 24" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M20 32 A8 8 0 0 0 28 40" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M35 32 A6 6 0 0 1 41 26" fill="none" stroke="currentColor" stroke-width="2.5"/>
          <path d="M35 32 A6 6 0 0 0 41 38" fill="none" stroke="currentColor" stroke-width="2.5"/>
        </symbol>
        
        <!-- Compressor (Circle with turbine blades) -->
        <symbol id="ico-compressor" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="22" fill="none" stroke="currentColor" stroke-width="4"/>
          <!-- Turbine blades -->
          <path d="M32 10 L32 22 M32 54 L32 42 M10 32 L22 32 M54 32 L42 32" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M16 16 L24 24 M48 48 L40 40 M16 48 L24 40 M48 16 L40 24" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <circle cx="32" cy="32" r="8" fill="currentColor"/>
        </symbol>
        
        <!-- Valve (Bowtie) -->
        <symbol id="ico-valve" viewBox="0 0 64 64">
          <path d="M8 32 L32 12 L32 52 L8 32 Z" fill="currentColor" opacity="0.8"/>
          <path d="M56 32 L32 12 L32 52 L56 32 Z" fill="currentColor" opacity="0.8"/>
          <path d="M8 32 L32 12 L32 52 L8 32 Z M56 32 L32 12 L32 52 L56 32 Z" fill="none" stroke="currentColor" stroke-width="3" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Heat Exchanger -->
        <symbol id="ico-hx" viewBox="0 0 64 64">
          <path d="M10 20h44" stroke="currentColor" stroke-width="4"/>
          <path d="M10 44h44" stroke="currentColor" stroke-width="4"/>
          <path d="M16 20c8 8 8 16 0 24" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M48 20c-8 8-8 16 0 24" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M32 6v12" stroke="currentColor" stroke-width="4"/>
          <path d="M26 14h12" stroke="currentColor" stroke-width="4"/>
        </symbol>
        
        <!-- Single Stream Heater -->
        <symbol id="ico-heater" viewBox="0 0 64 64">
          <rect x="14" y="20" width="36" height="24" fill="none" stroke="currentColor" stroke-width="4" rx="4"/>
          <path d="M20 32 Q26 26, 32 32 T44 32" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M32 6 L32 20" stroke="currentColor" stroke-width="4"/>
          <path d="M26 10 L32 6 L38 10" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Electric Heater (circle with H, like motor with M) -->
        <symbol id="ico-electric_heater" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="22" fill="none" stroke="currentColor" stroke-width="4"/>
          <text x="32" y="42" text-anchor="middle" font-size="32" font-weight="bold" fill="currentColor">H</text>
        </symbol>
        
        <!-- Two-Stream Heat Exchanger -->
        <symbol id="ico-hex" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="20" fill="none" stroke="currentColor" stroke-width="4"/>
          <!-- Hot stream (vertical) -->
          <path d="M20 8 L20 24" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M20 40 L20 56" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Cold stream (vertical) -->
          <path d="M44 56 L44 40" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M44 24 L44 8" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Arrows -->
          <path d="M16 20 L20 24 L24 20" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M40 12 L44 8 L48 12" fill="none" stroke="currentColor" stroke-width="3"/>
        </symbol>
        
        <!-- Mixer (two-to-one merge) -->
        <symbol id="ico-mixer" viewBox="0 0 64 64">
          <!-- Two inlets converging to one outlet -->
          <path d="M8 16 L32 32 L8 48" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
          <path d="M32 32 L56 32" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Arrow on outlet -->
          <path d="M48 26 L56 32 L48 38" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
        </symbol>
        
        <!-- Splitter (one-to-two diverge) -->
        <symbol id="ico-flash_drum" viewBox="0 0 64 96">
          <!-- Vertical drum vessel -->
          <rect x="16" y="8" width="32" height="80" rx="16" ry="16" fill="none" stroke="currentColor" stroke-width="3"/>
          <!-- Liquid level line -->
          <line x1="18" y1="56" x2="46" y2="56" stroke="currentColor" stroke-width="2" stroke-dasharray="4 3" opacity="0.6"/>
          <!-- V label (top half) -->
          <text x="32" y="38" text-anchor="middle" font-size="16" font-weight="700" fill="currentColor" opacity="0.7">V</text>
          <!-- L label (bottom half) -->
          <text x="32" y="74" text-anchor="middle" font-size="16" font-weight="700" fill="currentColor" opacity="0.7">L</text>
        </symbol>
        
        <symbol id="ico-splitter" viewBox="0 0 64 64">
          <!-- Single inlet to two outlets -->
          <path d="M8 32 L32 32" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M32 32 L56 16" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M32 32 L56 48" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Arrows on outlets -->
          <path d="M48 10 L56 16 L48 22" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
          <path d="M48 42 L56 48 L48 54" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
        </symbol>
        
        <!-- Generic pipe/flow (fallback) -->
        <symbol id="ico-pipe" viewBox="0 0 64 64">
          <path d="M10 32h44" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <path d="M42 24l12 8-12 8" fill="none" stroke="currentColor" stroke-width="6" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Battery (electrical energy storage) -->
        <symbol id="ico-battery" viewBox="0 0 64 64">
          <rect x="10" y="18" width="36" height="28" rx="3" fill="none" stroke="currentColor" stroke-width="3"/>
          <rect x="46" y="26" width="6" height="12" rx="1" fill="currentColor"/>
          <rect x="16" y="24" width="8" height="16" fill="currentColor" opacity="0.8"/>
          <rect x="27" y="24" width="8" height="16" fill="currentColor" opacity="0.5"/>
        </symbol>
        
        <!-- Power Hub (electrical bus/distribution) -->
        <symbol id="ico-power_hub" viewBox="0 0 64 96">
          <rect x="12" y="20" width="40" height="56" rx="6" fill="none" stroke="currentColor" stroke-width="3"/>
          <!-- Lightning bolt -->
          <path d="M36 34 L28 50 L35 50 L29 66" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          <!-- Bus bars -->
          <line x1="18" y1="38" x2="46" y2="38" stroke="currentColor" stroke-width="2" opacity="0.5"/>
          <line x1="18" y1="58" x2="46" y2="58" stroke="currentColor" stroke-width="2" opacity="0.5"/>
        </symbol>
        
        <!-- Electrical Sink (load/ground) -->
        <symbol id="ico-sink_electrical" viewBox="0 0 64 64">
          <circle cx="32" cy="28" r="14" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M25 28 L39 28" stroke="currentColor" stroke-width="3"/>
          <path d="M32 21 L32 35" stroke="currentColor" stroke-width="3"/>
          <!-- Ground symbol -->
          <line x1="22" y1="48" x2="42" y2="48" stroke="currentColor" stroke-width="3"/>
          <line x1="26" y1="52" x2="38" y2="52" stroke="currentColor" stroke-width="2.5"/>
          <line x1="30" y1="56" x2="34" y2="56" stroke="currentColor" stroke-width="2"/>
        </symbol>
        
        <!-- Fixed Power Source (generator/grid) -->
        <symbol id="ico-source_electrical" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="18" fill="none" stroke="currentColor" stroke-width="3"/>
          <!-- ~ AC symbol -->
          <path d="M22 32 Q27 22 32 32 Q37 42 42 32" fill="none" stroke="currentColor" stroke-width="2.5"/>
        </symbol>
        
        <!-- Heat Sink (radiator/dissipation) -->
        <symbol id="ico-sink_heat" viewBox="0 0 64 64">
          <!-- Wavy heat lines -->
          <path d="M20 16 Q24 22 20 28 Q16 34 20 40" fill="none" stroke="currentColor" stroke-width="2.5"/>
          <path d="M32 16 Q36 22 32 28 Q28 34 32 40" fill="none" stroke="currentColor" stroke-width="2.5"/>
          <path d="M44 16 Q48 22 44 28 Q40 34 44 40" fill="none" stroke="currentColor" stroke-width="2.5"/>
          <!-- Base plate -->
          <rect x="14" y="44" width="36" height="6" rx="2" fill="currentColor" opacity="0.6"/>
        </symbol>
        
        <!-- Gas Turbine (expander) -->
        <symbol id="ico-gas_turbine" viewBox="0 0 64 64">
          <!-- Expanding trapezoid shape (narrow inlet, wide outlet) -->
          <path d="M16 18 L48 10 L48 54 L16 46 Z" fill="none" stroke="currentColor" stroke-width="3" stroke-linejoin="round"/>
          <!-- Shaft line -->
          <line x1="32" y1="46" x2="32" y2="58" stroke="currentColor" stroke-width="3"/>
          <!-- Blade hints -->
          <line x1="24" y1="24" x2="40" y2="22" stroke="currentColor" stroke-width="1.5" opacity="0.5"/>
          <line x1="24" y1="32" x2="40" y2="32" stroke="currentColor" stroke-width="1.5" opacity="0.5"/>
          <line x1="24" y1="40" x2="40" y2="42" stroke="currentColor" stroke-width="1.5" opacity="0.5"/>
        </symbol>
        
        <!-- Electrical Generator -->
        <symbol id="ico-generator" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="18" fill="none" stroke="currentColor" stroke-width="3"/>
          <!-- G letter -->
          <text x="32" y="38" text-anchor="middle" font-size="22" font-weight="700" fill="currentColor">G</text>
        </symbol>
      </defs>
    </svg>
  </div>

  <!-- Right panel for properties and unit library -->
  <aside class="rightPanel">
    <div class="card" id="propEditor"></div>

    <!-- Controls section at bottom -->
    <div class="controlsSection">
      <div class="controlsGrid">
        <div><b>Pan:</b> Middle mouse / Shift + drag</div>
        <div><b>Zoom:</b> Mouse wheel</div>
        <div><b>Rotate:</b> R key</div>
        <div><b>Delete:</b> Del key</div>
      </div>
    </div>
  </aside>

  <!-- Hidden textarea for import/export operations -->
  <textarea id="io" style="display:none;"></textarea>
  <!-- Hidden file input for JSON import -->
  <input type="file" id="fileImportInput" accept=".json,.JSON" style="display:none;">
</div>

<script>
"use strict";

/* =========================
   CONSTANTS & ENUMS
   ========================= */
const PortDir = { IN: 0, OUT: 1 };
const StreamType = { 
  MATERIAL: 0,  // Grey
  HEAT: 1,      // Yellow/orange
  MECHANICAL: 2, // Purple
  ELECTRICAL: 3  // Green
};

// Stream visual properties
const StreamVisuals = {
  [StreamType.MATERIAL]: { 
    color: '#94a3b8', 
    portColor: '#94a3b8' 
  },
  [StreamType.HEAT]: { 
    color: '#fbbf24', 
    portColor: '#fbbf24' 
  },
  [StreamType.MECHANICAL]: { 
    color: '#a855f7', 
    portColor: '#a855f7' 
  },
  [StreamType.ELECTRICAL]: { 
    color: '#22c55e', 
    portColor: '#22c55e' 
  }
};

/* =========================
   COMPONENT REGISTRY
   Chemical components with physical properties
   ========================= */
class ComponentRegistry {
  static _components = new Map();

  static register(formula, spec) {
    const comp = {
      // Identification
      formula,                    // Chemical formula (e.g., 'H2O')
      name: spec.name,           // Common name (e.g., 'Water')
      CAS: spec.CAS || null,     // CAS registry number
      
      // Basic properties
      MW: spec.MW,               // Molecular weight (g/mol)
      
      // Critical properties (for Peng-Robinson EOS)
      Tc: spec.Tc,               // Critical temperature (K)
      Pc: spec.Pc,               // Critical pressure (Pa)
      omega: spec.omega || 0,    // Acentric factor (dimensionless)
      Vc: spec.Vc || null,       // Critical volume (mÂ³/mol) - optional
      Zc: spec.Zc || null,       // Critical compressibility factor - optional
      
      // Phase transition properties
      Tb: spec.Tb,               // Normal boiling point at 1 atm (K)
      Tm: spec.Tm || null,       // Melting point at 1 atm (K) - optional
      Hv: spec.Hv || null,       // Heat of vaporization at Tb (J/mol) - optional
      Hf: spec.Hf || null,       // Heat of fusion at Tm (J/mol) - optional
      
      // Vapor pressure correlation (Antoine equation)
      // log10(Psat[mmHg]) = A - B/(C + T[Â°C])
      // Will be converted to Pa in calculations
      antoine: spec.antoine || null,  // {A, B, C, Tmin, Tmax}
      
      // Ideal gas heat capacity correlation (polynomial)
      // Cp_ig = A + B*T + C*TÂ² + D*TÂ³ + E*Tâ´  [J/(molÂ·K)]
      // T in Kelvin
      cpig: spec.cpig || null,   // {A, B, C, D, E, Tmin, Tmax}
      
      // Liquid heat capacity (constant or temperature-dependent)
      cpLiq: spec.cpLiq || null,  // J/(molÂ·K) or {A, B, C} for Cp = A + B*T + C*TÂ²
      
      // Liquid density correlation (Rackett or polynomial)
      densityLiq: spec.densityLiq || null,  // {method, params}
      
      // Liquid density constant (kg/mÂ³ at reference conditions)
      // Simple constant approximation; used by ThermoAdapter.density()
      rhoLiq: spec.rhoLiq || null,
      
      // Safety and environmental
      flashPoint: spec.flashPoint || null,    // K
      autoIgnition: spec.autoIgnition || null, // K
      LEL: spec.LEL || null,                   // Lower explosive limit (vol%)
      UEL: spec.UEL || null,                   // Upper explosive limit (vol%)
      
      // Additional metadata
      phase298: spec.phase298 || 'unknown',    // Phase at 298K, 1 atm ('gas', 'liquid', 'solid')
      molecular: spec.molecular || null        // Molecular structure info (optional)
    };
    this._components.set(formula, comp);
  }

  static get(formula) {
    return this._components.get(formula);
  }

  static list() {
    return Array.from(this._components.values());
  }

  static exists(formula) {
    return this._components.has(formula);
  }
  
  static getPropertyNames() {
    // Return list of all possible property names for display
    return [
      { key: 'formula', name: 'Formula', unit: '' },
      { key: 'name', name: 'Name', unit: '' },
      { key: 'CAS', name: 'CAS Number', unit: '' },
      { key: 'MW', name: 'Molecular Weight', unit: 'g/mol' },
      { key: 'Tc', name: 'Critical Temperature', unit: 'K' },
      { key: 'Pc', name: 'Critical Pressure', unit: 'Pa' },
      { key: 'omega', name: 'Acentric Factor', unit: '-' },
      { key: 'Tb', name: 'Normal Boiling Point', unit: 'K' },
      { key: 'phase298', name: 'Phase at 298K', unit: '' },
      { key: 'antoine', name: 'Antoine Coefficients', unit: '{A, B, C}' },
      { key: 'cpig', name: 'Ideal Gas Cp', unit: 'J/(molÂ·K)' },
      { key: 'cpLiq', name: 'Liquid Cp', unit: 'J/(molÂ·K)' }
    ];
  }
  
  static validate(formula) {
    // Validate that component has all required properties for energy balance
    const comp = this.get(formula);
    if (!comp) return { valid: false, errors: ['Component not found'] };
    
    const errors = [];
    const warnings = [];
    
    // Required for ALL components
    if (!comp.MW) errors.push('Missing molecular weight (MW)');
    if (!comp.Tc) errors.push('Missing critical temperature (Tc)');
    if (!comp.Pc) errors.push('Missing critical pressure (Pc)');
    if (comp.omega === undefined) errors.push('Missing acentric factor (omega)');
    if (!comp.Tb) errors.push('Missing boiling point (Tb)');
    if (!comp.phase298) errors.push('Missing phase at 298K');
    
    // Required for vapor pressure calculations
    if (!comp.antoine) {
      errors.push('Missing Antoine coefficients');
    } else {
      // Support both single-range and multi-range Antoine
      if (Array.isArray(comp.antoine)) {
        // Multi-range: validate each range
        if (comp.antoine.length === 0) {
          errors.push('Antoine: Empty array (need at least one range)');
        } else {
          comp.antoine.forEach((range, idx) => {
            const prefix = `Antoine[${idx}]`;
            if (!range.A && range.A !== 0) errors.push(`${prefix}: Missing coefficient A`);
            if (!range.B && range.B !== 0) errors.push(`${prefix}: Missing coefficient B`);
            if (!range.C && range.C !== 0) errors.push(`${prefix}: Missing coefficient C`);
            if (!range.Tmin) errors.push(`${prefix}: Missing Tmin (required for multi-range)`);
            if (!range.Tmax) errors.push(`${prefix}: Missing Tmax (required for multi-range)`);
            
            // Validate range ordering
            if (range.Tmin && range.Tmax && range.Tmin >= range.Tmax) {
              errors.push(`${prefix}: Tmin (${range.Tmin}K) must be less than Tmax (${range.Tmax}K)`);
            }
          });
          
          // Check for overlaps and ordering (warnings, not errors)
          for (let i = 0; i < comp.antoine.length - 1; i++) {
            const curr = comp.antoine[i];
            const next = comp.antoine[i + 1];
            
            if (curr.Tmax && next.Tmin && curr.Tmax < next.Tmin) {
              // Gap between ranges - this is OK but worth noting
              warnings.push(`Antoine: Gap between range ${i} (${curr.Tmax}K) and range ${i+1} (${next.Tmin}K)`);
            } else if (curr.Tmax && next.Tmin && curr.Tmax > next.Tmin) {
              // Overlap - warn but allow (some overlap is intentional for smooth transition)
              const overlap = curr.Tmax - next.Tmin;
              if (overlap > 10) {  // Only warn if overlap > 10K
                warnings.push(`Antoine: Large overlap (${overlap.toFixed(0)}K) between range ${i} and ${i+1}`);
              }
            }
          }
        }
      } else {
        // Single-range: validate object
        if (!comp.antoine.A && comp.antoine.A !== 0) errors.push('Antoine: Missing coefficient A');
        if (!comp.antoine.B && comp.antoine.B !== 0) errors.push('Antoine: Missing coefficient B');
        if (!comp.antoine.C && comp.antoine.C !== 0) errors.push('Antoine: Missing coefficient C');
        if (!comp.antoine.Tmin) warnings.push('Antoine: Missing Tmin (range not validated)');
        if (!comp.antoine.Tmax) warnings.push('Antoine: Missing Tmax (range not validated)');
      }
    }
    
    // Required for energy balance (heat capacity)
    if (!comp.cpig) {
      errors.push('Missing ideal gas heat capacity correlation (cpig)');
    } else {
      if (comp.cpig.A === undefined) errors.push('cpig: Missing coefficient A');
      if (comp.cpig.B === undefined) errors.push('cpig: Missing coefficient B');
      if (comp.cpig.C === undefined) errors.push('cpig: Missing coefficient C');
      if (comp.cpig.D === undefined) errors.push('cpig: Missing coefficient D');
      if (!comp.cpig.Tmin) warnings.push('cpig: Missing Tmin (range not validated)');
      if (!comp.cpig.Tmax) warnings.push('cpig: Missing Tmax (range not validated)');
    }
    
    // Required for liquid phase energy balance
    if (!comp.cpLiq) {
      errors.push('Missing liquid heat capacity (cpLiq) - required for liquid phase calculations');
    }
    
    // Recommended for Peng-Robinson EOS
    if (!comp.Vc) warnings.push('Missing critical volume (Vc) - recommended for PR EOS');
    if (!comp.Zc) warnings.push('Missing critical compressibility (Zc)');
    
    // Recommended for phase change calculations
    if (!comp.Tm) warnings.push('Missing melting point (Tm)');
    if (!comp.Hv) warnings.push('Missing heat of vaporization (Hv)');
    
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }
  
  static validateAll() {
    // Validate all registered components
    const results = {};
    for (const comp of this.list()) {
      results[comp.formula] = this.validate(comp.formula);
    }
    return results;
  }
}

// Register initial components with COMPLETE, STANDARDIZED property sets
// All components must have: MW, Tc, Pc, omega, Tb, phase298, antoine, cpig, cpLiq
// Ideal gas Cp correlation: Cp_ig = A + B*T + C*TÂ² + D*TÂ³ + E*Tâ´  [J/(molÂ·K)]
// Liquid Cp: Approximately constant (liquids have much lower temperature dependence than gases)
// Valid for temperatures in [Tmin, Tmax]

ComponentRegistry.register('H2O', {
  name: 'Water',
  CAS: '7732-18-5',
  MW: 18.015,
  Tc: 647.1,
  Pc: 22064000,
  omega: 0.344,
  Vc: 0.0000559,
  Zc: 0.229,
  Tb: 373.15,
  Tm: 273.15,
  Hv: 40660,
  phase298: 'liquid',
  // Multiple Antoine ranges for extended temperature coverage
  antoine: [
    { A: 8.07131, B: 1730.63, C: 233.426, Tmin: 274, Tmax: 373, desc: 'Low temp range (1-100Â°C)' },
    { A: 8.14019, B: 1810.94, C: 244.485, Tmin: 372, Tmax: 647, desc: 'High temp range (99-374Â°C)' }
  ],
  // NIST WebBook correlation
  cpig: { A: 33.933, B: -0.008418, C: 2.9906e-5, D: -1.7825e-8, E: 3.6934e-12, Tmin: 273, Tmax: 1500 },
  cpLiq: 75.3,  // J/(molÂ·K) at 298K - approximately constant for liquid water
  rhoLiq: 1000  // kg/mÂ³ at 298K (liquid density at reference conditions)
});

ComponentRegistry.register('O2', {
  name: 'Oxygen',
  CAS: '7782-44-7',
  MW: 31.999,
  Tc: 154.6,
  Pc: 5043000,
  omega: 0.022,
  Vc: 0.0000734,
  Zc: 0.288,
  Tb: 90.2,
  Tm: 54.4,
  Hv: 6820,
  phase298: 'gas',
  antoine: { A: 6.69147, B: 319.013, C: 266.7, Tmin: 60, Tmax: 154 },
  // NIST WebBook - Shomate equation converted to polynomial
  cpig: { A: 29.659, B: -0.0085178, C: 2.3968e-5, D: -2.0269e-8, E: 6.6185e-12, Tmin: 100, Tmax: 2000 },
  cpLiq: 52.8,  // J/(molÂ·K) for liquid O2 near Tb (NIST)
  rhoLiq: 1141  // kg/mÂ³ (liquid O2 at NBP)
});

ComponentRegistry.register('H2', {
  name: 'Hydrogen',
  CAS: '1333-74-0',
  MW: 2.016,
  Tc: 33.2,
  Pc: 1297000,
  omega: -0.216,
  Vc: 0.0000641,
  Zc: 0.303,
  Tb: 20.4,
  Tm: 13.8,
  Hv: 904,
  phase298: 'gas',
  antoine: { A: 5.00395, B: 56.0, C: 258.0, Tmin: 14, Tmax: 33 },
  // NIST WebBook
  cpig: { A: 29.088, B: -0.0019226, C: 4.0002e-6, D: -8.7047e-10, E: 1.0227e-13, Tmin: 298, Tmax: 1000 },
  cpLiq: 28.8,  // J/(molÂ·K) for liquid H2 (20K, NIST)
  rhoLiq: 71    // kg/mÂ³ (liquid H2 at NBP)
});

ComponentRegistry.register('N2', {
  name: 'Nitrogen',
  CAS: '7727-37-9',
  MW: 28.014,
  Tc: 126.2,
  Pc: 3396000,
  omega: 0.037,
  Vc: 0.0000901,
  Zc: 0.289,
  Tb: 77.4,
  Tm: 63.1,
  Hv: 5577,
  phase298: 'gas',
  antoine: { A: 6.49457, B: 255.68, C: 266.55, Tmin: 63, Tmax: 126 },
  // NIST WebBook
  cpig: { A: 29.124, B: -0.0033536, C: 1.0735e-5, D: -9.5806e-9, E: 2.8861e-12, Tmin: 100, Tmax: 2000 },
  cpLiq: 54.4,  // J/(molÂ·K) for liquid N2 at 77K (NIST)
  rhoLiq: 807   // kg/mÂ³ (liquid N2 at NBP)
});

ComponentRegistry.register('Ar', {
  name: 'Argon',
  CAS: '7440-37-1',
  MW: 39.948,
  Tc: 150.9,
  Pc: 4898000,
  omega: -0.002,
  Vc: 0.0000749,
  Zc: 0.291,
  Tb: 87.3,
  Tm: 83.8,
  Hv: 6447,
  phase298: 'gas',
  antoine: { A: 6.61562, B: 304.226, C: 267.31, Tmin: 84, Tmax: 151 },
  // Monoatomic gas: Cp = 5/2 R (constant)
  cpig: { A: 20.786, B: 0, C: 0, D: 0, E: 0, Tmin: 100, Tmax: 5000 },
  cpLiq: 42.1,  // J/(molÂ·K) for liquid Ar at 87K (NIST)
  rhoLiq: 1394  // kg/mÂ³ (liquid Ar at NBP)
});

ComponentRegistry.register('CH4', {
  name: 'Methane',
  CAS: '74-82-8',
  MW: 16.043,
  Tc: 190.6,
  Pc: 4599000,
  omega: 0.011,
  Vc: 0.0000986,
  Zc: 0.286,
  Tb: 111.7,
  Tm: 90.7,
  Hv: 8180,
  phase298: 'gas',
  antoine: { A: 6.61184, B: 389.93, C: 266.0, Tmin: 91, Tmax: 191 },
  // NIST WebBook
  cpig: { A: 34.942, B: -0.039957, C: 1.9184e-4, D: -1.5303e-7, E: 3.9321e-11, Tmin: 298, Tmax: 1500 },
  cpLiq: 52.6,  // J/(molÂ·K) for liquid CH4 at 111K (NIST)
  rhoLiq: 423   // kg/mÂ³ (liquid CH4 at NBP)
});

ComponentRegistry.register('He', {
  name: 'Helium',
  CAS: '7440-59-7',
  MW: 4.003,
  Tc: 5.19,
  Pc: 227000,
  omega: -0.390,
  Vc: 0.0000574,
  Zc: 0.301,
  Tb: 4.22,
  Tm: 0.95,  // At 2.5 MPa (no solid at 1 atm)
  Hv: 84,    // Very low heat of vaporization
  phase298: 'gas',
  // Antoine coefficients for helium (low temperature range)
  antoine: { A: 3.75830, B: 2.29551, C: 0.50, Tmin: 2, Tmax: 5 },
  // NIST: Monatomic gas, constant Cp
  cpig: { A: 20.786, B: 0.0, C: 0.0, D: 0.0, E: 0.0, Tmin: 100, Tmax: 2000 },
  cpLiq: 4.5,  // J/(molÂ·K) for liquid helium (very low)
  rhoLiq: 125  // kg/mÂ³ (liquid He at NBP)
});

ComponentRegistry.register('CO2', {
  name: 'Carbon Dioxide',
  CAS: '124-38-9',
  MW: 44.010,
  Tc: 304.1,
  Pc: 7377000,
  omega: 0.228,
  Vc: 0.0000940,
  Zc: 0.274,
  Tb: 194.7,  // Sublimation point at 1 atm
  Tm: 216.6,
  Hv: 15326,  // Sublimation enthalpy
  phase298: 'gas',
  // Antoine for solid-vapor equilibrium (sublimation)
  antoine: { A: 9.8106, B: 1347.8, C: 273.0, Tmin: 154, Tmax: 196 },
  // NIST WebBook
  cpig: { A: 29.370, B: 0.034540, C: -2.0662e-5, D: 3.9969e-9, E: 2.9882e-14, Tmin: 298, Tmax: 1500 },
  cpLiq: 85.5,  // J/(molÂ·K) for liquid CO2 at 250K (NIST) - liquid exists above 5.2 bar
  rhoLiq: 1101  // kg/mÂ³ (liquid CO2 at ~250K, 10 bar)
});

/* =========================
   UTILITY FUNCTIONS
   ========================= */
function clamp(v, min, max) { 
  return Math.max(min, Math.min(max, v)); 
}

function compToString(comp) {
  if (!comp) return '';
  const arr = Object.entries(comp)
    .filter(([, f]) => f > 1e-6)
    .map(([s, f]) => `${s}:${(f * 100).toFixed(1)}%`);
  return arr.join(' ');
}

function formatStream(s) {
  if (!s) return 'â€”';
  if (s.type === StreamType.ELECTRICAL) 
    return `âš¡ ${((s.actual ?? s.available ?? 0)/1000).toFixed(1)} kW`;
  if (s.type === StreamType.HEAT) 
    return `ðŸ”¥ ${((s.actual ?? s.available ?? 0)/1000).toFixed(1)} kW`;
  if (s.type === StreamType.MECHANICAL) 
    return `âš™ ${((s.actual ?? s.available ?? 0)/1000).toFixed(1)} kW`;
  if (s.type === StreamType.MATERIAL) {
    // Internal phase encoding: 'V', 'L', 'VL'
    const phaseDisplay = s.phase === 'V' ? 'Vapor' : 
                         s.phase === 'L' ? 'Liquid' : 
                         s.phase === 'VL' ? 'Two-Phase' : 'Unknown';
    const T_display = s.T ? (s.T - 273.15).toFixed(1) : '?';
    const P_display = s.P ? (s.P / 100000).toFixed(2) : '?';
    return `${phaseDisplay} T=${T_display}Â°C P=${P_display} bar`;
  }
  return JSON.stringify(s);
}

// Validation: Ensure stream type matches port type
function validateStreamType(stream, portType) {
  if (!stream) return false;
  if (stream.type !== portType) {
    console.error(`Stream type mismatch: stream.type=${stream.type}, portType=${portType}`);
    return false;
  }
  return true;
}

/* =========================
   MODEL REGISTRY
   Physics kernels for thermodynamics, PVT, etc.
   ========================= */
class ModelRegistry {
  constructor() {
    this.catalog = {
      // LEGACY CATEGORIES REMOVED (violated architecture):
      // - pvt_gas: Mixed units (T+273.15), bypassed ComponentRegistry
      // - pvt_liquid: Hardcoded densities, bypassed ComponentRegistry  
      // - water_psat: Water-specific, Â°C units, bypassed ThermoAdapter
      // - humidity: Water-specific, bypassed ThermoAdapter
      // - vle: Direct antoine access (breaks multi-range), bypassed ThermoAdapter
      // - flash: Complex dependencies, ThermoAdapter has better implementation
      
      // KEPT (safe):
      thermo_package: new Map(),    // Thermodynamic property packages
      reaction: new Map(),          // Chemical reactions (future)
      hx: new Map(),                // Heat exchanger models (COP, etc)
      pressure_drop: new Map(),     // Pressure drop correlations
      units: new Map(),             // Unit system for display (UI only)
    };
    this.active = {
      thermo_package: null,
      reaction: null,
      hx: null,
      pressure_drop: null,
      units: null,
    };
  }

  register(kind, model) {
    if (!this.catalog[kind]) throw new Error(`Unknown model kind: ${kind}`);
    if (!model?.id) throw new Error("Model must have id");
    this.catalog[kind].set(model.id, model);
    if (!this.active[kind]) this.active[kind] = model.id;
  }

  get(kind, id) {
    const m = this.catalog[kind];
    if (!m) return null;
    return m.get(id) || null;
  }

  list(kind) {
    const m = this.catalog[kind];
    if (!m) return [];
    return Array.from(m.values());
  }

  setActive(kind, id) {
    // Validate that the model exists before activating
    const model = this.get(kind, id);
    if (!model) {
      console.warn(`ModelRegistry.setActive: Model '${id}' not found for kind '${kind}'. Active model unchanged.`);
      return false;
    }
    
    this.active[kind] = id;
    return true;
  }

  getActive(kind) {
    return this.get(kind, this.active[kind]);
  }
}

const models = new ModelRegistry();

/* =========================
   THERMO MODEL INTERFACE
   Single entry point for ALL thermodynamic calculations
   
   INTERNAL CONVENTION:
   - All temperatures in Kelvin (K)
   - All pressures in Pascal (Pa)
   - UI conversions happen ONLY at display/edit boundaries
   
   REFERENCE STATES:
   - Enthalpy: Ideal gas at 298.15 K, 101325 Pa
   - Entropy: (not yet implemented)
   ========================= */

/**
 * @typedef {Object} FlashResult - Canonical result type for ALL flash calculations
 * 
 * MANDATORY FIELDS (always present on every return path):
 * @property {string} phase       - 'V', 'L', or 'VL'
 * @property {number} beta        - Vapor fraction (0 = all liquid, 1 = all vapor)
 * @property {number} vaporFraction - Same as beta (alias for UI code)
 * @property {Object} x           - Liquid mole fractions  {comp: fraction}
 * @property {Object} y           - Vapor mole fractions   {comp: fraction}
 * @property {Object} nL          - Liquid molar flows     {comp: mol/s}
 * @property {Object} nV          - Vapor molar flows      {comp: mol/s}
 * @property {number} iterations  - Solver iteration count
 * @property {boolean} converged  - TRUE only if residual < tolerance; never a default assumption
 * 
 * PH FLASH ADDITIONAL FIELDS (present on phFlash results):
 * @property {number} T_K           - Solved temperature (K)
 * @property {boolean} bracketed    - Whether the root was bracketed before solve
 * @property {number} residual_Jps  - Final enthalpy residual (J/s); 0 for exact two-phase lever rule
 * @property {number} [Tmin_K]      - Lower temperature bound used in solve
 * @property {number} [Tmax_K]      - Upper temperature bound used in solve
 * @property {string} [warning]     - Human-readable warning if !converged or out-of-range
 */



/* =========================
   THERMO PACKAGE SYSTEM
   
   A ThermoPackage encapsulates all physics that vary between thermodynamic models:
   heat capacity, enthalpy, density, vapor pressure, and VLE K-values.
   
   ThermoAdapter delegates physics calls to the active package while handling
   orchestration (flash algorithms, stream aggregation, bisection solvers).
   
   ADDING A NEW MODEL:
   1. Create a class extending ThermoPackage (or IdealRaoultPackage for partial override)
   2. Override the methods whose physics change
   3. Register with: models.register('thermo_package', new YourPackage())
   4. The Models panel will automatically pick it up
   ========================= */

class ThermoPackage {
  /**
   * @param {string} id          - Unique identifier (e.g., 'ideal_raoult')
   * @param {string} name        - Display name (e.g., 'Ideal Gas + Raoult\'s Law')
   * @param {string} description - One-line description for the UI
   */
  constructor(id, name, description) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.status = 'stable';  // 'stable' | 'preview' | 'experimental'
    this._warnedRanges = new Set();
    this._vaporOffsetCache = {};
  }

  // â”€â”€ Physics API (override in subclasses) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Molar heat capacity Cp [J/(molÂ·K)] */
  cpMolar(comp, T_K, P_Pa, phase) { throw new Error('ThermoPackage.cpMolar not implemented'); }

  /** Molar enthalpy H [J/mol] relative to liquid at 298.15 K */
  hMolar(comp, T_K, P_Pa, phase) { throw new Error('ThermoPackage.hMolar not implemented'); }

  /** Mass density [kg/mÂ³] */
  density(comp, T_K, P_Pa, phase) { throw new Error('ThermoPackage.density not implemented'); }

  /** Saturation (vapor) pressure [Pa], or null if unavailable */
  saturationPressure(comp, T_K) { throw new Error('ThermoPackage.saturationPressure not implemented'); }

  /** VLE K-value: Ki = yi/xi at given T, P.  Default: Raoult (Psat/P) */
  kValue(comp, T_K, P_Pa) {
    const Psat = this.saturationPressure(comp, T_K);
    return Psat ? Psat / P_Pa : 1.0;
  }

  // â”€â”€ Cache Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Clear all internal caches. Called on package switch and component changes. */
  clearCaches() {
    this._vaporOffsetCache = {};
    this._warnedRanges.clear();
  }
}

/**
 * IDEAL GAS + RAOULT'S LAW
 * 
 * Gas phase:   Ideal gas (PV = nRT, Cp from polynomial correlation)
 * Liquid phase: Constant Cp, constant density
 * VLE:          Raoult's law (Ki = Psat_i / P)
 * Vapor pressure: Antoine equation (with multi-range support)
 * 
 * Suitable for: low-pressure systems, ideal mixtures, educational use.
 * Limitations:  No pressure effect on liquid properties, no non-ideal mixing.
 */
class IdealRaoultPackage extends ThermoPackage {
  constructor() {
    super(
      'ideal_raoult',
      'Ideal Gas + Raoult\'s Law',
      'Ideal gas EOS, constant liquid properties, Raoult\'s law VLE. Suitable for low-pressure ideal systems.'
    );
    this.status = 'stable';
  }

  // â”€â”€ Heat Capacity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  cpMolar(comp, T_K, P_Pa, phaseHint = null) {
    const compData = ComponentRegistry.get(comp);
    if (!compData) { console.warn(`Component ${comp} not found`); return 0; }

    let phase = phaseHint;
    if (!phase) { phase = (T_K < compData.Tb) ? 'L' : 'V'; }

    if (phase === 'L') {
      if (!compData.cpLiq) {
        console.warn(`No liquid Cp for ${comp}, using ideal gas Cp (may be inaccurate)`);
        phase = 'V';
      } else {
        return compData.cpLiq;
      }
    }

    if (!compData.cpig) { console.warn(`No heat capacity correlation for ${comp}`); return 0; }
    const cpig = compData.cpig;

    // Clamp T to valid range to prevent catastrophic polynomial extrapolation
    let T_eval = T_K;
    if (cpig.Tmin && T_K < cpig.Tmin) {
      console.warn(`Temperature ${T_K}K below Cp correlation range for ${comp} (min ${cpig.Tmin}K)`);
      T_eval = cpig.Tmin;
    }
    if (cpig.Tmax && T_K > cpig.Tmax) {
      console.warn(`Temperature ${T_K}K above Cp correlation range for ${comp} (max ${cpig.Tmax}K)`);
      T_eval = cpig.Tmax;
    }

    const T = T_eval;
    return cpig.A + cpig.B * T + cpig.C * T * T + cpig.D * T * T * T + (cpig.E || 0) * T * T * T * T;
  }

  // â”€â”€ Enthalpy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  hMolar(comp, T_K, P_Pa, phaseHint = null) {
    const compData = ComponentRegistry.get(comp);
    if (!compData) { console.warn(`Component ${comp} not found in registry`); return 0; }

    const Tref = 298.15;
    let phase = phaseHint;
    if (!phase) { phase = (T_K < compData.Tb) ? 'L' : 'V'; }

    if (phase === 'V') {
      if (!compData.cpig) { console.warn(`No ideal gas Cp correlation for ${comp}`); return 0; }
      const cpig = compData.cpig;

      // Range warnings (deduplicated)
      if (cpig.Tmin && T_K < cpig.Tmin) {
        const wk = `${comp}-cpig-below-${cpig.Tmin}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K below Cp_ig range for ${comp} (min ${cpig.Tmin}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }
      if (cpig.Tmax && T_K > cpig.Tmax) {
        const wk = `${comp}-cpig-above-${cpig.Tmax}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K above Cp_ig range for ${comp} (max ${cpig.Tmax}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }

      function integratedCpig(T) {
        return cpig.A * T + cpig.B * T * T / 2 + cpig.C * T * T * T / 3
             + cpig.D * T * T * T * T / 4 + (cpig.E || 0) * T * T * T * T * T / 5;
      }
      function cpigAt(T) {
        return cpig.A + cpig.B * T + cpig.C * T * T + cpig.D * T * T * T + (cpig.E || 0) * T * T * T * T;
      }

      // Integrate with clamping: beyond valid range, extend linearly with Cp at boundary
      let hV_sens;
      const Tmin_cp = cpig.Tmin || 0;
      const Tmax_cp = cpig.Tmax || Infinity;

      if (T_K > Tmax_cp) {
        hV_sens = (integratedCpig(Tmax_cp) - integratedCpig(Tref)) + cpigAt(Tmax_cp) * (T_K - Tmax_cp);
      } else if (T_K < Tmin_cp) {
        hV_sens = (integratedCpig(Tmin_cp) - integratedCpig(Tref)) + cpigAt(Tmin_cp) * (T_K - Tmin_cp);
      } else {
        hV_sens = integratedCpig(T_K) - integratedCpig(Tref);
      }

      const dHref_vap = this._getVaporEnthalpyOffset(comp);
      return hV_sens + dHref_vap;

    } else if (phase === 'L') {
      if (!compData.cpLiq) { console.warn(`No liquid Cp for ${comp}`); return 0; }
      const cpLiq = compData.cpLiq;

      if (typeof cpLiq === 'object' && cpLiq.A !== undefined) {
        function integratedCpLiq(T) {
          return cpLiq.A * T + (cpLiq.B || 0) * T * T / 2 + (cpLiq.C || 0) * T * T * T / 3
               + (cpLiq.D || 0) * T * T * T * T / 4 + (cpLiq.E || 0) * T * T * T * T * T / 5;
        }
        return integratedCpLiq(T_K) - integratedCpLiq(Tref);
      } else {
        return cpLiq * (T_K - Tref);
      }
    } else {
      console.warn(`Unknown phase '${phase}' for ${comp}`);
      return 0;
    }
  }

  /** Compute vapor enthalpy reference offset. Cached for performance. */
  _getVaporEnthalpyOffset(comp) {
    if (this._vaporOffsetCache[comp] !== undefined) {
      return this._vaporOffsetCache[comp];
    }

    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.Hv || !compData.Tb) {
      console.warn(`Cannot compute vapor offset for ${comp} - missing Hv or Tb`);
      this._vaporOffsetCache[comp] = 0;
      return 0;
    }

    const Tref = 298.15;
    const Tb = compData.Tb;
    const Hv = compData.Hv;
    const cpig = compData.cpig;
    const cpLiq = compData.cpLiq;

    if (!cpig || !cpLiq) {
      console.warn(`Cannot compute vapor offset for ${comp} - missing Cp data`);
      this._vaporOffsetCache[comp] = 0;
      return 0;
    }

    function integratedCpig(T) {
      return cpig.A * T + cpig.B * T * T / 2 + cpig.C * T * T * T / 3
           + cpig.D * T * T * T * T / 4 + (cpig.E || 0) * T * T * T * T * T / 5;
    }
    const hV_sens_at_Tb = integratedCpig(Tb) - integratedCpig(Tref);

    let hL_at_Tb;
    if (typeof cpLiq === 'object' && cpLiq.A !== undefined) {
      function integratedCpLiq(T) {
        return cpLiq.A * T + (cpLiq.B || 0) * T * T / 2 + (cpLiq.C || 0) * T * T * T / 3
             + (cpLiq.D || 0) * T * T * T * T / 4 + (cpLiq.E || 0) * T * T * T * T * T / 5;
      }
      hL_at_Tb = integratedCpLiq(Tb) - integratedCpLiq(Tref);
    } else {
      hL_at_Tb = cpLiq * (Tb - Tref);
    }

    const dHref_vap = Hv - (hV_sens_at_Tb - hL_at_Tb);
    this._vaporOffsetCache[comp] = dHref_vap;
    return dHref_vap;
  }

  // â”€â”€ Density â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  density(comp, T_K, P_Pa, phaseHint) {
    if (phaseHint === 'L') {
      const compData = ComponentRegistry.get(comp);
      const rhoLiq = compData && compData.rhoLiq;
      if (rhoLiq) return rhoLiq;
      console.warn(`No liquid density (rhoLiq) for ${comp}, using default 1000 kg/mÂ³`);
      return 1000;
    } else if (phaseHint === 'V') {
      const compData = ComponentRegistry.get(comp);
      const MW = compData ? compData.MW : 28;
      const R = 8.314;
      return (P_Pa * MW / 1000) / (R * T_K);
    }
    return null;
  }

  // â”€â”€ Vapor Pressure (Antoine) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  saturationPressure(comp, T_K) {
    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.antoine) {
      console.warn(`No Antoine coefficients for ${comp}`);
      return null;
    }

    let antoineData = compData.antoine;
    const T_C = T_K - 273.15;

    if (Array.isArray(antoineData)) {
      let selectedRange = null;
      let closestRange = null;
      let closestDist = Infinity;

      for (const range of antoineData) {
        if (T_K >= range.Tmin && T_K <= range.Tmax) { selectedRange = range; break; }
        const dist = Math.min(Math.abs(T_K - range.Tmin), Math.abs(T_K - range.Tmax));
        if (dist < closestDist) { closestDist = dist; closestRange = range; }
      }

      if (selectedRange) {
        antoineData = selectedRange;
      } else {
        const side = T_K < closestRange.Tmin ? 'below' : 'above';
        const wk = `${comp}-antoine-${side}`;
        if (!this._warnedRanges.has(wk)) {
          const desc = closestRange.desc || `${closestRange.Tmin}-${closestRange.Tmax}K`;
          console.warn(`T=${T_K.toFixed(1)}K outside all Antoine ranges for ${comp}, using closest range (${desc})`);
          this._warnedRanges.add(wk);
        }
        antoineData = closestRange;
      }
    } else {
      if (antoineData.Tmin && T_K < antoineData.Tmin) {
        const wk = `${comp}-antoine-below-${antoineData.Tmin}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K below Antoine range for ${comp} (min ${antoineData.Tmin}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }
      if (antoineData.Tmax && T_K > antoineData.Tmax) {
        const wk = `${comp}-antoine-above-${antoineData.Tmax}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K above Antoine range for ${comp} (max ${antoineData.Tmax}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }
    }

    const log10_Psat_mmHg = antoineData.A - antoineData.B / (antoineData.C + T_C);
    const Psat_mmHg = Math.pow(10, log10_Psat_mmHg);
    return Psat_mmHg * 133.322;
  }

  // â”€â”€ VLE K-value (Raoult's law) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  kValue(comp, T_K, P_Pa) {
    const Psat = this.saturationPressure(comp, T_K);
    return Psat ? Psat / P_Pa : 1.0;
  }
}

/**
 * PENG-ROBINSON EQUATION OF STATE (Stub)
 * 
 * Cubic EOS for non-ideal gas and liquid phases:
 *   P = RT/(V-b) - a(T)/[V(V+b) + b(V-b)]
 * 
 * Will provide: departure functions for H and Cp, liquid density from cubic roots,
 * fugacity coefficients for rigorous VLE (Ki = Ï†_L_i / Ï†_V_i).
 * 
 * Currently falls back to IdealRaoultPackage for all methods.
 * Override methods here as the implementation is built out.
 * 
 * STATUS: preview â€” not yet implemented; selecting this uses ideal gas as fallback.
 */
class PengRobinsonPackage extends IdealRaoultPackage {
  constructor() {
    super();
    // Override base class identity
    this.id = 'peng_robinson';
    this.name = 'Peng-Robinson EOS';
    this.description = 'Cubic EOS for non-ideal systems. Accurate for hydrocarbons at moderate to high pressures. (Not yet implemented â€” falls back to ideal gas.)';
    this.status = 'preview';
  }

  // â”€â”€ Future overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When implementing, override these one by one.
  // Each override replaces the ideal-gas version with PR departure functions.

  // cpMolar(comp, T_K, P_Pa, phase) {
  //   // TODO: Cp_ig(T) + Cp_departure(T, P, phase)
  //   // Cp_dep = -T * dÂ²a/dTÂ² * ... (from EOS)
  // }

  // hMolar(comp, T_K, P_Pa, phase) {
  //   // TODO: H_ig(T) + H_departure(T, P, phase)
  //   // H_dep = [a - T*da/dT] * integral term from cubic solution
  // }

  // density(comp, T_K, P_Pa, phase) {
  //   // TODO: Solve cubic ZÂ³ - (1-B)ZÂ² + (A-3BÂ²-2B)Z - (AB-BÂ²-BÂ³) = 0
  //   // Ï = P * MW / (Z * R * T)
  // }

  // saturationPressure(comp, T_K) {
  //   // TODO: Iterative bubble point: find P where Ï†_L = Ï†_V
  // }

  // kValue(comp, T_K, P_Pa) {
  //   // TODO: Ki = Ï†_L_i(T,P,x) / Ï†_V_i(T,P,y)
  //   // Requires iterative solution with composition dependence
  // }
}

class ThermoAdapter {
  constructor(pkg) {
    if (!pkg || !(pkg instanceof ThermoPackage)) {
      throw new Error('ThermoAdapter requires a ThermoPackage instance');
    }
    this._pkg = pkg;
  }
  
  /** Proxy _warnedRanges to active package (used by saturationTemperature and tests) */
  get _warnedRanges() { return this._pkg._warnedRanges; }
  set _warnedRanges(v) { this._pkg._warnedRanges = v; }
  
  /** Switch active thermo package. Clears all caches and warnings. */
  setPackage(pkg) {
    if (!pkg || !(pkg instanceof ThermoPackage)) {
      throw new Error('setPackage requires a ThermoPackage instance');
    }
    this._pkg.clearCaches();
    this._pkg = pkg;
  }
  
  /** Get active package info */
  getPackage() { return this._pkg; }
  
  /**
   * Normalize phase hint to single-phase value
   * 
   * CRITICAL: Prevents passing 'VL' to single-phase property functions (cpMolar, hMolar, etc)
   * which expect only 'V' or 'L'. This is a common silent corruption bug when VL streams
   * have undefined quality and fallback logic uses phaseConstraint='VL' as a phase hint.
   * 
   * @param {string} phaseConstraintOrHint - Phase from stream.phaseConstraint or similar
   * @param {string} defaultPhase - Default single phase to use ('L' or 'V'), default 'L'
   * @returns {string} Single phase: 'V' or 'L' (never 'VL')
   */
  normalizeSinglePhaseHint(phaseConstraintOrHint, defaultPhase = 'L') {
    // Validate defaultPhase is single-phase
    if (defaultPhase !== 'V' && defaultPhase !== 'L') {
      console.warn(`normalizeSinglePhaseHint: invalid defaultPhase '${defaultPhase}', using 'L'`);
      defaultPhase = 'L';
    }
    
    // Map to single phase
    if (phaseConstraintOrHint === 'V') return 'V';
    if (phaseConstraintOrHint === 'L') return 'L';
    
    // Anything else (including 'VL', null, undefined, '') â†’ defaultPhase
    return defaultPhase;
  }
  
  /**
   * Get component property (molecular weight, critical properties, etc.)
   * @param {string} comp - Component formula (e.g., 'H2O')
   * @param {string} prop - Property name: 'MW', 'Tc', 'Pc', 'omega', etc.
   * @returns {number} Property value
   */
  getComponentProp(comp, prop) {
    const compData = ComponentRegistry.get(comp);
    if (!compData) {
      console.warn(`Component ${comp} not found`);
      return null;
    }
    return compData[prop];
  }
  
  /** Molar heat capacity [J/(molÂ·K)] â€” delegated to active thermo package */
  cpMolar(comp, T_K, P_Pa, phaseHint = null) {
    return this._pkg.cpMolar(comp, T_K, P_Pa, phaseHint);
  }
  
  /** Molar enthalpy [J/mol] â€” delegated to active thermo package */
  hMolar(comp, T_K, P_Pa, phaseHint = null) {
    return this._pkg.hMolar(comp, T_K, P_Pa, phaseHint);
  }
  
    /**
   * Compute complete enthalpy properties for a material stream
   * 
   * Calculates total enthalpy flow (Hdot) and mixture molar enthalpy (hMolarMix)
   * 
   * For single phase: Hdot = Î£(n_i * h_i(T, P, phase))
   * For two-phase:    Hdot = Î£(nV_i * h_i(T, P, 'V')) + Î£(nL_i * h_i(T, P, 'L'))
   * 
   * CRITICAL: For VL phase, only uses nV/nL if split is actually defined
   * If quality is undefined (e.g., single-component at saturation), falls back
   * to single-phase calculation with warning
   * 
   * @param {Object} stream - Material stream with {T, P, n, phase, nV, nL, ...}
   * @returns {Object} Stream with added enthalpy properties
   */
  computeStreamEnthalpy(stream) {
    if (!stream || stream.type !== StreamType.MATERIAL) {
      console.warn('computeStreamEnthalpy called on non-material stream');
      return stream;
    }
    
    // Total molar flow
    const nTot = Object.values(stream.n || {}).reduce((sum, n) => sum + n, 0);
    
    if (nTot < 1e-12) {
      // Empty stream
      stream.nTot = 0;
      stream.hMolarMix = 0;
      stream.Hdot_J_s = 0;
      return stream;
    }
    
    let Hdot_total = 0;  // J/s (internal unit)
    
    // Check if VL split is actually defined
    if (stream.phase === 'VL' && this._isVLSplitDefined(stream)) {
      // TWO-PHASE WITH DEFINED SPLIT: Direct sum of component contributions
      // Hdot = Î£(nV_i * hV_i) + Î£(nL_i * hL_i)
      
      // Vapor contribution
      for (const [comp, n_i] of Object.entries(stream.nV)) {
        if (n_i > 1e-12) {  // Skip negligible flows
          const h_i = this.hMolar(comp, stream.T, stream.P, 'V');
          if (!Number.isFinite(h_i)) {
            console.warn(`hMolar returned ${h_i} for ${comp} (V) at T=${stream.T}K, P=${stream.P}Pa â€” treating as 0`);
            continue;
          }
          Hdot_total += n_i * h_i;  // mol/s * J/mol = J/s
        }
      }
      
      // Liquid contribution
      for (const [comp, n_i] of Object.entries(stream.nL)) {
        if (n_i > 1e-12) {  // Skip negligible flows
          const h_i = this.hMolar(comp, stream.T, stream.P, 'L');
          if (!Number.isFinite(h_i)) {
            console.warn(`hMolar returned ${h_i} for ${comp} (L) at T=${stream.T}K, P=${stream.P}Pa â€” treating as 0`);
            continue;
          }
          Hdot_total += n_i * h_i;  // mol/s * J/mol = J/s
        }
      }
      
    } else if (stream.phase === 'VL' && !this._isVLSplitDefined(stream)) {
      // VL PHASE BUT UNDEFINED SPLIT (e.g., saturation with unknown quality)
      // Fallback to single-phase calculation with warning
      
      // CRITICAL: Use normalizeSinglePhaseHint to prevent passing 'VL' to hMolar
      // stream.phaseConstraint might be 'VL', which is invalid for single-phase functions
      const fallbackPhase = this.normalizeSinglePhaseHint(stream.phaseConstraint, 'L');
      
      console.warn(`VL phase with undefined quality detected - using ${fallbackPhase} phase for enthalpy (PH flash required)`);
      
      for (const [comp, n_i] of Object.entries(stream.n)) {
        if (n_i > 1e-12) {
          const h_i = this.hMolar(comp, stream.T, stream.P, fallbackPhase);
          if (!Number.isFinite(h_i)) {
            console.warn(`hMolar returned ${h_i} for ${comp} (${fallbackPhase}) at T=${stream.T}K, P=${stream.P}Pa â€” treating as 0`);
            continue;
          }
          Hdot_total += n_i * h_i;
        }
      }
      
      // Mark stream with warning
      stream.enthalpyWarning = `Quality undefined at saturation - ${fallbackPhase} phase assumed. PH flash required for accurate enthalpy.`;
      
    } else {
      // SINGLE PHASE: Sum component contributions
      // Hdot = Î£(n_i * h_i)
      const phase = stream.phase || 'V';
      
      for (const [comp, n_i] of Object.entries(stream.n)) {
        if (n_i > 1e-12) {  // Skip negligible flows
          const h_i = this.hMolar(comp, stream.T, stream.P, phase);
          if (!Number.isFinite(h_i)) {
            console.warn(`hMolar returned ${h_i} for ${comp} (${phase}) at T=${stream.T}K, P=${stream.P}Pa â€” treating as 0`);
            continue;
          }
          Hdot_total += n_i * h_i;  // mol/s * J/mol = J/s
        }
      }
    }
    
    // [v4.0.0] Final NaN guard â€” if enthalpy is non-finite, zero it and warn
    if (!Number.isFinite(Hdot_total)) {
      console.warn(`computeStreamEnthalpy: Hdot_total is ${Hdot_total} â€” resetting to 0`);
      Hdot_total = 0;
    }
    
    // Compute mixture molar enthalpy
    const hMolarMix = Hdot_total / nTot;  // J/mol
    
    // Store on stream (INTERNAL UNITS: J/s, J/mol)
    stream.nTot = nTot;
    stream.hMolarMix = hMolarMix;  // J/mol
    stream.Hdot_J_s = Hdot_total;  // J/s (canonical internal unit)
    
    // Validation: Ensure non-empty stream has non-zero enthalpy unless at reference
    if (nTot > 1e-12 && Math.abs(Hdot_total) < 1e-6 && Math.abs(stream.T - 298.15) > 0.1) {
      console.warn(`Stream at T=${stream.T}K has Hdotâ‰ˆ0 - possible enthalpy calculation error`);
    }
    
    return stream;
  }
  
  /**
   * Get total enthalpy flow rate in J/s, ensuring it's computed
   * 
   * CRITICAL: This function guarantees enthalpy is computed before use.
   * Use this in units that need inlet enthalpy (valve, heater, etc) to avoid
   * silent failures when Hdot is undefined.
   * 
   * INTERNAL UNITS: Returns J/s (canonical)
   * 
   * @param {Object} stream - Material stream
   * @returns {number} Hdot in J/s, or 0 if stream invalid
   */
  getHdot_Jps(stream) {
    if (!stream || stream.type !== StreamType.MATERIAL) {
      console.warn('getHdot_Jps: invalid or non-material stream');
      return 0;
    }
    
    // Check if stream has minimum required fields for enthalpy calculation
    if (!stream.T || !stream.P || !stream.n) {
      console.warn('getHdot_Jps: stream missing T, P, or n - cannot compute enthalpy');
      return 0;
    }
    
    // If Hdot already computed and valid, return it (J/s)
    if (stream.Hdot_J_s !== undefined && stream.Hdot_J_s !== null && !isNaN(stream.Hdot_J_s)) {
      return stream.Hdot_J_s;  // Already in J/s
    }
    
    // Need to compute enthalpy on-demand
    // First ensure flash is done if needed
    if (!stream.phase) {
      try {
        const flashResult = this.tpFlash(stream);
        stream.phase = flashResult.phase;
        stream.beta = flashResult.beta;
        stream.nV = flashResult.nV;
        stream.nL = flashResult.nL;
        stream.x = flashResult.x;
        stream.y = flashResult.y;
      } catch (err) {
        console.warn(`getHdot_Jps: flash failed - ${err.message}`);
        return 0;
      }
    }
    
    // Now compute enthalpy
    try {
      this.computeStreamEnthalpy(stream);
      return stream.Hdot_J_s;  // J/s
    } catch (err) {
      console.warn(`getHdot_Jps: enthalpy calculation failed - ${err.message}`);
      return 0;
    }
  }
  
  /**
   * Density
   * @param {string} comp - Component formula
   * @param {number} T_K - Temperature in Kelvin
   * @param {number} P_Pa - Pressure in Pascal
   * @param {string} phaseHint - 'V' for vapor, 'L' for liquid
   * @returns {number} Density in kg/mÂ³
   */
  /** Mass density [kg/mÂ³] â€” delegated to active thermo package */
  density(comp, T_K, P_Pa, phaseHint) {
    return this._pkg.density(comp, T_K, P_Pa, phaseHint);
  }
  
  
  /**
   * Temperature-Pressure flash calculation
   * Determines phase split and equilibrium for given T, P, composition
   * @param {Object} stream - {T: K, P: Pa, n: {comp: mol/s}, phaseConstraint: 'V'|'L'|'VL'}
   * @returns {Object} {phase, beta, vaporFraction, x, y, nL, nV}
   */
  tpFlash(stream) {
    const T_K = stream.T;
    const P_Pa = stream.P;
    const n = stream.n;
    const phaseConstraint = stream.phaseConstraint || 'VL';
    
    // Built-in TP flash implementation (legacy external flash model removed in v1.5.0)
    // Uses Raoult's law with Rachford-Rice for multi-component VLE
    
    const comps = Object.keys(n);
    const nTotal = Object.values(n).reduce((a,b) => a+b, 0);
    
    if (nTotal < 1e-12) {
      return {
        phase: 'V',
        beta: 1.0,
        vaporFraction: 1.0,
        x: {},
        y: {},
        nL: {},
        nV: {}
      };
    }
    
    // Simple single-component flash using saturation pressure
    if (comps.length === 1) {
      const comp = comps[0];
      const Psat = this.saturationPressure(comp, T_K);
      
      if (!Psat) {
        // No saturation pressure available, use phase constraint
        if (phaseConstraint === 'L') {
          return {
            phase: 'L',
            beta: 0.0,
            vaporFraction: 0.0,
            x: { [comp]: 1.0 },
            y: {},
            nL: { [comp]: n[comp] },
            nV: {}
          };
        }
        return {
          phase: 'V',
          beta: 1.0,
          vaporFraction: 1.0,
          x: {},
          y: { [comp]: 1.0 },
          nL: {},
          nV: { [comp]: n[comp] }
        };
      }
      
      const K = Psat / P_Pa;
      
      if (phaseConstraint === 'V' || K > 1.05) {
        // Vapor phase
        return {
          phase: 'V',
          beta: 1.0,
          vaporFraction: 1.0,
          x: {},
          y: { [comp]: 1.0 },
          nL: {},
          nV: { [comp]: n[comp] }
        };
      } else if (phaseConstraint === 'L' || K < 0.95) {
        // Liquid phase
        return {
          phase: 'L',
          beta: 0.0,
          vaporFraction: 0.0,
          x: { [comp]: 1.0 },
          y: {},
          nL: { [comp]: n[comp] },
          nV: {}
        };
      } else {
        // FIX 4: Two-phase region (0.95 < K < 1.05)
        // For single component at saturation: K â‰ˆ 1
        // Quality (vapor fraction) is UNDEFINED from TP alone
        // Requires energy balance (PH flash) to determine actual split
        
        return {
          phase: 'VL',
          beta: null,  // Undefined - requires PH flash
          vaporFraction: null,
          x: { [comp]: 1.0 },
          y: { [comp]: 1.0 },
          nL: {},  // Cannot determine without energy balance
          nV: {},  // Cannot determine without energy balance
          warning: 'Single-component at saturation: quality undefined in TP flash. Requires PH flash for vapor fraction.'
        };
      }
    }
    
    // â”€â”€ Multi-component Rachford-Rice VLE flash (Raoult's law) â”€â”€
    // K_i = Psat_i(T) / P for each component
    // Solve: Î£ z_i(K_i - 1) / (1 + Î²(K_i - 1)) = 0  for Î² âˆˆ [0, 1]
    
    const z = {};   // Overall mole fractions
    const K = {};   // K-values
    let allAbove = true;   // All K > 1 â†’ all vapor
    let allBelow = true;   // All K < 1 â†’ all liquid
    
    for (const c of comps) {
      z[c] = n[c] / nTotal;
      const Psat = this.saturationPressure(c, T_K);
      if (Psat) {
        K[c] = Psat / P_Pa;
      } else {
        // No Psat data (supercritical or missing Antoine) â†’ non-condensable
        K[c] = T_K > (ComponentRegistry.get(c)?.Tc || 1e6) ? 1e6 : 1.0;
      }
      if (K[c] <= 1.0) allAbove = false;
      if (K[c] >= 1.0) allBelow = false;
    }
    
    // Phase constraint shortcuts
    if (phaseConstraint === 'L') {
      return {
        phase: 'L', beta: 0.0, vaporFraction: 0.0,
        x: { ...z }, y: {},
        nL: { ...n }, nV: {}
      };
    }
    if (phaseConstraint === 'V') {
      return {
        phase: 'V', beta: 1.0, vaporFraction: 1.0,
        x: {}, y: { ...z },
        nL: {}, nV: { ...n }
      };
    }
    
    // Check dew/bubble conditions
    // Bubble point check: Î£ z_i K_i.  If < 1, all liquid (below bubble point)
    // Dew point check:    Î£ z_i / K_i. If < 1, all vapor (above dew point)
    let sumZK = 0, sumZoverK = 0;
    for (const c of comps) { sumZK += z[c] * K[c]; sumZoverK += z[c] / K[c]; }
    
    if (sumZK <= 1.0) {
      // Below bubble point â†’ all liquid
      return {
        phase: 'L', beta: 0.0, vaporFraction: 0.0,
        x: { ...z }, y: {},
        nL: { ...n }, nV: {}
      };
    }
    
    if (sumZoverK <= 1.0) {
      // Above dew point â†’ all vapor
      return {
        phase: 'V', beta: 1.0, vaporFraction: 1.0,
        x: {}, y: { ...z },
        nL: {}, nV: { ...n }
      };
    }
    
    // â”€â”€ Two-phase: solve Rachford-Rice by Newton-Raphson â”€â”€
    let beta = 0.5;  // Initial guess
    
    for (let iter = 0; iter < 50; iter++) {
      let f = 0, df = 0;
      for (const c of comps) {
        const km1 = K[c] - 1;
        const denom = 1 + beta * km1;
        f += z[c] * km1 / denom;
        df -= z[c] * km1 * km1 / (denom * denom);
      }
      
      if (Math.abs(f) < 1e-12) break;
      
      const step = f / df;
      beta -= step;
      
      // Clamp to valid range
      beta = Math.max(1e-10, Math.min(1 - 1e-10, beta));
    }
    
    // Compute phase compositions and flows
    const x = {}, y = {}, nL_out = {}, nV_out = {};
    for (const c of comps) {
      x[c] = z[c] / (1 + beta * (K[c] - 1));
      y[c] = K[c] * x[c];
      nL_out[c] = x[c] * (1 - beta) * nTotal;
      nV_out[c] = y[c] * beta * nTotal;
    }
    
    return {
      phase: 'VL',
      beta: beta,
      vaporFraction: beta,
      x, y,
      nL: nL_out,
      nV: nV_out
    };
  }
  
  /**
   * Pressure-Enthalpy flash calculation
   * 
   * Accepts target enthalpy via EITHER:
   *   - Second argument: phFlash(stream, H_target_Jps)
   *   - Stream property:  phFlash({ P, n, H_target_Jps })
   * 
   * The solver uses the two-argument form; direct callers and tests may use either.
   * If both are provided, the explicit second argument takes precedence.
   * 
   * @param {Object} stream - {P: Pa, n: {comp: mol/s}, H_target_Jps?: number}
   * @param {number} [H_target_Jps] - Target enthalpy in J/s (optional if on stream)
   * @returns {Object} Flash result with T_K, converged, residual_Jps, etc.
   */
  phFlash(stream, H_target_Jps) {
    // PH FLASH: Given P, n, and target enthalpy, solve for T and phase split
    // Supports single-component (with saturation handling) and mixtures
    
    // CRITICAL: Accept H_target_Jps from either the second argument or the stream object.
    // The explicit argument takes precedence when provided.
    if (H_target_Jps === undefined || H_target_Jps === null) {
      H_target_Jps = stream.H_target_Jps;
    }
    
    // Validate that we actually have a target
    if (H_target_Jps === undefined || H_target_Jps === null || !isFinite(H_target_Jps)) {
      console.error('phFlash: No valid H_target_Jps provided (neither as argument nor on stream)');
      return {
        phase: 'V', beta: 1.0, vaporFraction: 1.0,
        x: {}, y: {}, nL: {}, nV: {},
        T_K: 298.15, iterations: 0,
        converged: false, bracketed: false,
        residual_Jps: NaN,
        warning: 'phFlash called without valid H_target_Jps'
      };
    }
    
    const P_Pa = stream.P;
    const n = stream.n;
    const phaseConstraint = stream.phaseConstraint || 'VL';
    
    const nTot = Object.values(n).reduce((sum, val) => sum + val, 0);
    
    if (nTot < 1e-12) {
      // Empty stream - return default vapor at reference T
      return {
        phase: 'V',
        beta: 1.0,
        vaporFraction: 1.0,
        x: {},
        y: {},
        nL: {},
        nV: {},
        T_K: 298.15,
        iterations: 0,
        converged: true,
        bracketed: true,
        residual_Jps: 0,
        warning: undefined
      };
    }
    
    // Target molar enthalpy
    const h_target = H_target_Jps / nTot;  // J/mol
    
    // Check if single component
    const comps = Object.keys(n);
    const isSingleComponent = (comps.length === 1);
    
    if (isSingleComponent && phaseConstraint === 'VL') {
      // SINGLE-COMPONENT SPECIAL HANDLING
      return this._phFlash_SingleComponent(comps[0], P_Pa, n, h_target, H_target_Jps);
    }
    
    // GENERAL CASE (mixtures or constrained phase)
    return this._phFlash_General(P_Pa, n, h_target, H_target_Jps, phaseConstraint);
  }
  
  /**
   * PH flash for single component with saturation handling
   * 
   * Determines region (subcooled, two-phase, superheated) using saturation enthalpies,
   * then solves for T (subcooled/superheated) or quality (two-phase).
   * 
   * Returns SAME metadata contract as _phFlash_General:
   *   {T_K, converged, bracketed, residual_Jps, iterations, Tmin_K, Tmax_K, warning, ...}
   * 
   * @private
   */
  _phFlash_SingleComponent(comp, P_Pa, n, h_target, H_target_Jps) {
    const nTot = n[comp];
    const compData = ComponentRegistry.get(comp);
    
    // Find saturation temperature at this pressure
    const Tsat = this._findSaturationTemperature(comp, P_Pa);
    
    if (!Tsat) {
      // Cannot find Tsat (supercritical, no Antoine data, etc.) â€” fall back to general method
      console.warn(`Cannot find Tsat for ${comp} at P=${P_Pa}Pa - using general PH flash`);
      return this._phFlash_General(P_Pa, n, h_target, H_target_Jps, 'VL');
    }
    
    // Compute liquid and vapor enthalpies at saturation
    const hf = this.hMolar(comp, Tsat, P_Pa, 'L');  // Saturated liquid enthalpy (J/mol)
    const hg = this.hMolar(comp, Tsat, P_Pa, 'V');  // Saturated vapor enthalpy (J/mol)
    
    // Determine region and solve
    if (h_target < hf * 0.9999) {
      // â”€â”€â”€ SUBCOOLED LIQUID: h < hf â”€â”€â”€
      // Adaptive lower bound: use melting point or fraction of Tb, with absolute minimum
      const Tmin_solve = Math.max(50, compData.Tm || (compData.Tb ? compData.Tb * 0.4 : 50));
      const Tmax_solve = Tsat;
      
      const solveResult = this._solveTemperatureForEnthalpy(comp, P_Pa, h_target, 'L', Tmin_solve, Tmax_solve);
      const residual_Jps = solveResult.residual * nTot;  // J/mol â†’ J/s
      
      return {
        phase: 'L',
        beta: 0.0,
        vaporFraction: 0.0,
        x: { [comp]: 1.0 },
        y: {},
        nL: { [comp]: nTot },
        nV: {},
        T_K: solveResult.T_K,
        iterations: solveResult.iterations,
        converged: solveResult.converged,
        bracketed: solveResult.bracketed,
        residual_Jps: residual_Jps,
        Tmin_K: Tmin_solve,
        Tmax_K: Tmax_solve,
        warning: solveResult.warning
      };
      
    } else if (h_target > hg * 1.0001) {
      // â”€â”€â”€ SUPERHEATED VAPOR: h > hg â”€â”€â”€
      const Tmin_solve = Tsat;
      const Tmax_solve = 3000;  // Match _phFlash_General's upper bound
      
      const solveResult = this._solveTemperatureForEnthalpy(comp, P_Pa, h_target, 'V', Tmin_solve, Tmax_solve);
      const residual_Jps = solveResult.residual * nTot;  // J/mol â†’ J/s
      
      return {
        phase: 'V',
        beta: 1.0,
        vaporFraction: 1.0,
        x: {},
        y: { [comp]: 1.0 },
        nL: {},
        nV: { [comp]: nTot },
        T_K: solveResult.T_K,
        iterations: solveResult.iterations,
        converged: solveResult.converged,
        bracketed: solveResult.bracketed,
        residual_Jps: residual_Jps,
        Tmin_K: Tmin_solve,
        Tmax_K: Tmax_solve,
        warning: solveResult.warning
      };
      
    } else {
      // â”€â”€â”€ TWO-PHASE: hf â‰¤ h â‰¤ hg â”€â”€â”€
      // Compute quality from lever rule â€” exact for single component
      const beta = (h_target - hf) / (hg - hf);
      const beta_clamped = Math.max(0, Math.min(1, beta));
      
      const nV_val = beta_clamped * nTot;
      const nL_val = (1 - beta_clamped) * nTot;
      
      // Residual is zero by construction (lever rule gives exact h)
      return {
        phase: 'VL',
        beta: beta_clamped,
        vaporFraction: beta_clamped,
        x: { [comp]: 1.0 },
        y: { [comp]: 1.0 },
        nL: { [comp]: nL_val },
        nV: { [comp]: nV_val },
        T_K: Tsat,
        iterations: 1,
        converged: true,
        bracketed: true,
        residual_Jps: 0,
        Tmin_K: Tsat,
        Tmax_K: Tsat,
        warning: undefined
      };
    }
  }
  
  /**
   * General PH flash for mixtures or constrained phases
   * @private
   */
  _phFlash_General(P_Pa, n, h_target, H_target_Jps, phaseConstraint) {
    const nTot = Object.values(n).reduce((sum, val) => sum + val, 0);
    
    // Define enthalpy calculation function at temperature T
    const Hcalc = (T_K) => {
      // Build temporary stream
      const tempStream = {
        type: StreamType.MATERIAL,
        T: T_K,
        P: P_Pa,
        n: { ...n },
        phaseConstraint
      };
      
      // Flash at this T
      const flashResult = this.tpFlash(tempStream);
      
      // Augment with flash results
      tempStream.phase = flashResult.phase;
      tempStream.beta = flashResult.beta;
      tempStream.nV = flashResult.nV;
      tempStream.nL = flashResult.nL;
      tempStream.x = flashResult.x;
      tempStream.y = flashResult.y;
      
      // Compute enthalpy
      this.computeStreamEnthalpy(tempStream);
      
      return tempStream.Hdot_J_s;  // J/s (internal unit)
    };
    
    // Solve for T using bracketed method
    // Adaptive bounds based on component properties
    const comps = Object.keys(n);
    let Tmin_default = 200;
    for (const c of comps) {
      const cd = ComponentRegistry.get(c);
      if (cd) {
        const Tlow = Math.max(20, (cd.Tm || cd.Tb * 0.5 || 50) - 20);
        Tmin_default = Math.min(Tmin_default, Tlow);
      }
    }
    let Tmin = Tmin_default;
    let Tmax = 2000;  // K
    
    // Narrow bracket if phase-constrained
    if (phaseConstraint === 'L') {
      Tmax = 700;  // Reasonable max for liquids
    }
    
    // Regula falsi with bisection fallback
    let T_solution = null;
    let iterations = 0;
    const MAX_ITER = 150;
    const TOL = Math.max(5e-4 * Math.abs(H_target_Jps), 1e-3);  // J/s â€” 0.05% relative or 1 mJ/s absolute
    const ZERO_DENOMINATOR_THRESHOLD = 1e-6;  // Guard against Hmax â‰ˆ Hmin
    
    let Hmin = Hcalc(Tmin);
    let Hmax = Hcalc(Tmax);
    
    // Check if solution is bracketed
    let bracketed = (H_target_Jps - Hmin) * (H_target_Jps - Hmax) <= 0;
    
    if (!bracketed) {
      // Not bracketed - try wider range
      if (H_target_Jps < Hmin) {
        Tmin = 100;
        Hmin = Hcalc(Tmin);
      }
      if (H_target_Jps > Hmax) {
        Tmax = 3000;
        Hmax = Hcalc(Tmax);
      }
      
      // CRITICAL: Re-check bracketing after widening
      bracketed = (H_target_Jps - Hmin) * (H_target_Jps - Hmax) <= 0;
      
      if (!bracketed) {
        // STILL not bracketed - target is outside achievable range
        // Choose endpoint closest to target as best effort
        const distMin = Math.abs(Hmin - H_target_Jps);
        const distMax = Math.abs(Hmax - H_target_Jps);
        
        T_solution = (distMin < distMax) ? Tmin : Tmax;
        const H_final = (distMin < distMax) ? Hmin : Hmax;
        const residual = H_final - H_target_Jps;
        
        console.warn(`PH flash: Target H=${(H_target_Jps/1000).toFixed(1)} kW outside achievable range [${(Hmin/1000).toFixed(1)}, ${(Hmax/1000).toFixed(1)}] kW. Using T=${T_solution.toFixed(1)}K (residual=${(residual/1000).toFixed(1)} kW)`);
        
        // Final flash at best-effort temperature
        const finalStream = {
          type: StreamType.MATERIAL,
          T: T_solution,
          P: P_Pa,
          n: { ...n },
          phaseConstraint
        };
        
        const flashResult = this.tpFlash(finalStream);
        
        return {
          phase: flashResult.phase,
          beta: flashResult.beta,
          vaporFraction: flashResult.vaporFraction || flashResult.beta,
          x: flashResult.x,
          y: flashResult.y,
          nL: flashResult.nL,
          nV: flashResult.nV,
          T_K: T_solution,
          iterations: 0,
          converged: false,
          bracketed: false,
          residual_Jps: residual,
          Tmin_K: Tmin,
          Tmax_K: Tmax,
          warning: `Target enthalpy outside achievable range. Residual: ${(residual/1000).toFixed(1)} kW`
        };
      }
    }
    
    // Bracketed solver loop
    let residual = Infinity;
    
    for (let iter = 0; iter < MAX_ITER; iter++) {
      iterations = iter + 1;
      
      // Guard against near-zero denominator
      const denominator = Hmax - Hmin;
      
      let T_new;
      if (Math.abs(denominator) < ZERO_DENOMINATOR_THRESHOLD) {
        // Hmax â‰ˆ Hmin - use bisection instead of regula falsi
        T_new = (Tmin + Tmax) / 2;
      } else {
        // Regula falsi step
        T_new = Tmin - (Hmin - H_target_Jps) * (Tmax - Tmin) / denominator;
      }
      
      // Ensure T_new is within bounds
      const T_clamped = Math.max(Tmin + 0.01, Math.min(Tmax - 0.01, T_new));
      
      const H_new = Hcalc(T_clamped);
      const error = H_new - H_target_Jps;
      residual = error;
      
      // CRITICAL: Convergence based on residual, not iterations
      if (Math.abs(error) < TOL) {
        T_solution = T_clamped;
        break;
      }
      
      // Update bracket
      if (error * (Hmin - H_target_Jps) > 0) {
        Tmin = T_clamped;
        Hmin = H_new;
      } else {
        Tmax = T_clamped;
        Hmax = H_new;
      }
      
      // Bisection fallback if bracket gets too narrow
      if (Tmax - Tmin < 0.01) {
        T_solution = (Tmin + Tmax) / 2;
        // Recompute residual at chosen T
        const H_final = Hcalc(T_solution);
        residual = H_final - H_target_Jps;
        break;
      }
    }
    
    // If no solution found, use midpoint
    if (!T_solution) {
      T_solution = (Tmin + Tmax) / 2;
      const H_final = Hcalc(T_solution);
      residual = H_final - H_target_Jps;
      console.warn(`PH flash did not converge after ${MAX_ITER} iterations. Using T=${T_solution.toFixed(2)}K (residual=${(residual/1000).toFixed(3)} kW)`);
    }
    
    // Final flash at solution temperature
    const finalStream = {
      type: StreamType.MATERIAL,
      T: T_solution,
      P: P_Pa,
      n: { ...n },
      phaseConstraint
    };
    
    const flashResult = this.tpFlash(finalStream);
    
    // CRITICAL: Convergence based on residual, not iterations
    const converged = Math.abs(residual) < TOL;
    
    return {
      phase: flashResult.phase,
      beta: flashResult.beta,
      vaporFraction: flashResult.vaporFraction || flashResult.beta,
      x: flashResult.x,
      y: flashResult.y,
      nL: flashResult.nL,
      nV: flashResult.nV,
      T_K: T_solution,
      iterations,
      converged,
      bracketed: true,  // If we got here, it was bracketed
      residual_Jps: residual,
      Tmin_K: Tmin,
      Tmax_K: Tmax,
      warning: converged ? undefined : `PH flash residual ${(residual/1000).toFixed(3)} kW exceeds tolerance ${(TOL/1000).toFixed(3)} kW`
    };
  }
  
  /**
   * Find saturation temperature at given pressure by inverting Antoine equation
   * Uses bisection on Psat(T) = P_target
   * 
   * CRITICAL: Must handle cryogenic fluids where Tc << 200K
   * Returns null if no valid Tsat can be found (supercritical, no Antoine data, etc.)
   * 
   * @private
   * @param {string} comp - Component formula
   * @param {number} P_Pa - Target pressure in Pa
   * @returns {number|null} Saturation temperature in K, or null
   */
  _findSaturationTemperature(comp, P_Pa) {
    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.antoine) {
      return null;
    }
    
    // Supercritical check: if P > Pc, no saturation temperature exists
    if (compData.Pc && P_Pa > compData.Pc) {
      return null;
    }
    
    // Use bracketed search to invert Psat(T) = P
    const targetPsat = P_Pa;
    
    // Adaptive lower bound: use triple point (Tm), or fraction of Tb, or absolute minimum
    // Must be well below Tc for the bracket to contain Tsat
    let Tmin = Math.max(10, compData.Tm || (compData.Tb ? compData.Tb * 0.4 : 10));
    let Tmax = compData.Tc || 1000;  // K - critical temperature is the upper limit for VLE
    
    // Guard: if bracket is inverted or degenerate, cannot solve
    if (Tmin >= Tmax) {
      console.warn(`_findSaturationTemperature: Tmin (${Tmin.toFixed(1)}K) >= Tmax (${Tmax.toFixed(1)}K) for ${comp}`);
      return null;
    }
    
    const MAX_ITER = 50;
    const TOL = 1;  // Pa
    
    for (let iter = 0; iter < MAX_ITER; iter++) {
      const Tmid = (Tmin + Tmax) / 2;
      const Psat = this.saturationPressure(comp, Tmid);
      
      if (!Psat) return null;
      
      const error = Psat - targetPsat;
      
      if (Math.abs(error) < TOL) {
        return Tmid;
      }
      
      if (error > 0) {
        // Psat too high, decrease T
        Tmax = Tmid;
      } else {
        // Psat too low, increase T
        Tmin = Tmid;
      }
      
      if (Tmax - Tmin < 0.01) {
        return (Tmin + Tmax) / 2;
      }
    }
    
    return (Tmin + Tmax) / 2;
  }
  
  /**
   * Solve for temperature given target molar enthalpy in single phase
   * Uses bisection search on h(T) = h_target
   * 
   * Returns a result object with convergence metadata (matches _phFlash_General contract)
   * 
   * @private
   * @param {string} comp - Component formula
   * @param {number} P_Pa - Pressure in Pa
   * @param {number} h_target - Target molar enthalpy in J/mol
   * @param {string} phase - 'V' or 'L'
   * @param {number} Tmin - Lower temperature bound (K)
   * @param {number} Tmax - Upper temperature bound (K)
   * @returns {{T_K: number, converged: boolean, residual: number, iterations: number, bracketed: boolean, warning?: string}}
   */
  _solveTemperatureForEnthalpy(comp, P_Pa, h_target, phase, Tmin, Tmax) {
    const MAX_ITER = 50;
    const TOL = 1;  // J/mol
    
    // Guard: inverted bracket
    if (Tmin >= Tmax) {
      console.warn(`_solveTemperatureForEnthalpy: Tmin (${Tmin.toFixed(1)}K) >= Tmax (${Tmax.toFixed(1)}K) for ${comp}`);
      return { T_K: (Tmin + Tmax) / 2, converged: false, residual: NaN, iterations: 0, bracketed: false,
               warning: `Invalid temperature bracket [${Tmin.toFixed(1)}, ${Tmax.toFixed(1)}] K` };
    }
    
    // Check bracketing: is h_target between h(Tmin) and h(Tmax)?
    const h_lo = this.hMolar(comp, Tmin, P_Pa, phase);
    const h_hi = this.hMolar(comp, Tmax, P_Pa, phase);
    const bracketed = (h_target - h_lo) * (h_target - h_hi) <= 0;
    
    if (!bracketed) {
      // Target is outside achievable range â€” return closest endpoint
      const dist_lo = Math.abs(h_lo - h_target);
      const dist_hi = Math.abs(h_hi - h_target);
      const T_best = (dist_lo < dist_hi) ? Tmin : Tmax;
      const h_best = (dist_lo < dist_hi) ? h_lo : h_hi;
      const residual = h_best - h_target;
      
      return { T_K: T_best, converged: false, residual, iterations: 0, bracketed: false,
               warning: `Target molar enthalpy ${h_target.toFixed(1)} J/mol outside achievable range [${h_lo.toFixed(1)}, ${h_hi.toFixed(1)}] J/mol` };
    }
    
    // Bisection loop
    let residual = Infinity;
    let iterations = 0;
    
    for (let iter = 0; iter < MAX_ITER; iter++) {
      iterations = iter + 1;
      const Tmid = (Tmin + Tmax) / 2;
      const h_mid = this.hMolar(comp, Tmid, P_Pa, phase);
      
      residual = h_mid - h_target;
      
      if (Math.abs(residual) < TOL) {
        return { T_K: Tmid, converged: true, residual, iterations, bracketed: true };
      }
      
      // Enthalpy increases with T
      if (residual > 0) {
        // h too high, decrease T
        Tmax = Tmid;
      } else {
        // h too low, increase T
        Tmin = Tmid;
      }
      
      if (Tmax - Tmin < 0.01) {
        const T_final = (Tmin + Tmax) / 2;
        residual = this.hMolar(comp, T_final, P_Pa, phase) - h_target;
        return { T_K: T_final, converged: Math.abs(residual) < TOL, residual, iterations, bracketed: true };
      }
    }
    
    const T_final = (Tmin + Tmax) / 2;
    residual = this.hMolar(comp, T_final, P_Pa, phase) - h_target;
    return { T_K: T_final, converged: Math.abs(residual) < TOL, residual, iterations, bracketed: true,
             warning: `Bisection did not converge after ${MAX_ITER} iterations. Residual: ${residual.toFixed(3)} J/mol` };
  }
  
  
  /** Saturation pressure [Pa] â€” delegated to active thermo package */
  saturationPressure(comp, T_K) {
    return this._pkg.saturationPressure(comp, T_K);
  }
  
  /**
   * Authoritative saturation temperature calculation (inverse Antoine)
   * 
   * Given pressure, find temperature where Psat(T) = P
   * Uses same range selection logic as saturationPressure
   * 
   * @param {string} comp - Component formula
   * @param {number} P_Pa - Pressure in Pa
   * @returns {number} Saturation temperature in K, or null if no Antoine data
   */
  saturationTemperature(comp, P_Pa) {
    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.antoine) {
      console.warn(`No Antoine coefficients for ${comp}`);
      return null;
    }
    
    const P_mmHg = P_Pa / 133.322;  // Pa to mmHg
    const log10_P = Math.log10(P_mmHg);
    
    let antoineData = compData.antoine;
    
    // For multiple ranges, need to determine which range applies
    // Simple heuristic: try each range and pick the first valid one
    if (Array.isArray(antoineData)) {
      let T_sat = null;
      for (const range of antoineData) {
        // Inverse Antoine: T[Â°C] = B/(A - log10(P)) - C
        const T_C = range.B / (range.A - log10_P) - range.C;
        const T_K = T_C + 273.15;
        
        // Check if this T is within the range
        if (T_K >= range.Tmin && T_K <= range.Tmax) {
          T_sat = T_K;
          break;
        }
      }
      
      // If no range matched, use first range and warn
      if (T_sat === null) {
        const range = antoineData[0];
        const T_C = range.B / (range.A - log10_P) - range.C;
        T_sat = T_C + 273.15;
        
        const warnKey = `${comp}-tsat-outofrange`;
        if (!this._warnedRanges.has(warnKey)) {
          console.warn(`Tsat calculation for ${comp} at P=${(P_Pa/1e5).toFixed(2)} bar outside all Antoine ranges`);
          this._warnedRanges.add(warnKey);
        }
      }
      return T_sat;
    } else {
      // Single range: compute directly
      const T_C = antoineData.B / (antoineData.A - log10_P) - antoineData.C;
      return T_C + 273.15;
    }
  }
  
  /**
   * Check if a two-phase split is actually defined
   * A split is considered defined if nV and nL exist and sum to nTot within tolerance
   * @param {Object} stream - Stream with n, nV, nL
   * @returns {boolean} True if split is valid and defined
   */
  _isVLSplitDefined(stream) {
    if (!stream.nV || !stream.nL) return false;
    
    const nTot = Object.values(stream.n || {}).reduce((sum, n) => sum + n, 0);
    const nV_tot = Object.values(stream.nV).reduce((sum, n) => sum + n, 0);
    const nL_tot = Object.values(stream.nL).reduce((sum, n) => sum + n, 0);
    
    const TOLERANCE = 1e-6;  // mol/s
    const diff = Math.abs((nV_tot + nL_tot) - nTot);
    
    return diff < TOLERANCE && nTot > 1e-12;
  }
  
  /**
   * Stream heat capacity (mixture)
   * Accounts for phase of each component
   * 
   * INTERNAL UNITS: Returns J/s/K (not kW/K)
   * For UI display, use: formatPower_kW(Cp_J_s_K * deltaT) / deltaT
   * 
   * @param {Object} stream - {T: K, P: Pa, n: {comp: mol/s}, phase: 'V'|'L'|'VL'}
   * @returns {number} Total heat capacity in J/s/K
   */
  streamCp(stream) {
    let Cp_total_J_s_K = 0;
    
    // For single-phase streams
    if (stream.phase === 'V' || stream.phase === 'L') {
      for (const [comp, n_mols] of Object.entries(stream.n)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, stream.phase);
        Cp_total_J_s_K += n_mols * Cp_J_molK;  // mol/s * J/(molÂ·K) = J/s/K
      }
      return Cp_total_J_s_K;
    }
    
    // For two-phase streams (VL) - only if split is defined
    if (stream.phase === 'VL' && this._isVLSplitDefined(stream)) {
      // Vapor contribution
      for (const [comp, n_mols] of Object.entries(stream.nV)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, 'V');
        Cp_total_J_s_K += n_mols * Cp_J_molK;
      }
      // Liquid contribution
      for (const [comp, n_mols] of Object.entries(stream.nL)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, 'L');
        Cp_total_J_s_K += n_mols * Cp_J_molK;
      }
      return Cp_total_J_s_K;
    }
    
    // Fallback for VL with undefined split
    if (stream.phase === 'VL') {
      console.warn('VL phase with undefined quality - using liquid phase for Cp (PH flash required)');
      
      // CRITICAL: Use normalizeSinglePhaseHint to prevent passing 'VL' to cpMolar
      // stream.phaseConstraint might be 'VL', which is invalid for single-phase functions
      const fallbackPhase = this.normalizeSinglePhaseHint(stream.phaseConstraint, 'L');
      
      for (const [comp, n_mols] of Object.entries(stream.n)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, fallbackPhase);
        Cp_total_J_s_K += n_mols * Cp_J_molK;
      }
      return Cp_total_J_s_K;
    }
    
    // Final fallback: assume vapor if no phase info
    for (const [comp, n_mols] of Object.entries(stream.n)) {
      const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, 'V');
      Cp_total_J_s_K += n_mols * Cp_J_molK;
    }
    return Cp_total_J_s_K;
  }
  
  /**
   * Stream mass flow (mixture)
   * @param {Object} stream - {n: {comp: mol/s}}
   * @returns {number} Total mass flow in kg/s
   */
  streamMassFlow(stream) {
    let m_total_kgs = 0;
    for (const [comp, n_mols] of Object.entries(stream.n)) {
      const MW = this.getComponentProp(comp, 'MW');  // g/mol
      m_total_kgs += n_mols * MW / 1000;  // kg/s
    }
    return m_total_kgs;
  }
  
  /**
   * P0.1 FIX: Stream volumetric flow via package (not inline PV=nRT)
   * Vapor uses compressibility Z from package (IG: Z=1, PR: Z from EOS)
   * Liquid uses density from package
   * @param {Object} stream - Material stream with T, P, n, phase, nV, nL
   * @returns {number} Volumetric flow in mÂ³/s
   */
  streamVolFlow_m3ps(stream) {
    if (!stream || !stream.n) return 0;
    const R = 8.314;  // J/(molÂ·K)
    
    const calcVaporVol = (n_map, T, P) => {
      const nV = Object.values(n_map).reduce((a, b) => a + b, 0);
      if (nV < 1e-15) return 0;
      // Z factor from package (ideal gas: Z=1)
      const Z = this._pkg.compressibilityZ 
        ? this._pkg.compressibilityZ(n_map, T, P) 
        : 1.0;
      return nV * Z * R * T / P;
    };
    
    const calcLiquidVol = (n_map, T, P) => {
      let vol = 0;
      for (const [comp, n] of Object.entries(n_map)) {
        if (n < 1e-15) continue;
        const rho = this.density(comp, T, P, 'L');
        const MW = this.getComponentProp(comp, 'MW');
        vol += n * (MW / 1000) / rho;
      }
      return vol;
    };
    
    if (stream.phase === 'V') {
      return calcVaporVol(stream.n, stream.T, stream.P);
    } else if (stream.phase === 'L') {
      return calcLiquidVol(stream.n, stream.T, stream.P);
    } else if (stream.phase === 'VL' && stream.nV && stream.nL) {
      return calcVaporVol(stream.nV, stream.T, stream.P)
           + calcLiquidVol(stream.nL, stream.T, stream.P);
    }
    // Fallback: treat as vapor
    return calcVaporVol(stream.n, stream.T, stream.P);
  }
  
  /**
   * P0.3 FIX: Compressor work calculation via thermo package
   * Keeps ideal-gas isentropic relations in the package, not in the unit.
   * Future PR EOS will override with s(T,P)-based isentropic calculation.
   * 
   * @param {Object} inStream - Inlet material stream {T, P, n, phase}
   * @param {number} Pout - Outlet pressure in Pa
   * @param {number} eta - Isentropic efficiency (0-1)
   * @returns {Object} {W_isentropic_W, W_shaft_W, H_target_Jps, T_isentropic_K, gammaMix, cpMix}
   */
  computeCompressorWork(inStream, Pout, eta) {
    const R = 8.314;
    const nTotal = Object.values(inStream.n).reduce((a, b) => a + b, 0);
    
    // Mixture Cp via package
    let cpMix = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const xi = n / nTotal;
      cpMix += xi * this.cpMolar(comp, inStream.T, inStream.P, 'V');
    }
    
    // Ideal gas: gamma = Cp/(Cp-R), isentropic T-P relation
    // PR EOS would override this entire method with entropy-based calc
    const cvMix = cpMix - R;
    const gammaMix = cpMix / cvMix;
    const ratio = Pout / inStream.P;
    
    const T_isentropic_K = inStream.T * Math.pow(ratio, (gammaMix - 1) / gammaMix);
    const W_isentropic_W = nTotal * cpMix * (T_isentropic_K - inStream.T);  // W (J/s)
    const W_shaft_W = W_isentropic_W / eta;
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps + W_shaft_W;
    
    return {
      W_isentropic_W,
      W_shaft_W,
      H_in_Jps,
      H_target_Jps,
      T_isentropic_K,
      gammaMix,
      cpMix
    };
  }
  
  /**
   * Gas turbine (expander) work calculation via thermo package.
   * Inverse of compressor: gas expands from high to low pressure, extracting work.
   * 
   * Sign convention: W values returned are POSITIVE (work extracted).
   *   W_isentropic = nTotal * cpMix * (T_in âˆ’ T_isentropic)   [> 0 since T_in > T_isen]
   *   W_shaft      = W_isentropic * eta                        [efficiency reduces output]
   *   H_target     = H_in âˆ’ W_shaft                            [outlet enthalpy is lower]
   * 
   * @param {Object} inStream - Inlet material stream {T, P, n, phase}
   * @param {number} Pout - Outlet pressure in Pa (must be < inStream.P)
   * @param {number} eta - Isentropic efficiency (0-1)
   * @returns {Object} {W_isentropic_W, W_shaft_W, H_in_Jps, H_target_Jps, T_isentropic_K, gammaMix, cpMix}
   */
  computeTurbineWork(inStream, Pout, eta) {
    const R = 8.314;
    const nTotal = Object.values(inStream.n).reduce((a, b) => a + b, 0);
    
    // Mixture Cp via package (vapor phase)
    let cpMix = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const xi = n / nTotal;
      cpMix += xi * this.cpMolar(comp, inStream.T, inStream.P, 'V');
    }
    
    const cvMix = cpMix - R;
    const gammaMix = cpMix / cvMix;
    const ratio = Pout / inStream.P;  // < 1 for expansion
    
    // Isentropic expansion: T drops
    const T_isentropic_K = inStream.T * Math.pow(ratio, (gammaMix - 1) / gammaMix);
    
    // Work extracted (positive convention)
    const W_isentropic_W = nTotal * cpMix * (inStream.T - T_isentropic_K);
    const W_shaft_W = W_isentropic_W * eta;  // Efficiency reduces extracted work
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps - W_shaft_W;  // Outlet enthalpy is lower
    
    return {
      W_isentropic_W,
      W_shaft_W,
      H_in_Jps,
      H_target_Jps,
      T_isentropic_K,
      gammaMix,
      cpMix
    };
  }
  
  /**
   * Pump work calculation via thermo package
   * Incompressible liquid: W = VÂ·Î”P / Î·
   * @param {Object} inStream - Inlet material stream
   * @param {number} Pout - Outlet pressure in Pa
   * @param {number} eta - Efficiency (0-1)
   * @returns {Object} {W_hydraulic_W, W_shaft_W, H_target_Jps, V_m3ps}
   */
  computePumpWork(inStream, Pout, eta) {
    let V_m3ps = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const rho = this.density(comp, inStream.T, inStream.P, 'L');
      const MW = this.getComponentProp(comp, 'MW');
      V_m3ps += n * (MW / 1000) / rho;
    }
    
    const deltaP = Pout - inStream.P;
    const W_hydraulic_W = V_m3ps * deltaP;  // W (J/s) = mÂ³/s Ã— Pa
    const W_shaft_W = W_hydraulic_W / eta;
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps + W_shaft_W;
    
    return {
      W_hydraulic_W,
      W_shaft_W,
      H_in_Jps,
      H_target_Jps,
      V_m3ps
    };
  }
  /**
   * Reverse compressor: given available shaft work, compute achievable outlet pressure.
   * Uses same ideal-gas isentropic relations as forward calculation.
   * @param {Object} inStream - Inlet material stream {T, P, n, phase}
   * @param {number} W_shaft_avail_W - Available shaft work in W
   * @param {number} eta - Isentropic efficiency (0-1)
   * @returns {Object} {P_actual, H_target_Jps, W_isentropic_W, W_shaft_W, gammaMix, cpMix}
   */
  computeCompressorFromWork(inStream, W_shaft_avail_W, eta) {
    const R = 8.314;
    const nTotal = Object.values(inStream.n).reduce((a, b) => a + b, 0);
    
    let cpMix = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const xi = n / nTotal;
      cpMix += xi * this.cpMolar(comp, inStream.T, inStream.P, 'V');
    }
    
    const cvMix = cpMix - R;
    const gammaMix = cpMix / cvMix;
    
    const W_isen_W = W_shaft_avail_W * eta;
    // T_isen = T_in + W_isen / (nTotal * cpMix)
    const T_isen = inStream.T + W_isen_W / (nTotal * cpMix);
    
    // P_actual = P_in * (T_isen / T_in)^(Î³/(Î³-1))
    let P_actual;
    if (T_isen <= inStream.T) {
      P_actual = inStream.P;  // No compression possible
    } else {
      P_actual = inStream.P * Math.pow(T_isen / inStream.T, gammaMix / (gammaMix - 1));
    }
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps + W_shaft_avail_W;
    
    return {
      P_actual,
      W_isentropic_W: W_isen_W,
      W_shaft_W: W_shaft_avail_W,
      H_in_Jps,
      H_target_Jps,
      T_isentropic_K: T_isen,
      gammaMix,
      cpMix
    };
  }
  
  /**
   * Reverse pump: given available shaft work, compute achievable outlet pressure.
   * @param {Object} inStream - Inlet material stream
   * @param {number} W_shaft_avail_W - Available shaft work in W
   * @param {number} eta - Efficiency (0-1)
   * @returns {Object} {P_actual, H_target_Jps, W_hydraulic_W, W_shaft_W, V_m3ps}
   */
  computePumpFromWork(inStream, W_shaft_avail_W, eta) {
    let V_m3ps = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const rho = this.density(comp, inStream.T, inStream.P, 'L');
      const MW = this.getComponentProp(comp, 'MW');
      V_m3ps += n * (MW / 1000) / rho;
    }
    
    const W_hydraulic_W = W_shaft_avail_W * eta;
    const deltaP = V_m3ps > 0 ? W_hydraulic_W / V_m3ps : 0;
    const P_actual = inStream.P + deltaP;
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps + W_shaft_avail_W;
    
    return {
      P_actual,
      W_hydraulic_W,
      W_shaft_W: W_shaft_avail_W,
      H_in_Jps,
      H_target_Jps,
      V_m3ps
    };
  }
}

// Global thermo adapter instance
const idealRaoultPkg = new IdealRaoultPackage();
const pengRobinsonPkg = new PengRobinsonPackage();
const thermo = new ThermoAdapter(idealRaoultPkg);

// [v4.9.0] Thermo warning suppression.
// Thermo routines emit console.warn for extrapolation, range limits, and flash
// iteration diagnostics. These are expected developer diagnostics, not user errors,
// and fire hundreds of times per solve cycle (every stream Ã— every iteration).
// This wrapper silently collects unique messages and provides:
//   - window.thermoWarnings()  â†’ array of all unique warnings seen this session
//   - A single summary count in the console on first solve
(function installWarnCollector() {
  const _origWarn = console.warn;
  const _seen = new Set();
  let _summarized = false;
  console.warn = function(...args) {
    const msg = args.map(a => String(a)).join(' ');
    // Only intercept thermo-style warnings (range, extrapolation, flash, phase)
    if (msg.startsWith('Warning:') || msg.includes('extrapolation') ||
        msg.includes('flash') || msg.includes('phase') || msg.includes('Cp') ||
        msg.includes('Antoine') || msg.includes('enthalpy') || msg.includes('hMolar')) {
      _seen.add(msg);
      return;  // suppress
    }
    _origWarn.apply(console, args);
  };
  window.thermoWarnings = () => [..._seen];
  // After first solve, emit a one-line count (if any warnings accumulated)
  setTimeout(() => {
    if (_seen.size > 0 && !_summarized) {
      _summarized = true;
      _origWarn(`[thermo] ${_seen.size} range/extrapolation warnings suppressed. Run thermoWarnings() to inspect.`);
    }
  }, 1000);
})();

// =============================================================================
// UI FORMATTING HELPERS
// =============================================================================
// These functions convert internal units (J/s, J/mol, J/s/K) to display units (kW, kJ/mol, kW/K)
// CRITICAL: Internal calculations must NEVER use these - they are for display ONLY

/**
 * Format power (enthalpy flow rate) for UI display
 * @param {number} Hdot_J_s - Power in J/s (internal unit)
 * @param {number} decimals - Number of decimal places (default: 2)
 * @returns {string} Formatted string "X.XX kW"
 */
function formatPower_kW(Hdot_J_s, decimals = 2) {
  if (Hdot_J_s === undefined || Hdot_J_s === null || isNaN(Hdot_J_s)) {
    return 'N/A';
  }
  return (Hdot_J_s / 1000).toFixed(decimals);
}

/**
 * Format molar enthalpy for UI display
 * @param {number} h_J_mol - Molar enthalpy in J/mol (internal unit)
 * @param {number} decimals - Number of decimal places (default: 2)
 * @returns {string} Formatted string "X.XX kJ/mol"
 */
function formatEnthalpy_kJmol(h_J_mol, decimals = 2) {
  if (h_J_mol === undefined || h_J_mol === null || isNaN(h_J_mol)) {
    return 'N/A';
  }
  return (h_J_mol / 1000).toFixed(decimals);
}

/**
 * Format heat capacity for UI display
 * @param {number} Cp_J_s_K - Heat capacity in J/s/K (internal unit)
 * @param {number} decimals - Number of decimal places (default: 2)
 * @returns {string} Formatted string "X.XX kW/K"
 */
function formatHeatCapacity_kWK(Cp_J_s_K, decimals = 2) {
  if (Cp_J_s_K === undefined || Cp_J_s_K === null || isNaN(Cp_J_s_K)) {
    return 'N/A';
  }
  return (Cp_J_s_K / 1000).toFixed(decimals);
}


/* =========================
   MODEL IMPLEMENTATIONS
   ========================= */

// PVT Models (Pressure-Volume-Temperature)
// =============================================================================
// LEGACY MODELS REMOVED (v1.5.0 - Architecture Cleanup)
// =============================================================================
// The following models have been REMOVED to enforce single-entrypoint architecture:
//
// 1. pvt_gas (ideal): Mixed units (T+273.15 violation), bypassed ComponentRegistry
// 2. thermo (constant_cp): Hardcoded Cp values, bypassed ComponentRegistry
// 3. water_psat (antoine): Water-specific, Â°C units, bypassed ThermoAdapter
// 4. humidity (simple): Water-specific, called water_psat directly
// 5. pvt_liquid (incompressible): Hardcoded densities, bypassed ComponentRegistry
// 6. vle (raoult): Direct antoine.A/B/C access (BREAKS multi-range!), bypassed ThermoAdapter
// 7. flash (successive_substitution): Complex dependencies, ThermoAdapter has better impl
//
// ALL thermodynamic calculations MUST go through ThermoAdapter.
// =============================================================================

// Heat Exchanger
models.register('hx', {
  id: 'cop_cooling',
  name: 'COP cooling',
  desc: 'COP = Q_cooling / W_electric',
  coolingPower(QkW_electric, COP) { 
    return QkW_electric * COP; 
  }
});

// Pressure Drop
models.register('pressure_drop', {
  id: 'none',
  name: 'No Î”P',
  desc: 'P_out = P_in',
  deltaPFraction() { return 0; }
});


// Thermo Packages
models.register('thermo_package', idealRaoultPkg);
models.register('thermo_package', pengRobinsonPkg);

// Unit Systems
// Unit Systems - SI (bar) is default
models.register('units', {
  id: 'SI_bar',
  name: 'SI (bar)',
  desc: 'Temperature (Â°C), Pressure (bar), Flow (mol/h, kg/h, mÂ³/h)',
  
  temperature: { from: (K) => K - 273.15, to: (C) => C + 273.15, symbol: 'Â°C', decimals: 1 },
  pressure: { from: (Pa) => Pa / 100000, to: (bar) => bar * 100000, symbol: 'bar', decimals: 3 },
  molarFlow: { from: (mols) => mols * 3600, to: (molh) => molh / 3600, symbol: 'mol/h', decimals: 1 },
  massFlow: { from: (kgs) => kgs * 3600, to: (kgh) => kgh / 3600, symbol: 'kg/h', decimals: 2 },
  volumeFlow: { from: (m3s) => m3s * 3600, to: (m3h) => m3h / 3600, symbol: 'mÂ³/h', decimals: 2 }
});

models.register('units', {
  id: 'SI',
  name: 'SI Units',
  desc: 'Temperature (K), Pressure (Pa), Flow (mol/s, kg/s, mÂ³/s)',
  
  temperature: { from: (K) => K, to: (K) => K, symbol: 'K', decimals: 2 },
  pressure: { from: (Pa) => Pa, to: (Pa) => Pa, symbol: 'Pa', decimals: 0 },
  molarFlow: { from: (mols) => mols, to: (mols) => mols, symbol: 'mol/s', decimals: 3 },
  massFlow: { from: (kgs) => kgs, to: (kgs) => kgs, symbol: 'kg/s', decimals: 4 },
  volumeFlow: { from: (m3s) => m3s, to: (m3s) => m3s, symbol: 'mÂ³/s', decimals: 4 }
});

models.register('units', {
  id: 'Imperial',
  name: 'Imperial Units',
  desc: 'Temperature (Â°F), Pressure (psi), Flow (lbmol/h, lb/h, ftÂ³/h)',
  
  temperature: { 
    from: (K) => (K - 273.15) * 9/5 + 32, 
    to: (F) => (F - 32) * 5/9 + 273.15, 
    symbol: 'Â°F', 
    decimals: 1 
  },
  pressure: { 
    from: (Pa) => Pa / 6894.76, 
    to: (psi) => psi * 6894.76, 
    symbol: 'psi', 
    decimals: 2 
  },
  molarFlow: { 
    from: (mols) => mols * 3600 / 453.592, 
    to: (lbmolh) => lbmolh * 453.592 / 3600, 
    symbol: 'lbmol/h', 
    decimals: 1 
  },
  massFlow: { 
    from: (kgs) => kgs * 3600 * 2.20462, 
    to: (lbh) => lbh / 2.20462 / 3600, 
    symbol: 'lb/h', 
    decimals: 1 
  },
  volumeFlow: { 
    from: (m3s) => m3s * 3600 * 35.3147, 
    to: (ft3h) => ft3h / 35.3147 / 3600, 
    symbol: 'ftÂ³/h', 
    decimals: 1 
  }
});

/* =========================
   ERROR SEVERITY SYSTEM
   Categorizes operational errors by damage level
   ========================= */
const ErrorSeverity = {
  MINOR: { 
    icon: 'âš ï¸', 
    color: '#fbbf24', 
    prefix: 'WARNING',
    level: 1
  },
  MAJOR: { 
    icon: 'ðŸ”§', 
    color: '#f97316', 
    prefix: 'MAJOR DAMAGE',
    level: 2
  },
  CATASTROPHIC: { 
    icon: 'ðŸ’¥', 
    color: '#ef4444', 
    prefix: 'CATASTROPHIC',
    level: 3
  }
};

/* =========================
   ERROR CATALOG & DIAGNOSIS
   Natural language explanations for common failures
   ========================= */
const ErrorCatalog = {
  // Catastrophic failures
  'compressor.*liquid': {
    severity: ErrorSeverity.CATASTROPHIC,
    title: 'Compressor Destroyed',
    explanation: 'Compressors are designed to handle gases, not liquids. When liquid enters a compressor, it cannot be compressed and causes immediate mechanical failure. Think of it like trying to compress water in a sealed cylinder - the incompressible liquid will destroy the compression mechanism.',
    causes: [
      'Upstream condenser or cooler dropped temperature below dew point',
      'Feed stream is liquid or two-phase with high liquid fraction',
      'Insufficient separation before compression',
      'Temperature control failure upstream'
    ],
    fixes: [
      'Add a knockout drum or separator before the compressor',
      'Ensure feed temperature is above dew point',
      'Check flash calculation results - inlet should show vapor phase',
      'Add heating if stream is too cold'
    ]
  },
  
  // Major damage
  'pump.*cavitation.*vapor': {
    severity: ErrorSeverity.MAJOR,
    title: 'Pump Cavitation',
    explanation: 'Pumps are designed for liquids and cannot handle vapor. When vapor enters a pump, cavitation occurs - the formation and collapse of vapor bubbles that physically damage the pump impeller. This causes vibration, noise, reduced efficiency, and mechanical wear.',
    causes: [
      'Feed stream is vapor or two-phase with high vapor fraction',
      'Upstream heater raised temperature above bubble point',
      'Pressure drop upstream caused flashing',
      'Insufficient NPSH (Net Positive Suction Head)'
    ],
    fixes: [
      'Ensure feed is subcooled liquid',
      'Add cooling if stream is too hot',
      'Check flash results - inlet should show liquid phase',
      'Increase system pressure or decrease temperature'
    ]
  },
  
  // Configuration warnings
  'power.*overload': {
    severity: ErrorSeverity.MINOR,
    title: 'Power Source Overload',
    explanation: 'The electrical or mechanical power demand exceeds the available capacity from the power source. The connected equipment cannot operate properly without sufficient power supply.',
    causes: [
      'Power source capacity too small for connected load',
      'Too many units connected to single power source',
      'Compression ratio or pressure rise too high',
      'Motor efficiency losses not accounted for'
    ],
    fixes: [
      'Increase power source max capacity',
      'Add additional power sources',
      'Reduce compression ratio or pressure rise',
      'Check motor efficiency parameter'
    ]
  },
  
  'no.*input': {
    severity: ErrorSeverity.MINOR,
    title: 'Missing Input Connection',
    explanation: 'This unit requires an input stream but none is connected. Process equipment needs material or power feeds to operate.',
    causes: [
      'Unit was just added and not yet connected',
      'Connection was deleted',
      'Upstream unit missing or disconnected'
    ],
    fixes: [
      'Connect an appropriate input stream',
      'Add upstream source or equipment',
      'Check unit ports match stream types (material, power, etc.)'
    ]
  },
  
  'no.*output': {
    severity: ErrorSeverity.MINOR,
    title: 'No Output Connection',
    explanation: 'This unit has no outlet stream. While not necessarily an error, process streams typically need destinations.',
    causes: [
      'Unit was just added and not yet connected',
      'Downstream equipment missing',
      'This is an endpoint (sink) and this is normal'
    ],
    fixes: [
      'Add downstream equipment or sink',
      'Connect outlet to next process step',
      'If this is intentional, no action needed'
    ]
  },
  
  'temperature.*cross': {
    severity: ErrorSeverity.MAJOR,
    title: 'Heat Exchanger Temperature Cross',
    explanation: 'In a heat exchanger, the hot stream cannot exit colder than the cold stream inlet (and vice versa). This violates the second law of thermodynamics and indicates impossible heat transfer.',
    causes: [
      'Specified outlet temperatures are thermodynamically infeasible',
      'Approach temperature is too small or negative',
      'Heat capacity imbalance too extreme',
      'Stream flow rates or properties changed'
    ],
    fixes: [
      'Increase approach temperature (typically 5-20K)',
      'Adjust hot or cold outlet temperature targets',
      'Check stream flow rates and heat capacities',
      'Use effectiveness mode instead of fixed outlet temps'
    ]
  },
  
  'thermodynamic.*violation.*heat': {
    severity: ErrorSeverity.CATASTROPHIC,
    title: 'Thermodynamic Violation in Heat Transfer',
    explanation: 'Heat is flowing in the wrong direction! The hot stream is gaining heat or the cold stream is losing heat. This violates the second law of thermodynamics and is physically impossible.',
    causes: [
      'Outlet temperature set higher than inlet for hot stream',
      'Outlet temperature set lower than inlet for cold stream',
      'Severe numerical error in calculation',
      'Wrong stream assignment (hot/cold swapped)'
    ],
    fixes: [
      'Check that hot inlet > hot outlet',
      'Check that cold outlet > cold inlet',
      'Verify stream connections are correct',
      'Use approach temperature mode for automatic calculation'
    ]
  },

  'power.*cycle.*infinite': {
    severity: ErrorSeverity.CATASTROPHIC,
    title: 'Power Cycle â€” Infinite Energy',
    explanation: 'A closed loop exists in the power connections (e.g. Hub â†’ Motor â†’ Generator â†’ Hub). This creates energy from nothing and violates the first law of thermodynamics. The solver cannot converge because each iteration amplifies the circulating power.',
    causes: [
      'Generator output fed back to the same hub or source that powers its drive',
      'Motor/generator chain forms a closed ring',
      'Connections were imported from a file with a circular power path'
    ],
    fixes: [
      'Break the cycle by disconnecting one power link',
      'Send the generator output to a different hub or sink',
      'Add a load (sink_electrical) to consume the generated power instead of recycling it'
    ]
  },

  'hub.*to.*hub.*not supported': {
    severity: ErrorSeverity.MAJOR,
    title: 'Hub-to-Hub Connection',
    explanation: 'Connecting one Power Hub directly to another is not supported. The hub balancing algorithm (Step C) cannot propagate demand or curtailment across hub boundaries: the upstream hub sees zero demand from the downstream hub, and the downstream hub ignores upstream curtailment. This produces silently wrong power balances.',
    causes: [
      'Two hubs connected directly via elec_out â†’ elec_in',
      'Imported file contained a hub-to-hub connection'
    ],
    fixes: [
      'Remove the direct hub-to-hub connection',
      'Place a motor between the hubs if you need to relay power',
      'Use a single hub with all sources and consumers connected directly'
    ]
  }
};

// Diagnose errors from scene state
function diagnoseErrors(scene) {
  const diagnostics = [];
  
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const ud = scene.runtime.unitData.get(id);
    
    // Check for unit-level errors
    if (ud?.last?.error) {
      const errorMsg = ud.last.error.message.toLowerCase();
      
      // Match against catalog
      for (const [pattern, info] of Object.entries(ErrorCatalog)) {
        const regex = new RegExp(pattern, 'i');
        if (regex.test(errorMsg)) {
          diagnostics.push({
            unitId: id,
            unitName: u.name || def.name,
            ...info,
            originalMessage: ud.last.error.message
          });
          break;
        }
      }
    }
    
    // Check for missing connections
    if (def.ports && def.ports.length > 0) {
      // Check inputs
      const inputPorts = def.ports.filter(p => p.dir === PortDir.IN);
      const outputPorts = def.ports.filter(p => p.dir === PortDir.OUT);
      
      for (const port of inputPorts) {
        const hasConnection = scene.connections.some(
          c => c.to.unitId === id && c.to.portId === port.portId
        );
        if (!hasConnection && def.defId !== 'source' && def.defId !== 'battery' && def.defId !== 'source_mechanical') {
          diagnostics.push({
            unitId: id,
            unitName: u.name || def.name,
            ...ErrorCatalog['no.*input'],
            originalMessage: `No input connected to ${port.portId}`
          });
        }
      }
      
      // Check outputs (warning only, not critical)
      for (const port of outputPorts) {
        const hasConnection = scene.connections.some(
          c => c.from.unitId === id && c.from.portId === port.portId
        );
        if (!hasConnection && def.defId !== 'sink') {
          // This is less critical, only add if there are no other errors for this unit
          const hasOtherError = diagnostics.some(d => d.unitId === id);
          if (!hasOtherError) {
            diagnostics.push({
              unitId: id,
              unitName: u.name || def.name,
              ...ErrorCatalog['no.*output'],
              originalMessage: `No output connected from ${port.portId}`
            });
          }
        }
      }
    }
  }
  
  return diagnostics;
}

/* =========================
   UNIT CATEGORIES
   Categories for organizing units with color coding
   ========================= */
const UnitCategories = {
  // Material sources
  SOURCE: { name: 'Sources', color: '#10b981' },      // Green
  
  // Material sinks  
  SINK: { name: 'Sinks', color: '#6366f1' },          // Indigo
  
  // Power sources
  POWER_SOURCE: { name: 'Power Sources', color: '#eab308' },  // Yellow
  
  // Power conversion
  POWER_CONVERSION: { name: 'Power Conversion', color: '#f59e0b' }, // Orange
  
  // Pressure change equipment
  PRESSURE: { name: 'Pressure Change', color: '#8b5cf6' }, // Purple
  
  // Heat exchangers
  HEAT_EXCHANGER: { name: 'Heat Exchangers', color: '#3b82f6' }, // Blue
  
  // Separators
  SEPARATOR: { name: 'Separators', color: '#ec4899' }, // Pink
  
  // Topology (mixers, splitters, tees)
  TOPOLOGY: { name: 'Topology', color: '#14b8a6' },    // Teal
  
  // Power management (hub, battery, power sink)
  POWER_MANAGEMENT: { name: 'Power Management', color: '#facc15' },  // Gold
  
  // Reactors
  REACTOR: { name: 'Reactors', color: '#ef4444' },    // Red
  
  // Test units
  TEST: { name: 'Test Units', color: '#64748b' }      // Slate
};

/* =========================
   UNIT REGISTRY
   Defines available unit operations
   
   STREAM TYPE SYSTEM:
   -------------------
   Each port MUST have a 'type' field that matches one of:
   - StreamType.MATERIAL  (for gas/liquid material streams)
   - StreamType.HEAT      (for heat transfer)
   - StreamType.MECHANICAL (for mechanical work)
   - StreamType.ELECTRICAL (for electrical power)
   
   Port definition format:
   { portId: 'unique_id', dir: PortDir.IN/OUT, type: StreamType.XXX, x: pos_x, y: pos_y }
   
   Stream object MUST have matching 'type' field:
   - MATERIAL: { type: StreamType.MATERIAL, phase: 'gas'/'liquid', T, P, nDot/mDot, comp }
   - HEAT: { type: StreamType.HEAT, QkW }
   - MECHANICAL: { type: StreamType.MECHANICAL, WkW }
   - ELECTRICAL: { type: StreamType.ELECTRICAL, QkW }
   
   Connections are only allowed between ports of the SAME type.
   The solver validates that streams produced match their port types.
   
   CATEGORY SYSTEM:
   ---------------
   Each unit belongs to a category from UnitCategories.
   Units in the same category share the same color.
   Category is displayed in the properties panel.
   ========================= */
class UnitRegistry {
  static _defs = new Map();

  static register(defId, spec) {
    const category = spec.category || UnitCategories.UTILITY;
    const def = {
      defId,
      name: spec.name,
      category: category.name,
      w: Math.max(2, spec.w || 2),  // Minimum 2x2 for better readability
      h: Math.max(2, spec.h || 2),
      color: category.color, // Color comes from category
      ports: spec.ports || [],
      tick: spec.tick || null,
      postFlashCheck: spec.postFlashCheck || null  // [v4.7.6] Was missing â†’ postFlashCheck never ran
    };
    this._defs.set(defId, def);
  }

  static get(id) { 
    return this._defs.get(id); 
  }

  static list() { 
    return Array.from(this._defs.values()); 
  }
  
  static listByCategory() {
    const byCategory = {};
    for (const def of this._defs.values()) {
      const cat = def.category;
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push(def);
    }
    return byCategory;
  }
}

// Source - Generic material stream source
UnitRegistry.register('source', {
  name: 'Source',
  category: UnitCategories.SOURCE,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    // Create material stream with molar composition
    const n = {};
    n[par.species] = par.nDot;
    
    // [v4.0.0] Validate absolute temperature: clamp to [1, 5000] K
    let T_K = par.T + 273.15;  // Convert Â°C to K
    if (T_K < 1) {
      u.last = { ...(u.last || {}), warning: `Temperature ${(T_K - 273.15).toFixed(1)}Â°C below absolute zero â€” clamped to 1 K (-272.15Â°C)` };
      T_K = 1;
    } else if (T_K > 5000) {
      u.last = { ...(u.last || {}), warning: `Temperature ${(T_K - 273.15).toFixed(0)}Â°C exceeds 5000 K limit â€” clamped to 5000 K (4726.85Â°C)` };
      T_K = 5000;
    }
    
    ports.out = {
      type: StreamType.MATERIAL,
      T: T_K,
      P: par.P,           // Already in Pa
      n: n,               // mol/s for each component
      phaseConstraint: par.phaseConstraint || 'V' // User-controlled phase constraint
    };
  }
});

// Sink - Stream terminator
UnitRegistry.register('sink', {
  name: 'Sink',
  category: UnitCategories.SINK,
  w: 2,
  h: 2,
  ports: [{ portId: 'in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 }],
  tick(u, ports, par) { 
    // Store incoming stream info for display
    if (ports.in) {
      u.last = {
        stream: { ...ports.in }
      };
    }
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTERY â€” Electrical energy storage (discharge only, for now)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ PURPOSE                                                                    â”‚
// â”‚   Provides electrical power up to its rated capacity.                      â”‚
// â”‚   Behaviorally identical to a fixed-output generator: outputs its max      â”‚
// â”‚   capacity on every tick. The downstream system (hub or direct consumer)   â”‚
// â”‚   decides how much to actually draw.                                       â”‚
// â”‚                                                                            â”‚
// â”‚ PORTS                                                                      â”‚
// â”‚   out (ELECTRICAL, OUT) â€” available power in W                             â”‚
// â”‚                                                                            â”‚
// â”‚ PARAMETERS                                                                 â”‚
// â”‚   maxPower [kW] â€” rated discharge capacity (default: 1000 kW)             â”‚
// â”‚                                                                            â”‚
// â”‚ DESIGN NOTES                                                               â”‚
// â”‚   â€¢ The battery has NO demand-response logic. It is a dumb source.         â”‚
// â”‚   â€¢ When connected to a Power Hub, the hub controls dispatch:              â”‚
// â”‚     firm sources are drawn first, batteries fill the gap.                  â”‚
// â”‚   â€¢ When connected directly to a consumer (no hub), the consumer           â”‚
// â”‚     takes what it needs; excess capacity is simply unused.                 â”‚
// â”‚   â€¢ Charge management (SOC, charge/discharge cycles) is deferred to a     â”‚
// â”‚     future version. Currently the battery can only discharge.              â”‚
// â”‚                                                                            â”‚
// â”‚ INTERNAL UNITS                                                             â”‚
// â”‚   All internal values in W (J/s). par.maxPower is in kW (user-facing).    â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTERY â€” Demand-based electrical source (dispatchable)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Produces up to maxPower on demand. Two modes:
//   Direct: reads downstream powerDemand, reports shortage if demand > capacity.
//   Hub:    hub writes regulated demand via _hubDemand_W (never exceeds capacity).
UnitRegistry.register('battery', {
  name: 'Battery',
  category: UnitCategories.POWER_MANAGEMENT,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    const maxPower_W = (par.maxPower || 1000) * 1000;
    const actualDraw_W = u._actualDraw_W ?? maxPower_W;  // Refined by Step E
    ports.out = {
      type: StreamType.ELECTRICAL,
      capacity: maxPower_W,
      actual: actualDraw_W,
      available: maxPower_W,  // deprecated alias for capacity
      demand: u._hubDemand_W || 0  // Preserve demand written by hub Step C
    };
    u.last = {
      maxPower_W: maxPower_W,
      type: 'battery'
    };
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIXED POWER SOURCE â€” Non-dispatchable electrical source
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Produces at nominal capacity unconditionally. Think grid connection or
// generator at rated load. Not demand-responsive: always outputs maxPower.
UnitRegistry.register('source_electrical', {
  name: 'Power Source',
  category: UnitCategories.POWER_SOURCE,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    const maxPower_W = (par.maxPower || 1000) * 1000;
    const actualDraw_W = u._actualDraw_W ?? maxPower_W;  // Refined by Step E
    ports.out = {
      type: StreamType.ELECTRICAL,
      capacity: maxPower_W,
      actual: actualDraw_W,
      available: maxPower_W,  // deprecated alias for capacity
      demand: u._hubDemand_W !== undefined ? u._hubDemand_W : maxPower_W
    };
    u.last = {
      maxPower_W: maxPower_W,
      type: 'fixed'
    };
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POWER HUB â€” Electrical bus that balances supply and demand
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ PURPOSE                                                                    â”‚
// â”‚   Central switchboard that balances electrical supply and demand.           â”‚
// â”‚   Aggregates power from fixed sources and batteries on elec_in,            â”‚
// â”‚   distributes to consumers on elec_out, and dissipates surplus as heat.    â”‚
// â”‚                                                                            â”‚
// â”‚ PORTS                                                                      â”‚
// â”‚   elec_in  (ELECTRICAL, IN,  multiConnect) â€” all producers connect here    â”‚
// â”‚   elec_out (ELECTRICAL, OUT) â€” all consumers connect here                  â”‚
// â”‚   heat_out (HEAT, OUT) â€” surplus dissipated as heat                        â”‚
// â”‚                                                                            â”‚
// â”‚ BALANCING ALGORITHM (runs in solver post-processing Step C)                â”‚
// â”‚   1. fixed_supply  = Î£ capacity from fixed sources on elec_in              â”‚
// â”‚   2. battery_max   = Î£ capacity from batteries on elec_in                  â”‚
// â”‚   3. total_demand  = Î£ powerDemand of consumers on elec_out                â”‚
// â”‚   4. battery_draw  = clamp(total_demand âˆ’ fixed_supply, 0, battery_max)    â”‚
// â”‚   5. total_supply  = fixed_supply + battery_draw                           â”‚
// â”‚   6. Per-consumer allocation via allocatePower() function:                 â”‚
// â”‚      Default: proportional â€” each consumer gets demand Ã— (supply/demand)   â”‚
// â”‚      Future: priority-based, round-robin, etc. (same function signature)   â”‚
// â”‚   7. surplus       = max(0, fixed_supply âˆ’ total_demand) â†’ heat_out        â”‚
// â”‚                                                                            â”‚
// â”‚ PER-CONSUMER ALLOCATION (v4.2.0)                                           â”‚
// â”‚   Each consumer gets an individual _hubAllocFactor written on its unit.    â”‚
// â”‚   Converters (motor, e-heater) read this instead of the port-level         â”‚
// â”‚   curtailmentFactor. The port retains a global factor as summary/fallback. â”‚
// â”‚   Hub stores full allocation map in u.last.consumerAllocation.             â”‚
// â”‚                                                                            â”‚
// â”‚ DEMAND WRITEBACK                                                           â”‚
// â”‚   Fixed sources: demand = capacity (always producing)                      â”‚
// â”‚   Batteries: demand = proportional share of battery_draw (hub-regulated)   â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POWER ALLOCATION FUNCTION â€” Determines per-consumer power distribution
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pure function: (consumers, totalSupply_W) â†’ allocation map
// Default: proportional (equal curtailment). Replace this function to implement
// priority-based, round-robin, or any custom dispatch strategy.
//
// Input:  consumers = [{ unitId, demand_W, priority }]   (priority: 1=default)
// Output: Map(unitId â†’ { demand_W, allocated_W, factor, priority })
//
// Contract:
//   - Î£ allocated_W â‰¤ totalSupply_W  (never over-allocate)
//   - factor âˆˆ [0, 1]                (allocation / demand)
//   - allocated_W = demand_W Ã— factor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function allocatePower(consumers, totalSupply_W) {
  const allocation = {};
  const totalDemand_W = consumers.reduce((s, c) => s + c.demand_W, 0);
  
  if (totalDemand_W <= 0 || consumers.length === 0) {
    for (const c of consumers) {
      allocation[c.unitId] = { demand_W: 0, allocated_W: 0, factor: 1.0, priority: c.priority ?? 1 };
    }
    return allocation;
  }
  
  // Proportional allocation: each consumer gets the same fraction of their demand
  const globalFactor = Math.min(1.0, totalSupply_W / totalDemand_W);
  
  for (const c of consumers) {
    const allocated_W = c.demand_W * globalFactor;
    allocation[c.unitId] = {
      demand_W: c.demand_W,
      allocated_W: allocated_W,
      factor: globalFactor,
      priority: c.priority ?? 1
    };
  }
  
  return allocation;
}

UnitRegistry.register('power_hub', {
  name: 'Power Hub',
  category: UnitCategories.POWER_MANAGEMENT,
  w: 2,
  h: 3,
  ports: [
    { portId: 'elec_in',  dir: PortDir.IN,  type: StreamType.ELECTRICAL, x: 0, y: 1.5, multiConnect: true },
    { portId: 'elec_out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 1.5 },
    { portId: 'heat_out', dir: PortDir.OUT, type: StreamType.HEAT, x: 1, y: 0 }
  ],
  tick(u, ports, par) {
    const elecIn = ports.elec_in;
    const totalCapacity_W = elecIn ? (elecIn.capacity ?? elecIn.available ?? 0) : 0;
    
    // Forward: advertise supply on elec_out (use carry-forward from Step C)
    const distAvail_W = u._hubDistAvail_W !== undefined ? u._hubDistAvail_W : totalCapacity_W;
    ports.elec_out = {
      type: StreamType.ELECTRICAL,
      capacity: totalCapacity_W,
      actual: distAvail_W,
      available: distAvail_W,  // deprecated alias â€” Step C overwrites
      curtailmentFactor: u._hubCurtailment !== undefined ? u._hubCurtailment : 1.0,
      demand: 0
    };
    
    // Heat out: surplus from Step C (fixed sources that overproduce)
    const surplus_W = u._hubSurplus_W || 0;
    ports.heat_out = {
      type: StreamType.HEAT,
      capacity: surplus_W,
      actual: surplus_W,
      available: surplus_W,  // deprecated alias
      demand: 0
    };
    
    u.last = {
      totalCapacity_W:   totalCapacity_W,
      totalSupply_W:     totalCapacity_W,  // Overwritten by Step C
      totalDemand_W:     0,
      batteryDraw_W:     0,
      surplus_W:         0,
      curtailmentFactor: 1.0
    };
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ELECTRICAL SINK â€” Absorbs and accounts for electrical power
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
UnitRegistry.register('sink_electrical', {
  name: 'Electrical Sink',
  category: UnitCategories.POWER_MANAGEMENT,
  w: 2,
  h: 2,
  ports: [{ portId: 'in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 0, y: 1 }],
  tick(u, ports, par) {
    const sIn = ports.in;
    u.last = {
      absorbed_W: sIn ? (sIn.actual ?? sIn.available ?? 0) : 0
    };
    // Signal unconstrained demand upstream so direct-connected
    // batteries/sources output at full capacity.
    u.powerDemand = Infinity;
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HEAT SINK â€” Absorbs and accounts for thermal power (dump load, radiator)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
UnitRegistry.register('sink_heat', {
  name: 'Heat Sink',
  category: UnitCategories.SINK,
  w: 2,
  h: 2,
  ports: [{ portId: 'in', dir: PortDir.IN, type: StreamType.HEAT, x: 0, y: 1, multiConnect: true }],
  tick(u, ports, par) {
    const sIn = ports.in;
    u.last = {
      absorbed_W: sIn ? (sIn.actual ?? sIn.available ?? 0) : 0,
      sourceCount: sIn?._sourceCount ?? (sIn ? 1 : 0)
    };
    // Signal unconstrained demand upstream so electric heaters (and their
    // sources/batteries) know this sink will absorb all available heat.
    u.heatDemand = Infinity;
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAS TURBINE (EXPANDER) â€” Extracts mechanical work from gas expansion
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Inverse of compressor. Gas enters at high pressure, expands isentropically
// to outlet pressure, producing shaft work. Efficiency reduces extracted work.
//
// Ports: mat_in (MATERIAL) â†’ mat_out (MATERIAL) + mech_out (MECHANICAL)
// Mode:  Fixed outlet pressure (Pout setpoint)
//
// Errors:
//   CATASTROPHIC â€” liquid at inlet (blade destruction)
//   MAJOR        â€” liquid forms during expansion (wet exhaust)
//   MINOR        â€” Pout >= Pin (no expansion possible)
UnitRegistry.register('gas_turbine', {
  name: 'Gas Turbine',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in',  dir: PortDir.IN,  type: StreamType.MATERIAL,   x: 0, y: 1 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL,   x: 2, y: 1 },
    { portId: 'mech_out', dir: PortDir.OUT, type: StreamType.MECHANICAL, x: 1, y: 2 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    if (!sIn) return;
    
    const Pout = par.Pout || (sIn.P / 2);  // Default: expand to half inlet pressure
    const eta = par.eta || 0.88;
    
    // CATASTROPHIC: liquid at inlet destroys turbine blades
    if (sIn.phase === 'L' || (sIn.phase === 'VL' && sIn.vaporFraction < 0.9)) {
      u.last = {
        error: {
          severity: ErrorSeverity.CATASTROPHIC,
          message: 'Turbine destroyed by liquid ingestion (gas turbine requires vapor)'
        }
      };
      return;
    }
    
    // Check expansion is valid (Pout must be < Pin)
    if (Pout >= sIn.P) {
      // No expansion â€” pass through at inlet conditions
      const H_in = thermo.getHdot_Jps(sIn);
      ports.mat_out = {
        type: StreamType.MATERIAL,
        P: sIn.P,
        n: { ...sIn.n },
        phaseConstraint: 'V',
        H_target_Jps: H_in
      };
      ports.mech_out = { type: StreamType.MECHANICAL, capacity: 0, actual: 0, available: 0, demand: 0 };
      u.last = {
        Pin: sIn.P, Pout_setpoint: Pout, Pout_actual: sIn.P,
        W_shaft: 0, W_isentropic: 0, eta: eta,
        error: {
          severity: ErrorSeverity.MINOR,
          message: `Outlet pressure ${(Pout/100000).toFixed(2)} bar â‰¥ inlet ${(sIn.P/100000).toFixed(2)} bar â€” no expansion`
        }
      };
      return;
    }
    
    // Compute turbine work via ThermoAdapter
    const work = thermo.computeTurbineWork(sIn, Pout, eta);
    
    // Set outlet stream
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: Pout,
      n: { ...sIn.n },
      H_target_Jps: work.H_target_Jps
      // No phaseConstraint: PH flash decides outlet phase (may form liquid)
    };
    
    // Mechanical output: shaft work produced
    ports.mech_out = {
      type: StreamType.MECHANICAL,
      capacity: work.W_shaft_W,
      actual: work.W_shaft_W,  // Turbine always produces its full output
      available: work.W_shaft_W,  // deprecated alias
      demand: 0
    };
    
    u.last = {
      Pin: sIn.P,
      Pout_setpoint: Pout,
      Pout_actual: Pout,
      ratio: (sIn.P / Pout).toFixed(2),  // Expansion ratio (> 1)
      Tin: sIn.T - 273.15,
      gamma: work.gammaMix.toFixed(3),
      W_isentropic: work.W_isentropic_W,
      W_shaft: work.W_shaft_W,
      eta: eta,
      eta_pct: (eta * 100).toFixed(0),
      H_in_kW: (work.H_in_Jps / 1000).toFixed(2),
      H_out_kW: (work.H_target_Jps / 1000).toFixed(2)
    };
  },
  // Post-flash check: detect liquid formation in outlet
  postFlashCheck(u, ports) {
    const matOut = ports.mat_out;
    if (!matOut) return;
    if (matOut.phase === 'L' || matOut.phase === 'VL') {
      const vf = matOut.vaporFraction !== undefined ? matOut.vaporFraction : (matOut.phase === 'L' ? 0 : 0.5);
      u.last.error = {
        severity: ErrorSeverity.MAJOR,
        message: `Liquid forming in turbine exhaust (vapor fraction: ${(vf*100).toFixed(1)}%) â€” risk of blade erosion`
      };
      u.last.outletPhase = matOut.phase;
      u.last.outletVF = vf;
    }
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ELECTRICAL GENERATOR â€” Converts mechanical power to electrical power
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Inverse of electric motor. Receives shaft work (e.g. from gas turbine),
// converts to electrical power with efficiency loss.
// This is a bookkeeping unit â€” no thermodynamics, just W_elec = W_mech Ã— Î·.
UnitRegistry.register('generator', {
  name: 'Generator',
  category: UnitCategories.POWER_CONVERSION,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mech_in', dir: PortDir.IN,  type: StreamType.MECHANICAL, x: 0, y: 1 },
    { portId: 'elec_out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 1 },
    { portId: 'heat_out', dir: PortDir.OUT, type: StreamType.HEAT, x: 1, y: 0 }
  ],
  tick(u, ports, par) {
    const mechIn = ports.mech_in;
    if (!mechIn) return;
    
    const eta = par.eta || 0.97;
    const W_mech_W = mechIn.actual ?? mechIn.available ?? 0;
    const W_elec_W = W_mech_W * eta;
    const Q_loss_W = W_mech_W - W_elec_W;  // 1st law: P_in = P_out + Q_loss
    
    u.last = {
      W_mech_W: W_mech_W,
      W_elec_W: W_elec_W,
      Q_loss_W: Q_loss_W,
      eta: eta,
      efficiency_pct: (eta * 100).toFixed(1)
    };
    
    ports.elec_out = {
      type: StreamType.ELECTRICAL,
      capacity: W_elec_W,
      actual: W_elec_W,
      available: W_elec_W,
      demand: 0
    };
    
    // Heat loss port â€” dissipates (1-Î·) fraction of mechanical input
    ports.heat_out = {
      type: StreamType.HEAT,
      capacity: W_mech_W * (1 - eta),
      actual: Q_loss_W,
      available: Q_loss_W,
      demand: 0
    };
  }
});

// Mechanical Source - For testing/standalone mechanical systems
UnitRegistry.register('source_mechanical', {
  name: 'Mechanical Source',
  category: UnitCategories.POWER_SOURCE,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.MECHANICAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    const maxPower_W = (par.maxPower || 1000) * 1000;
    ports.out = {
      type: StreamType.MECHANICAL,
      capacity: maxPower_W,
      actual: u._actualDraw_W ?? maxPower_W,  // Refined by Step E
      available: maxPower_W,  // deprecated alias
      demand: 0
    };
  }
});

// Electric Motor - Converts electrical to mechanical power
UnitRegistry.register('motor', {
  name: 'Electric Motor',
  category: UnitCategories.POWER_CONVERSION,
  w: 2,
  h: 2,
  ports: [
    { portId: 'elec_in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 0, y: 1 },
    { portId: 'mech_out', dir: PortDir.OUT, type: StreamType.MECHANICAL, x: 2, y: 1 },
    { portId: 'heat_out', dir: PortDir.OUT, type: StreamType.HEAT, x: 1, y: 0 }
  ],
  tick(u, ports, par) {
    const elecIn = ports.elec_in;
    if (!elecIn) return;
    
    const eta = par.eta || 0.95;
    // Per-consumer allocation: prefer individual factor from hub (Step C)
    // Falls back to port-level curtailmentFactor (direct battery / no hub)
    const curtailment = u._hubAllocFactor ?? elecIn.curtailmentFactor ?? 1.0;
    const elecActual_W = elecIn.actual ?? elecIn.available ?? 0;
    const elecCapacity_W = elecIn.capacity ?? elecIn.available ?? 0;
    // Per-consumer ceiling: hub's absolute allocation (prevents overdraw even
    // if demand or curtailment is stale). Direct-connect falls to bus actual.
    const myCap_W = u._hubAllocated_W ?? elecActual_W;
    // Demand from Step B rollup. Fallback 0 (not elecActual_W!) ensures an
    // unloaded motor draws nothing, and multiple consumers can't each claim
    // the full bus.  Converges on iteration 2+ once Step B has run.
    const myDemand_W = u._powerDemand_W ?? 0;
    const W_elec_W = Math.min(myDemand_W * curtailment, myCap_W);
    const W_mech_W = W_elec_W * eta;
    const Q_loss_W = W_elec_W - W_mech_W;  // 1st law: P_in = P_out + Q_loss
    
    u.last = {
      W_elec_W: W_elec_W,
      W_mech_W: W_mech_W,
      Q_loss_W: Q_loss_W,
      eta: eta,
      efficiency_pct: (eta * 100).toFixed(1)
    };
    
    ports.mech_out = {
      type: StreamType.MECHANICAL,
      capacity: elecCapacity_W * eta,   // theoretical max throughput
      actual: W_mech_W,                 // actual mechanical output
      available: W_mech_W,              // deprecated alias for actual
      demand: 0
    };
    
    // Heat loss port â€” dissipates (1-Î·) fraction of electrical input
    ports.heat_out = {
      type: StreamType.HEAT,
      capacity: elecCapacity_W * (1 - eta),
      actual: Q_loss_W,
      available: Q_loss_W,
      demand: 0
    };
  }
});

// Electric Heater - Converts electrical power to heat
UnitRegistry.register('electric_heater', {
  name: 'Electric Heater',
  category: UnitCategories.POWER_CONVERSION,
  w: 2,
  h: 2,
  ports: [
    { portId: 'elec_in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 0, y: 1 },
    { portId: 'heat_out', dir: PortDir.OUT, type: StreamType.HEAT, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const elecIn = ports.elec_in;
    if (!elecIn) return;
    
    const eta = 1.00;  // Resistance heater â€” always 100% (1st law)
    // Per-consumer allocation: prefer individual factor from hub (Step C)
    // Falls back to port-level curtailmentFactor (direct battery / no hub)
    const curtailment = u._hubAllocFactor ?? elecIn.curtailmentFactor ?? 1.0;
    const elecActual_W = elecIn.actual ?? elecIn.available ?? 0;
    const elecCapacity_W = elecIn.capacity ?? elecIn.available ?? 0;
    // Per-consumer ceiling: hub's absolute allocation (prevents overdraw even
    // if demand or curtailment is stale). Direct-connect falls to bus actual.
    const myCap_W = u._hubAllocated_W ?? elecActual_W;
    // Demand from Step B rollup. Fallback 0 (not elecActual_W!) ensures an
    // unloaded heater draws nothing.  Converges on iteration 2+ once Step B has run.
    const myDemand_W = u._powerDemand_W ?? 0;
    const W_elec_W = Math.min(myDemand_W * curtailment, myCap_W);
    const Q_available_W = W_elec_W * eta;
    const Q_loss_W = W_elec_W - Q_available_W;  // Always 0 (eta=1.00), computed for consistency
    
    u.last = {
      W_elec_capacity_W: elecCapacity_W,
      W_elec_actual_W: W_elec_W,
      Q_available_W: Q_available_W,
      Q_loss_W: Q_loss_W,
      eta: eta,
      efficiency_pct: (eta * 100).toFixed(1)
    };
    
    ports.heat_out = {
      type: StreamType.HEAT,
      capacity: elecCapacity_W * eta,   // theoretical max heat output
      actual: Q_available_W,            // actual heat output
      available: Q_available_W,         // deprecated alias for actual
      demand: 0
    };
  }
});

// Valve - Isenthalpic pressure reduction
UnitRegistry.register('valve', {
  name: 'Valve',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.in;
    if (!sIn) return;
    
    const Pout = par.Pout || 101325;
    
    // Check for pressure increase (valve can't do this)
    if (Pout > sIn.P) {
      u.last = {
        error: {
          severity: ErrorSeverity.MINOR,
          message: 'Outlet pressure higher than inlet - valve cannot increase pressure'
        }
      };
      return;
    }
    
    // ISENTHALPIC THROTTLING: H_in = H_out
    // Get inlet enthalpy (computed on-demand if not available)
    const H_in_Jps = thermo.getHdot_Jps(sIn);
    
    // Check if enthalpy computation failed (distinguish from valid zero at Tref)
    if (H_in_Jps === 0 && (!sIn.T || !sIn.P || !sIn.n)) {
      u.last = {
        error: {
          severity: ErrorSeverity.MAJOR,
          message: 'Cannot compute inlet enthalpy - missing stream properties'
        }
      };
      return;
    }
    
    ports.out = {
      type: StreamType.MATERIAL,
      P: Pout,
      n: { ...sIn.n },
      phaseConstraint: 'VL',  // Allow phase change
      H_target_Jps: H_in_Jps  // Guaranteed valid
    };
    
    u.last = {
      Pin: sIn.P,
      Pout: Pout,
      deltaP: sIn.P - Pout,
      ratio: (sIn.P / Pout).toFixed(2),
      mode: 'isenthalpic',
      H_in_kW: (H_in_Jps / 1000).toFixed(2)
    };
  }
});

// Pump - Raises liquid pressure
UnitRegistry.register('pump', {
  name: 'Pump',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'power_in', dir: PortDir.IN, type: StreamType.MECHANICAL, x: 1, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    const sPower = ports.power_in;
    if (!sIn) return;
    
    // [v4.2.0] Require power input â€” pump cannot operate without shaft work
    if (!sPower) {
      u.powerDemand = 0;
      ports.mat_out = {
        type: StreamType.MATERIAL,
        P: sIn.P,
        n: { ...sIn.n },
        phaseConstraint: 'L',
        H_target_Jps: thermo.getHdot_Jps(sIn)
      };
      u.last = {
        Pin: sIn.P, Pout_setpoint: par.Pout || (sIn.P + 500000), Pout_actual: sIn.P,
        W_shaft: 0, W_shaft_setpoint: 0, curtailed: true,
        error: {
          severity: ErrorSeverity.MAJOR,
          message: 'No power input connected â€” pump cannot operate without mechanical drive'
        }
      };
      return;
    }
    
    const Pout_setpoint = par.Pout || (sIn.P + 500000);  // Setpoint pressure
    const eta = par.eta || 0.75;
    
    // CRITICAL: Check for vapor (pumps need liquid!)
    if (sIn.phase === 'V' || (sIn.phase === 'VL' && sIn.vaporFraction > 0.1)) {
      u.last = {
        error: {
          severity: ErrorSeverity.MAJOR,
          message: 'Pump cavitation - vapor or two-phase at inlet (pump requires liquid)'
        }
      };
      return;
    }
    
    // Compute work needed for setpoint
    const workFull = thermo.computePumpWork(sIn, Pout_setpoint, eta);
    
    // ALWAYS report demand so hub/network can see it
    u.powerDemand = workFull.W_shaft_W;
    
    // Determine actual shaft work: limited by actual power on port
    const W_avail = sPower ? (sPower.actual ?? sPower.available ?? Infinity) : Infinity;
    const curtailed = W_avail < workFull.W_shaft_W - 1;
    const W_shaft_actual = Math.min(workFull.W_shaft_W, W_avail);
    
    // If no power at all, pass through at inlet conditions
    if (sPower && W_avail < 1) {
      ports.mat_out = {
        type: StreamType.MATERIAL,
        P: sIn.P,
        n: { ...sIn.n },
        phaseConstraint: 'L',
        H_target_Jps: thermo.getHdot_Jps(sIn)
      };
      u.last = {
        Pin: sIn.P, Pout_setpoint: Pout_setpoint, Pout_actual: sIn.P,
        deltaP_setpoint: Pout_setpoint - sIn.P, deltaP_actual: 0,
        V_m3h: workFull.V_m3ps * 3600,
        W_hydraulic: 0, W_shaft: 0, W_shaft_setpoint: workFull.W_shaft_W,
        eta: eta, eta_pct: (eta * 100).toFixed(0), curtailed: true,
        error: {
          severity: ErrorSeverity.MINOR,
          message: `No power available (need ${(workFull.W_shaft_W/1000).toFixed(1)} kW)`
        }
      };
      return;
    }
    
    // Compute actual outlet: full setpoint or partial pressurization
    let Pout_actual, H_target_Jps, W_hyd_actual, V_m3ps;
    
    if (!curtailed) {
      Pout_actual = Pout_setpoint;
      H_target_Jps = workFull.H_target_Jps;
      W_hyd_actual = workFull.W_hydraulic_W;
      V_m3ps = workFull.V_m3ps;
    } else {
      const rev = thermo.computePumpFromWork(sIn, W_shaft_actual, eta);
      Pout_actual = Math.min(rev.P_actual, Pout_setpoint);
      H_target_Jps = rev.H_target_Jps;
      W_hyd_actual = rev.W_hydraulic_W;
      V_m3ps = rev.V_m3ps;
    }
    
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: Pout_actual,
      n: { ...sIn.n },
      phaseConstraint: 'L',
      H_target_Jps: H_target_Jps
    };
    
    u.last = {
      Pin: sIn.P,
      Pout_setpoint: Pout_setpoint,
      Pout_actual: Pout_actual,
      deltaP_setpoint: Pout_setpoint - sIn.P,
      deltaP_actual: Pout_actual - sIn.P,
      V_m3h: V_m3ps * 3600,
      W_hydraulic: W_hyd_actual,          // Actual hydraulic work (W)
      W_shaft: W_shaft_actual,             // Actual shaft work consumed (W)
      W_shaft_setpoint: workFull.W_shaft_W, // Work needed for full setpoint (W)
      eta: eta,
      eta_pct: (eta * 100).toFixed(0),
      H_in_kW: (workFull.H_in_Jps / 1000).toFixed(2),
      H_out_kW: (H_target_Jps / 1000).toFixed(2),
      curtailed: curtailed
    };
    
    if (curtailed) {
      u.last.error = {
        severity: ErrorSeverity.MINOR,
        message: `Power-limited: ${(Pout_actual/100000).toFixed(2)} bar actual vs ${(Pout_setpoint/100000).toFixed(2)} bar setpoint (${(W_shaft_actual/1000).toFixed(1)} / ${(workFull.W_shaft_W/1000).toFixed(1)} kW)`
      };
    }
  }
});

// Compressor - Raises gas pressure
UnitRegistry.register('compressor', {
  name: 'Compressor',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'power_in', dir: PortDir.IN, type: StreamType.MECHANICAL, x: 1, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    const sPower = ports.power_in;
    if (!sIn) return;
    
    // [v4.2.0] Require power input â€” compressor cannot operate without shaft work
    if (!sPower) {
      u.powerDemand = 0;
      ports.mat_out = {
        type: StreamType.MATERIAL,
        P: sIn.P,
        n: { ...sIn.n },
        phaseConstraint: 'V',
        H_target_Jps: thermo.getHdot_Jps(sIn)
      };
      u.last = {
        Pin: sIn.P, Pout_setpoint: par.Pout || (sIn.P * 2), Pout_actual: sIn.P,
        W_shaft: 0, W_shaft_setpoint: 0, curtailed: true,
        error: {
          severity: ErrorSeverity.MAJOR,
          message: 'No power input connected â€” compressor cannot operate without mechanical drive'
        }
      };
      return;
    }
    
    const Pout_setpoint = par.Pout || (sIn.P * 2);  // Setpoint pressure
    const eta = par.eta || 0.80;
    
    // CRITICAL: Check for liquid (compressors destroy with liquid!)
    if (sIn.phase === 'L' || (sIn.phase === 'VL' && sIn.vaporFraction < 0.9)) {
      u.last = {
        error: {
          severity: ErrorSeverity.CATASTROPHIC,
          message: 'Compressor destroyed by liquid ingestion (compressor requires vapor)'
        }
      };
      return;
    }
    
    // Compute work needed for setpoint
    const workFull = thermo.computeCompressorWork(sIn, Pout_setpoint, eta);
    
    // ALWAYS report demand so hub/network can see it
    u.powerDemand = workFull.W_shaft_W;
    
    // Determine actual shaft work: limited by actual power on port
    const W_avail = sPower ? (sPower.actual ?? sPower.available ?? Infinity) : Infinity;
    const curtailed = W_avail < workFull.W_shaft_W - 1;
    const W_shaft_actual = Math.min(workFull.W_shaft_W, W_avail);
    
    // If no power at all, can't compress
    if (sPower && W_avail < 1) {
      // Pass through at inlet conditions (zero work)
      ports.mat_out = {
        type: StreamType.MATERIAL,
        P: sIn.P,
        n: { ...sIn.n },
        phaseConstraint: 'V',
        H_target_Jps: thermo.getHdot_Jps(sIn)
      };
      u.last = {
        Pin: sIn.P,
        Pout_setpoint: Pout_setpoint,
        Pout_actual: sIn.P,
        ratio_setpoint: (Pout_setpoint / sIn.P).toFixed(2),
        ratio_actual: '1.00',
        Tin: sIn.T - 273.15,
        gamma: workFull.gammaMix.toFixed(3),
        W_isentropic: 0, W_shaft: 0, W_shaft_setpoint: workFull.W_shaft_W,
        eta: eta, eta_pct: (eta * 100).toFixed(0),
        curtailed: true,
        error: {
          severity: ErrorSeverity.MINOR,
          message: `No power available (need ${(workFull.W_shaft_W/1000).toFixed(1)} kW)`
        }
      };
      return;
    }
    
    // Compute actual outlet: full setpoint or partial compression
    let Pout_actual, H_target_Jps, W_isen_actual;
    
    if (!curtailed) {
      // Full setpoint reached
      Pout_actual = Pout_setpoint;
      H_target_Jps = workFull.H_target_Jps;
      W_isen_actual = workFull.W_isentropic_W;
    } else {
      // Partial compression: reverse-calculate achievable pressure
      const rev = thermo.computeCompressorFromWork(sIn, W_shaft_actual, eta);
      Pout_actual = Math.min(rev.P_actual, Pout_setpoint);  // Never exceed setpoint
      H_target_Jps = rev.H_target_Jps;
      W_isen_actual = rev.W_isentropic_W;
    }
    
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: Pout_actual,
      n: { ...sIn.n },
      phaseConstraint: 'V',
      H_target_Jps: H_target_Jps
    };
    
    u.last = {
      Pin: sIn.P,
      Pout_setpoint: Pout_setpoint,
      Pout_actual: Pout_actual,
      ratio_setpoint: (Pout_setpoint / sIn.P).toFixed(2),
      ratio_actual: (Pout_actual / sIn.P).toFixed(2),
      Tin: sIn.T - 273.15,
      gamma: workFull.gammaMix.toFixed(3),
      W_isentropic: W_isen_actual,        // Actual isentropic work (W)
      W_shaft: W_shaft_actual,             // Actual shaft work consumed (W)
      W_shaft_setpoint: workFull.W_shaft_W, // Work needed for full setpoint (W)
      eta: eta,
      eta_pct: (eta * 100).toFixed(0),
      H_in_kW: (workFull.H_in_Jps / 1000).toFixed(2),
      H_out_kW: (H_target_Jps / 1000).toFixed(2),
      curtailed: curtailed
    };
    
    if (curtailed) {
      u.last.error = {
        severity: ErrorSeverity.MINOR,
        message: `Power-limited: ${(Pout_actual/100000).toFixed(2)} bar actual vs ${(Pout_setpoint/100000).toFixed(2)} bar setpoint (${(W_shaft_actual/1000).toFixed(1)} / ${(workFull.W_shaft_W/1000).toFixed(1)} kW)`
      };
    }
  }
});

// Heater - Single stream heater with external heat source
// Operates in setpoint mode: user specifies T_out, unit computes Q.
// If connected to a heat stream, Q is limited to available supply.
// Analogous to compressor (user specifies P_out, unit computes W).
UnitRegistry.register('heater', {
  name: 'Heater',
  category: UnitCategories.HEAT_EXCHANGER,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'heat_in', dir: PortDir.IN, type: StreamType.HEAT, x: 1, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    if (!sIn) return;
    
    // Get inlet enthalpy
    const H_in_Jps = thermo.getHdot_Jps(sIn);
    
    if (H_in_Jps === 0 && (!sIn.T || !sIn.P || !sIn.n)) {
      u.last = { error: { severity: ErrorSeverity.MAJOR,
        message: 'Cannot compute inlet enthalpy â€” missing stream properties' } };
      return;
    }
    
    // â”€â”€ Setpoint: compute Q_demand from target outlet temperature â”€â”€
    const T_setpoint_C = (par.T_out !== undefined && par.T_out !== null) ? par.T_out : (sIn.T - 273.15 + 50);
    const T_setpoint_K = T_setpoint_C + 273.15;
    
    if (T_setpoint_K < sIn.T - 0.01) {
      u.last = { error: { severity: ErrorSeverity.MAJOR,
        message: `Setpoint (${T_setpoint_C.toFixed(1)}Â°C) < inlet (${(sIn.T-273.15).toFixed(1)}Â°C) â€” use a heat exchanger for cooling` } };
      return;
    }
    
    const outProxy = { type: StreamType.MATERIAL, T: T_setpoint_K, P: sIn.P, n: { ...sIn.n },
      phaseConstraint: sIn.phaseConstraint || 'VL' };
    const H_setpoint_Jps = thermo.getHdot_Jps(outProxy);
    const Q_demand_W = Math.max(0, H_setpoint_Jps - H_in_Jps);  // W (J/s)
    
    // â”€â”€ Limit Q to available heat supply if connected â”€â”€
    const sHeat = ports.heat_in;
    let Q_actual_W = Q_demand_W;
    let supplyLimited = false;
    
    if (sHeat && (sHeat.actual ?? sHeat.available) >= 0) {
      const heatActual_W = sHeat.actual ?? sHeat.available ?? 0;
      Q_actual_W = Math.min(Q_demand_W, heatActual_W);  // actual in W
      if (Q_demand_W > heatActual_W + 10) {  // 10 W tolerance
        supplyLimited = true;
      }
    }
    
    const H_out_Jps = H_in_Jps + Q_actual_W;  // W + W = W
    
    // â”€â”€ Store heat demand for upstream signaling (P0.2: in W) â”€â”€
    // Reports FULL demand (not limited) so the hub can compute true curtailment
    u.heatDemand = Q_demand_W;
    
    // â”€â”€ Output stream â€” solver PH-flashes to find actual T and phase â”€â”€
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: sIn.P,
      n: { ...sIn.n },
      phaseConstraint: 'VL',
      H_target_Jps: H_out_Jps
    };
    
    u.last = {
      T_in_C: sIn.T - 273.15,
      T_setpoint_C: T_setpoint_C,
      Q_demand_W: Q_demand_W,
      Q_actual_W: Q_actual_W,
      H_in_kW: (H_in_Jps / 1000).toFixed(2),
      H_out_kW: (H_out_Jps / 1000).toFixed(2),
      supplyLimited: supplyLimited
    };
    
    if (supplyLimited) {
      u.last.error = { severity: ErrorSeverity.MINOR,
        message: `Setpoint ${T_setpoint_C.toFixed(0)}Â°C not achievable â€” need ${(Q_demand_W/1000).toFixed(1)} kW, supply limited to ${((sHeat.actual ?? sHeat.available ?? 0)/1000).toFixed(1)} kW` };
    }
  }
});

// Two-Stream Heat Exchanger
UnitRegistry.register('hex', {
  name: 'Heat Exchanger',
  category: UnitCategories.HEAT_EXCHANGER,
  w: 2,
  h: 2,
  ports: [
    // Hot side (horizontal)
    { portId: 'hot_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'hot_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 },
    // Cold side (vertical)
    { portId: 'cold_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 1, y: 0 },
    { portId: 'cold_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 1, y: 2 }
  ],
  tick(u, ports, par) {
    const sHot = ports.hot_in;
    const sCold = ports.cold_in;
    if (!sHot || !sCold) return;
    
    // User can specify approach temperature or outlet temperatures
    const T_approach = par.T_approach !== undefined ? par.T_approach : 10;  // K (default 10K minimum)
    const T_hot_out_target = (par.T_hot_out !== undefined && par.T_hot_out !== null) ? (par.T_hot_out + 273.15) : null;
    const T_cold_out_target = (par.T_cold_out !== undefined && par.T_cold_out !== null) ? (par.T_cold_out + 273.15) : null;
    
    // Compute inlet enthalpies using full thermo system (handles phase, latent heat, nonlinear Cp)
    const H_hot_in = thermo.getHdot_Jps(sHot);    // J/s
    const H_cold_in = thermo.getHdot_Jps(sCold);  // J/s
    
    // Stream Cp still needed for approach-temp heuristic and effectiveness display
    const Cp_hot = thermo.streamCp(sHot);    // J/s/K
    const Cp_cold = thermo.streamCp(sCold);  // J/s/K
    
    // Helper: compute exact stream enthalpy at a given temperature.
    // [v4.7.9] Propagate phaseConstraint from inlet to avoid saturation ambiguity:
    // without it, tpFlash defaults to 'VL', which at saturation returns beta=null
    // and forces computeStreamEnthalpy into a fallback single-phase guess.
    function H_at_T(stream, T_K) {
      const proxy = {
        type: StreamType.MATERIAL,
        T: T_K,
        P: stream.P,
        n: { ...stream.n },
        phaseConstraint: stream.phaseConstraint || 'VL'
      };
      return thermo.getHdot_Jps(proxy);
    }
    
    // Determine outlet enthalpies and duty
    let H_hot_out, H_cold_out, Q_J_s;
    let T_hot_out_est, T_cold_out_est;  // Estimated T for feasibility checks
    
    if (T_hot_out_target !== null) {
      // Hot outlet temperature specified by user
      T_hot_out_est = T_hot_out_target;
      H_hot_out = H_at_T(sHot, T_hot_out_target);
      Q_J_s = H_hot_in - H_hot_out;  // Energy released by hot stream (J/s)
      H_cold_out = H_cold_in + Q_J_s;  // Energy balance: cold stream absorbs Q
      // Estimate cold outlet T for feasibility check (using Cp as approximation)
      T_cold_out_est = (Cp_cold > 1e-12) ? (sCold.T + Q_J_s / Cp_cold) : sCold.T;
      
    } else if (T_cold_out_target !== null) {
      // Cold outlet temperature specified by user
      T_cold_out_est = T_cold_out_target;
      H_cold_out = H_at_T(sCold, T_cold_out_target);
      Q_J_s = H_cold_out - H_cold_in;  // Energy absorbed by cold stream (J/s)
      H_hot_out = H_hot_in - Q_J_s;  // Energy balance: hot stream releases Q
      // Estimate hot outlet T for feasibility check
      T_hot_out_est = (Cp_hot > 1e-12) ? (sHot.T - Q_J_s / Cp_hot) : sHot.T;
      
    } else if (par.UA_W_per_K !== undefined && par.UA_W_per_K !== null) {
      // â”€â”€ [v4.8.1] UA/NTU effectiveness mode (counter-current) â”€â”€
      //
      // Design-style HX rating using overall heat transfer coefficient Ã— area.
      // Uses single-phase Cp approximation for capacity rates; physically valid
      // when both streams remain single-phase with roughly constant Cp.
      //
      // Definitions:
      //   C_hot  = nDot_hot  Ã— cpMolar_hot   [J/s/K]  (= Cp_hot from streamCp)
      //   C_cold = nDot_cold Ã— cpMolar_cold   [J/s/K]
      //   Cmin   = min(C_hot, C_cold)
      //   Cmax   = max(C_hot, C_cold)
      //   Cr     = Cmin / Cmax               (capacity ratio)
      //   NTU    = UA / Cmin                  (number of transfer units)
      //
      // Counter-current effectiveness:
      //   Cr â‰  1:  Îµ = [1 - exp(-NTU(1-Cr))] / [1 - CrÂ·exp(-NTU(1-Cr))]
      //   Cr = 1:  Îµ = NTU / (1 + NTU)
      //
      // Duty: Q = clamp(Îµ Ã— Qmax, 0, Qmax)  where Qmax = Cmin Ã— (Th_in - Tc_in)

      const UA = Math.max(0, par.UA_W_per_K);   // W/K

      // â”€â”€ Two-phase warning â”€â”€
      // UA/NTU assumes constant Cp; it's unreliable with phase change.
      const hotIsVL  = sHot.phase  === 'VL' || sHot.phaseConstraint  === 'VL';
      const coldIsVL = sCold.phase === 'VL' || sCold.phaseConstraint === 'VL';
      let uaNtuWarning = null;
      if (hotIsVL || coldIsVL) {
        uaNtuWarning = 'UA/NTU assumes single-phase constant Cp â€” results are approximate ' +
          'because ' + (hotIsVL && coldIsVL ? 'both streams are' : hotIsVL ? 'hot stream is' : 'cold stream is') +
          ' two-phase. Consider approach or setpoint mode for accuracy.';
      }

      // â”€â”€ Capacity rates â”€â”€
      const C_hot  = Cp_hot;     // Already J/s/K from streamCp
      const C_cold = Cp_cold;

      if (C_hot < 1e-12 || C_cold < 1e-12) {
        u.last = {
          error: { severity: ErrorSeverity.MAJOR,
            message: 'UA/NTU mode requires nonzero heat capacity on both sides' },
          mode: 'ua_ntu'
        };
        return;
      }

      const Cmin = Math.min(C_hot, C_cold);
      const Cmax = Math.max(C_hot, C_cold);
      const Cr   = Cmin / Cmax;

      // â”€â”€ NTU & effectiveness â”€â”€
      const NTU = (Cmin > 1e-12) ? UA / Cmin : 0;
      let epsilon;
      if (UA < 1e-12 || NTU < 1e-12) {
        epsilon = 0;                                // UA â‰ˆ 0 â†’ no heat transfer
      } else if (Math.abs(Cr - 1) < 1e-8) {
        epsilon = NTU / (1 + NTU);                  // Balanced streams
      } else {
        const expTerm = Math.exp(-NTU * (1 - Cr));
        epsilon = (1 - expTerm) / (1 - Cr * expTerm);
      }
      epsilon = Math.max(0, Math.min(1, epsilon));  // Clamp [0,1]

      // â”€â”€ Duty â”€â”€
      const Qmax = Cmin * (sHot.T - sCold.T);      // J/s
      Q_J_s = Math.max(0, Math.min(epsilon * Qmax, Qmax));

      // â”€â”€ Outlet enthalpies (exact via 1st law) â”€â”€
      H_hot_out  = H_hot_in  - Q_J_s;
      H_cold_out = H_cold_in + Q_J_s;

      // â”€â”€ Estimated outlet temperatures (Cp approx for feasibility display) â”€â”€
      T_hot_out_est  = sHot.T  - Q_J_s / C_hot;
      T_cold_out_est = sCold.T + Q_J_s / C_cold;

      // Store UA/NTU diagnostics on unit for u.last merge later
      u._uaNtu = { UA, NTU, Cr, epsilon, Cmin, Cmax, Qmax, uaNtuWarning };

    } else {
      // â”€â”€ [v4.8.0] Approach mode: bisection solve for Q such that dTmin = T_approach â”€â”€
      //
      // For a candidate duty Q (J/s):
      //   H_hot_out  = H_hot_in  - Q
      //   H_cold_out = H_cold_in + Q
      // Resolve T_hot_out, T_cold_out via PH flash, then:
      //   dT1 = T_hot_in - T_cold_out   (hot-end approach)
      //   dT2 = T_hot_out - T_cold_in   (cold-end approach)
      //   dTmin = min(dT1, dT2)
      // Solve: dTmin(Q) = T_approach
      //
      // As Q increases from 0 â†’ Q_max, dTmin decreases monotonically.
      // f(Q) = dTmin(Q) - T_approach.  We want f(Q) = 0.

      // Helper: PH flash â†’ T_K for a given stream template and target enthalpy.
      // Uses ThermoAdapter.phFlash exclusively (no direct EOS calls).
      function T_from_PH(stream, H_Jps) {
        const result = thermo.phFlash(
          { P: stream.P, n: { ...stream.n }, phaseConstraint: stream.phaseConstraint || 'VL' },
          H_Jps
        );
        return result?.T_K ?? stream.T;  // fallback to inlet T if flash fails
      }

      // Evaluate dTmin for a candidate duty Q
      function evalPinch(Q) {
        const Th_out = T_from_PH(sHot,  H_hot_in  - Q);
        const Tc_out = T_from_PH(sCold, H_cold_in + Q);
        const dT1 = sHot.T  - Tc_out;   // hot-end approach
        const dT2 = Th_out  - sCold.T;   // cold-end approach
        return { dTmin: Math.min(dT1, dT2), dT1, dT2, Th_out, Tc_out };
      }

      // â”€â”€ Bracket: Q âˆˆ [0, Q_max] â”€â”€
      // Q_max = enthalpy to cool hot stream to (T_cold_in + T_approach)
      //       or heat cold stream to (T_hot_in - T_approach), whichever is smaller.
      const Q_max_hot  = Math.max(0, H_hot_in  - H_at_T(sHot,  sCold.T + T_approach));
      const Q_max_cold = Math.max(0, H_at_T(sCold, sHot.T  - T_approach) - H_cold_in);
      let Q_hi = Math.min(Q_max_hot, Q_max_cold);

      // Safety: if Q_hi is tiny or zero, no meaningful heat transfer is possible
      if (Q_hi < 1e-3) {
        u.last = {
          error: {
            severity: ErrorSeverity.MAJOR,
            message: `Approach temperature (${T_approach.toFixed(1)} K) too large for available Î”T (${(sHot.T - sCold.T).toFixed(1)} K)`
          },
          mode: 'approach', T_approach_par: T_approach,
          T_hot_in: sHot.T, T_cold_in: sCold.T
        };
        return;
      }

      // Check feasibility: at Q=0, dTmin = T_hot_in - T_cold_in (must exceed T_approach)
      const f_lo = evalPinch(0);
      if (f_lo.dTmin < T_approach - 0.01) {
        u.last = {
          error: {
            severity: ErrorSeverity.MAJOR,
            message: `Approach ${T_approach.toFixed(1)} K infeasible: inlet Î”T = ${(sHot.T - sCold.T).toFixed(1)} K`
          },
          mode: 'approach', T_approach_par: T_approach,
          T_hot_in: sHot.T, T_cold_in: sCold.T
        };
        return;
      }

      // â”€â”€ Bisection: find Q such that dTmin(Q) = T_approach â”€â”€
      let Q_lo = 0;
      const TOL_K = 0.05;     // Temperature tolerance (K)
      const MAX_BISECT = 40;   // Max iterations
      let iterCount = 0;
      let bestQ = 0, bestPinch = f_lo;

      for (let i = 0; i < MAX_BISECT; i++) {
        iterCount++;
        const Q_mid = (Q_lo + Q_hi) / 2;
        const p = evalPinch(Q_mid);

        if (p.dTmin < -1e-3) {
          // Cross detected â€” pull back
          Q_hi = Q_mid;
          continue;
        }

        const err = p.dTmin - T_approach;

        if (Math.abs(err) < TOL_K) {
          bestQ = Q_mid;
          bestPinch = p;
          break;
        }

        if (err > 0) {
          // dTmin still too large â†’ increase Q (transfer more heat)
          Q_lo = Q_mid;
        } else {
          // dTmin too small â†’ decrease Q
          Q_hi = Q_mid;
        }

        bestQ = Q_mid;
        bestPinch = p;
      }

      Q_J_s = bestQ;
      H_hot_out  = H_hot_in  - Q_J_s;
      H_cold_out = H_cold_in + Q_J_s;
      T_hot_out_est  = bestPinch.Th_out;
      T_cold_out_est = bestPinch.Tc_out;

      // Store solver diagnostics
      u._hxApproachIter = iterCount;
      u._hxApproachPinch = bestPinch.dTmin;
    }
    
    // Feasibility checks (using estimated outlet temperatures)
    let error = null;
    const isUaNtuMode = par.UA_W_per_K !== undefined && par.UA_W_per_K !== null;
    
    // Approach-based cross checks (only for setpoint / approach modes, not UA/NTU)
    if (!isUaNtuMode) {
      if (T_hot_out_est < sCold.T + T_approach) {
        error = {
          severity: ErrorSeverity.MAJOR,
          message: `Temperature cross: Hot outlet (${(T_hot_out_est-273.15).toFixed(1)}Â°C) below cold inlet + approach`
        };
      }
      
      if (T_cold_out_est > sHot.T - T_approach) {
        error = {
          severity: ErrorSeverity.MAJOR,
          message: `Temperature cross: Cold outlet (${(T_cold_out_est-273.15).toFixed(1)}Â°C) above hot inlet - approach`
        };
      }
    } else {
      // UA/NTU: check actual temperature cross (Th_out < Tc_in or Tc_out > Th_in)
      if (T_hot_out_est < sCold.T - 0.1) {
        error = {
          severity: ErrorSeverity.MAJOR,
          message: `Temperature cross: Hot outlet (${(T_hot_out_est-273.15).toFixed(1)}Â°C) below cold inlet (${(sCold.T-273.15).toFixed(1)}Â°C)`
        };
      }
      if (T_cold_out_est > sHot.T + 0.1) {
        error = {
          severity: ErrorSeverity.MAJOR,
          message: `Temperature cross: Cold outlet (${(T_cold_out_est-273.15).toFixed(1)}Â°C) above hot inlet (${(sHot.T-273.15).toFixed(1)}Â°C)`
        };
      }
    }
    
    if (T_hot_out_est > sHot.T) {
      error = {
        severity: ErrorSeverity.CATASTROPHIC,
        message: 'Thermodynamic violation: Hot stream gaining heat!'
      };
    }
    
    if (T_cold_out_est < sCold.T) {
      error = {
        severity: ErrorSeverity.CATASTROPHIC,
        message: 'Thermodynamic violation: Cold stream losing heat!'
      };
    }
    
    if (error) {
      u.last = { error };
      return;
    }
    
    // Output streams via H_target_Jps â€” solver uses PH flash to determine T and phase.
    // This correctly handles phase changes (boiling/condensing) in the heat exchanger.
    ports.hot_out = {
      type: StreamType.MATERIAL,
      P: sHot.P,  // Assume negligible pressure drop
      n: { ...sHot.n },
      phaseConstraint: sHot.phaseConstraint || 'VL',
      H_target_Jps: H_hot_out
    };
    
    ports.cold_out = {
      type: StreamType.MATERIAL,
      P: sCold.P,
      n: { ...sCold.n },
      phaseConstraint: sCold.phaseConstraint || 'VL',
      H_target_Jps: H_cold_out
    };
    
    // Calculate effectiveness (using Cp approximation for display)
    const Q_max = Math.min(Cp_hot, Cp_cold) * (sHot.T - sCold.T);  // J/s
    const effectiveness = Q_max > 1e-6 ? (Q_J_s / Q_max * 100).toFixed(1) : 'N/A';
    
    // Determine active mode
    const isUaNtu = par.UA_W_per_K !== undefined && par.UA_W_per_K !== null;
    const activeMode = T_hot_out_target !== null ? 'T_hot_out'
                     : T_cold_out_target !== null ? 'T_cold_out'
                     : isUaNtu ? 'ua_ntu'
                     : 'approach';

    u.last = {
      T_hot_in: sHot.T,
      T_hot_out: T_hot_out_est,
      T_cold_in: sCold.T,
      T_cold_out: T_cold_out_est,
      Q: Q_J_s / 1000,  // Display in kW
      effectiveness: effectiveness,
      approach: Math.min(T_hot_out_est - sCold.T, sHot.T - T_cold_out_est),
      mode: activeMode,
      T_approach_par: T_approach,
      // [v4.8.0] Approach-mode solver diagnostics (only present when mode='approach')
      hxDuty_W: Q_J_s,
      hxPinch_K_tick: u._hxApproachPinch,       // pinch from tick bisection (pre-flash)
      hxApproachIter: u._hxApproachIter          // bisection iteration count
    };

    // [v4.8.1] UA/NTU diagnostics (only present when mode='ua_ntu')
    if (u._uaNtu) {
      const d = u._uaNtu;
      u.last.UA_W_per_K  = d.UA;
      u.last.NTU         = d.NTU;
      u.last.Cr          = d.Cr;
      u.last.epsilon     = d.epsilon;
      u.last.Cmin        = d.Cmin;
      u.last.Cmax        = d.Cmax;
      u.last.Qmax_W      = d.Qmax;
      if (d.uaNtuWarning) {
        u.last.uaNtuWarning = d.uaNtuWarning;
      }
    }
  },

  // [v4.7.0] Post-solve validation using resolved (PH-flashed) outlet temperatures.
  // The tick function uses Cp estimates for feasibility checks, but those can diverge
  // from the actual PH flash result (especially with phase change).  This validator
  // reads the real T after the solver has resolved H_target_Jps â†’ T via phFlash.
  postFlashCheck(u, ports) {
    if (!u.last || u.last.error) return;  // tick bailed with error

    const hot_in   = ports.hot_in;
    const hot_out  = ports.hot_out;
    const cold_in  = ports.cold_in;
    const cold_out = ports.cold_out;
    if (!hot_in || !hot_out || !cold_in || !cold_out) return;
    if (!hot_out.T || !cold_out.T) return;  // PH flash didn't resolve

    const Th_in  = hot_in.T;
    const Th_out = hot_out.T;
    const Tc_in  = cold_in.T;
    const Tc_out = cold_out.T;

    // End-approach temperatures (positive = feasible)
    const dT_end1 = Th_in  - Tc_out;  // hot inlet vs cold outlet
    const dT_end2 = Th_out - Tc_in;   // hot outlet vs cold inlet
    const dTmin   = Math.min(dT_end1, dT_end2);

    // Overwrite u.last temperatures with actual resolved values
    u.last.T_hot_out_actual  = Th_out;
    u.last.T_cold_out_actual = Tc_out;
    u.last.dT_end1 = dT_end1;
    u.last.dT_end2 = dT_end2;
    u.last.hxPinch_K = dTmin;

    // â”€â”€ Temperature cross detection â”€â”€
    const EPS = 1e-3;  // K â€” numerical noise floor
    u.last.hxCross = dTmin < -EPS;

    if (!u.last.errors) u.last.errors = [];

    if (u.last.hxCross) {
      u.last.errors.push({
        severity: ErrorSeverity.MAJOR,
        message: `Temperature cross detected (Î”Tmin = ${dTmin.toFixed(2)} K): ` +
                 `Th_in=${(Th_in-273.15).toFixed(1)}Â°C â†’ Th_out=${(Th_out-273.15).toFixed(1)}Â°C, ` +
                 `Tc_in=${(Tc_in-273.15).toFixed(1)}Â°C â†’ Tc_out=${(Tc_out-273.15).toFixed(1)}Â°C`
      });
    }

    // â”€â”€ Approach violation (only in approach mode) â”€â”€
    if (u.last.mode === 'approach') {
      const T_approach = u.last.T_approach_par || 0;
      const tol = 0.5;  // K â€” tolerance for approach target
      u.last.hxApproachViolation = dTmin < T_approach - tol;
      if (u.last.hxApproachViolation) {
        u.last.errors.push({
          severity: ErrorSeverity.MINOR,
          message: `Approach violation: actual pinch ${dTmin.toFixed(2)} K < target ${T_approach.toFixed(1)} K`
        });
      }
    }
  }
});

// [v4.0.0] Removed duplicate flash_drum registration that used port 'in' instead of 'mat_in'.
// The canonical flash_drum definition is below (after splitter), using 'mat_in' for consistency.

// Mixer - Adiabatic stream mixer (2 inlets to 1 outlet)
UnitRegistry.register('mixer', {
  name: 'Mixer',
  category: UnitCategories.TOPOLOGY,
  w: 2,
  h: 2,
  ports: [
    { portId: 'in1', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 0 },
    { portId: 'in2', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 2 },
    { portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const s1 = ports.in1;
    const s2 = ports.in2;
    
    // At least one inlet must have data.
    // A connected-but-not-yet-computed inlet (e.g., a recycle stream on the first
    // solver iteration) is treated as zero flow. This bootstraps successive
    // substitution for recycle loops â€” the standard "tear stream" approach.
    if (!s1 && !s2) return;
    
    // Effective inlets: missing â†’ zero-flow placeholder
    const EMPTY_STREAM = { type: StreamType.MATERIAL, T: 298.15, P: 101325, n: {} };
    const eff1 = s1 || EMPTY_STREAM;
    const eff2 = s2 || EMPTY_STREAM;
    
    // â”€â”€ Pressure: minimum of inlets that have real data â”€â”€
    // Ignore placeholders (recycle bootstrap) â€” only real streams set pressure
    const pressures = [];
    if (s1 && s1.P > 0) pressures.push(s1.P);
    if (s2 && s2.P > 0) pressures.push(s2.P);
    const P_out = pressures.length > 0 ? Math.min(...pressures) : 101325;
    
    // â”€â”€ Molar balance: merge compositions â”€â”€
    const n_out = {};
    for (const [comp, n] of Object.entries(eff1.n || {})) {
      n_out[comp] = (n_out[comp] || 0) + n;
    }
    for (const [comp, n] of Object.entries(eff2.n || {})) {
      n_out[comp] = (n_out[comp] || 0) + n;
    }
    
    // Clamp tiny negatives from numerical noise
    for (const comp in n_out) {
      if (n_out[comp] < 0) n_out[comp] = 0;
    }
    
    const nTotal = Object.values(n_out).reduce((a, b) => a + b, 0);
    
    // Handle empty streams gracefully
    if (nTotal < 1e-15) {
      ports.out = {
        type: StreamType.MATERIAL,
        T: 298.15,
        P: P_out,
        n: {},
        phaseConstraint: 'VL'
      };
      u.last = { warning: 'All inlets are empty â€” zero total flow' };
      return;
    }
    
    // â”€â”€ Energy balance: adiabatic mixer (Q = 0, W = 0) â”€â”€
    // H_out = H_in1 + H_in2  (total enthalpy flow in J/s)
    // For empty placeholder streams, getHdot_Jps returns 0 (no flow = no enthalpy)
    const H_in1 = s1 ? thermo.getHdot_Jps(eff1) : 0;
    const H_in2 = s2 ? thermo.getHdot_Jps(eff2) : 0;
    const H_out_Jps = H_in1 + H_in2;
    
    // â”€â”€ Output stream spec: solver will PH-flash to find T and phase â”€â”€
    ports.out = {
      type: StreamType.MATERIAL,
      P: P_out,
      n: n_out,
      phaseConstraint: 'VL',
      H_target_Jps: H_out_Jps
    };
    
    // â”€â”€ Diagnostics for display â”€â”€
    u.last = {
      P_out: P_out,
      nTotal: nTotal,
      H_in1_kW: (H_in1 / 1000).toFixed(2),
      H_in2_kW: (H_in2 / 1000).toFixed(2),
      H_out_kW: (H_out_Jps / 1000).toFixed(2),
      nComponents: Object.keys(n_out).length
    };
  }
});

// Splitter - Stream splitter (1 inlet to 2 outlets, no component separation)
UnitRegistry.register('splitter', {
  name: 'Splitter',
  category: UnitCategories.TOPOLOGY,
  w: 2,
  h: 2,
  ports: [
    { portId: 'in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'out1', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 0 },
    { portId: 'out2', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 2 }
  ],
  tick(u, ports, par) {
    const sIn = ports.in;
    if (!sIn) return;
    
    // Split fraction: percentage of inlet going to out1 (0â€“100)
    const pct = (par.splitPct !== undefined && par.splitPct !== null) ? par.splitPct : 50;
    const frac1 = Math.max(0, Math.min(100, pct)) / 100;
    const frac2 = 1 - frac1;
    
    // â”€â”€ Molar balance: identical composition split â”€â”€
    const n_out1 = {};
    const n_out2 = {};
    for (const [comp, n] of Object.entries(sIn.n || {})) {
      n_out1[comp] = Math.max(0, frac1 * n);
      n_out2[comp] = Math.max(0, frac2 * n);
    }
    
    const nTotal = Object.values(sIn.n || {}).reduce((a, b) => a + b, 0);
    
    // Handle empty inlet gracefully
    if (nTotal < 1e-15) {
      const empty = { type: StreamType.MATERIAL, T: 298.15, P: sIn.P || 101325, n: {}, phaseConstraint: 'VL' };
      ports.out1 = { ...empty };
      ports.out2 = { ...empty };
      u.last = { warning: 'Inlet stream is empty â€” zero total flow' };
      return;
    }
    
    // â”€â”€ Energy balance: split enthalpy proportionally â”€â”€
    // Specific enthalpy is identical in both outlets (same T, P, composition)
    // So H_out1 = frac1 * H_in, H_out2 = frac2 * H_in
    const H_in_Jps = thermo.getHdot_Jps(sIn);
    
    ports.out1 = {
      type: StreamType.MATERIAL,
      P: sIn.P,
      n: n_out1,
      phaseConstraint: sIn.phaseConstraint || 'VL',
      H_target_Jps: frac1 * H_in_Jps
    };
    
    ports.out2 = {
      type: StreamType.MATERIAL,
      P: sIn.P,
      n: n_out2,
      phaseConstraint: sIn.phaseConstraint || 'VL',
      H_target_Jps: frac2 * H_in_Jps
    };
    
    // â”€â”€ Diagnostics â”€â”€
    u.last = {
      splitPct: pct,
      P: sIn.P,
      nTotal: nTotal,
      nOut1: Object.values(n_out1).reduce((a, b) => a + b, 0),
      nOut2: Object.values(n_out2).reduce((a, b) => a + b, 0),
      H_in_kW: (H_in_Jps / 1000).toFixed(2),
      H_out1_kW: (frac1 * H_in_Jps / 1000).toFixed(2),
      H_out2_kW: (frac2 * H_in_Jps / 1000).toFixed(2)
    };
  }
});

// Flash Drum (L-V Separator) â€” Adiabatic phase separation
// Inlet stream flashes at its T, P conditions.
// Vapor exits top, liquid exits bottom.
// No parameters â€” separation is determined by thermodynamics.
// Analogous pattern: splitter splits by fraction, flash drum splits by phase.
UnitRegistry.register('flash_drum', {
  name: 'Flash Drum',
  category: UnitCategories.SEPARATOR,
  w: 2,
  h: 3,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'vap_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 0 },
    { portId: 'liq_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 3 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    if (!sIn) return;
    
    // The inlet stream arrives already flashed by the solver.
    // It carries: T, P, n, nV, nL, beta, phase, x, y, Hdot_J_s
    
    const nV = sIn.nV || {};
    const nL = sIn.nL || {};
    const nTotal_V = Object.values(nV).reduce((a, b) => a + b, 0);
    const nTotal_L = Object.values(nL).reduce((a, b) => a + b, 0);
    const nTotal = nTotal_V + nTotal_L;
    
    if (nTotal < 1e-15) {
      const empty = { type: StreamType.MATERIAL, T: sIn.T || 298.15, P: sIn.P || 101325, n: {}, phaseConstraint: 'VL' };
      ports.vap_out = { ...empty };
      ports.liq_out = { ...empty };
      u.last = { error: { severity: ErrorSeverity.MAJOR, message: 'Empty feed' } };
      return;
    }
    
    // â”€â”€ Vapor outlet â”€â”€
    // Phase constraint = V: solver will compute vapor-only enthalpy
    ports.vap_out = {
      type: StreamType.MATERIAL,
      T: sIn.T,
      P: sIn.P,
      n: { ...nV },
      phaseConstraint: 'V'
    };
    
    // â”€â”€ Liquid outlet â”€â”€
    // Phase constraint = L: solver will compute liquid-only enthalpy
    ports.liq_out = {
      type: StreamType.MATERIAL,
      T: sIn.T,
      P: sIn.P,
      n: { ...nL },
      phaseConstraint: 'L'
    };
    
    // â”€â”€ Diagnostics â”€â”€
    const beta = sIn.beta !== undefined ? sIn.beta : (nTotal > 0 ? nTotal_V / nTotal : 0);
    
    u.last = {
      T_C: (sIn.T - 273.15),
      P_bar: (sIn.P / 1e5),
      phase: sIn.phase || 'unknown',
      beta: beta,
      vap_pct: (beta * 100),
      nTotal: nTotal,
      nV_total: nTotal_V,
      nL_total: nTotal_L
    };
    
    // Composition detail per component
    const comps = [...new Set([...Object.keys(nV), ...Object.keys(nL)])];
    for (const c of comps) {
      const feed = (nV[c] || 0) + (nL[c] || 0);
      if (feed > 1e-15) {
        u.last[`K_${c}`] = ((sIn.y?.[c] || 0) / (sIn.x?.[c] || 1e-30));
        u.last[`recovery_V_${c}_pct`] = ((nV[c] || 0) / feed * 100);
      }
    }
  }
});

/* =========================
   SCENE CLASS
   Manages the process flowsheet state
   ========================= */
class Scene {
  constructor() {
    // Grid properties (kept for backwards compatibility in export/import)
    this.gridW = 22;
    this.gridH = 14;
    this.tile = 48; // Size of one grid cell in world units
    
    // Scene data
    this.units = new Map();
    this.connections = [];
    this._idCounter = 0;
    this.processName = '';
    
    // Runtime calculation results
    this.runtime = {
      unitData: new Map(),
      lastSolve: { ok: true, iterations: 0, warnings: [] }
    };
  }

  placeUnit(defId, x, y) {
    const def = UnitRegistry.get(defId);
    if (!def) return null;
    
    // Check collision with existing units
    if (this._collision(x, y, def.w, def.h, null)) return null;
    
    // Create new unit with default parameters
    const id = `${defId}-${++this._idCounter}`;
    const unit = { 
      id, 
      defId, 
      name: `${def.name} ${this._idCounter}`, // Default name
      x, 
      y, 
      rot: 0, 
      params: {} 
    };
    
    // Set default parameters based on unit type
    // [v4.5.0] Every unit gets sensible defaults so it's immediately operational
    // when dropped on the flowsheet â€” no mandatory manual configuration.
    switch (defId) {
      // â”€â”€ Material source: N2 gas at ambient conditions â”€â”€
      case 'source':
        unit.params = { species: 'N2', nDot: 1.0, T: 25, P: 101325, phaseConstraint: 'V' };
        break;
      // â”€â”€ Power / mechanical sources â”€â”€
      case 'source_electrical':
      case 'source_mechanical':
        unit.params = { maxPower: 50 };   // 50 kW â€” reasonable small plant
        break;
      case 'battery':
        unit.params = { maxPower: 20 };   // 20 kW battery
        break;
      // â”€â”€ Turbomachinery â”€â”€
      case 'pump':
        unit.params = { Pout: 500000, eta: 0.75 };     // 5 bar, centrifugal
        break;
      case 'compressor':
        unit.params = { Pout: 300000, eta: 0.80 };     // 3 bar, centrifugal
        break;
      case 'gas_turbine':
        unit.params = { Pout: 101325, eta: 0.88 };     // expand to 1 atm
        break;
      // â”€â”€ Power conversion â”€â”€
      case 'motor':
        unit.params = { eta: 0.95 };      // industrial-grade
        break;
      case 'generator':
        unit.params = { eta: 0.97 };      // grid-scale
        break;
      case 'electric_heater':
        unit.params = { eta: 1.00 };      // resistance heater â€” always 1.00
        break;
      // â”€â”€ Pressure change â”€â”€
      case 'valve':
        unit.params = { Pout: 101325 };   // let down to 1 atm
        break;
      // â”€â”€ Heat exchange â”€â”€
      case 'heater':
        unit.params = { T_out: 150 };     // 150 Â°C outlet
        break;
      case 'hex':
        unit.params = { T_approach: 10 }; // 10 K approach
        break;
      // â”€â”€ Topology â”€â”€
      case 'splitter':
        unit.params = { splitPct: 50 };   // 50/50 split
        break;
      // â”€â”€ Units with no params: sink, sink_electrical, sink_heat,
      //    power_hub, mixer, flash_drum â€” empty params is correct â”€â”€
    }
    
    this.units.set(id, unit);
    return id;
  }

  deleteUnit(id) {
    this.units.delete(id);
    // Remove all connections involving this unit
    this.connections = this.connections.filter(
      c => c.from.unitId !== id && c.to.unitId !== id
    );
  }

  moveUnit(id, nx, ny) {
    const u = this.units.get(id);
    if (!u) return;
    
    const def = UnitRegistry.get(u.defId);
    
    // Check collision at new position
    if (this._collision(nx, ny, def.w, def.h, id)) return;
    
    u.x = nx;
    u.y = ny;
  }

  rotateUnit(id) {
    const u = this.units.get(id);
    if (!u) return;
    u.rot = (u.rot + 1) % 4;
  }

  unitAt(x, y) {
    for (const [id, u] of this.units) {
      const def = UnitRegistry.get(u.defId);
      if (x >= u.x && x < u.x + def.w && y >= u.y && y < u.y + def.h) {
        return u;
      }
    }
    return null;
  }

  _collision(x, y, w, h, skipId) {
    for (const [id, u] of this.units) {
      if (id === skipId) continue;
      
      const def = UnitRegistry.get(u.defId);
      const ox = u.x, oy = u.y, ow = def.w, oh = def.h;
      
      // AABB collision detection
      if (!(x + w <= ox || ox + ow <= x || y + h <= oy || oy + oh <= y)) {
        return true;
      }
    }
    return false;
  }

  connect(from, to) {
    this._lastConnectError = null;  // Clear previous error

    // Validate units exist
    const uFrom = this.units.get(from.unitId);
    const uTo = this.units.get(to.unitId);
    if (!uFrom || !uTo) return null;

    // Validate ports exist and are compatible
    const defFrom = UnitRegistry.get(uFrom.defId);
    const defTo = UnitRegistry.get(uTo.defId);
    const pFrom = defFrom.ports.find(p => p.portId === from.portId);
    const pTo = defTo.ports.find(p => p.portId === to.portId);
    if (!pFrom || !pTo) return null;
    if (pFrom.type !== pTo.type) return null; // Check stream type compatibility

    // Check if target IN port already has a connection
    // Exception: multiConnect ports accept unlimited connections
    const existingToPort = this.connections.find(
      c => c.to.unitId === to.unitId && c.to.portId === to.portId
    );
    if (existingToPort && !(pTo && pTo.multiConnect)) return null;

    // Check source OUT port connections based on stream type
    const existingFromPort = this.connections.find(
      c => c.from.unitId === from.unitId && c.from.portId === from.portId
    );
    
    // For MATERIAL streams: strict 1-to-1 (physical splitting not allowed)
    if (pFrom.type === StreamType.MATERIAL && existingFromPort) {
      return null;
    }
    
    // For POWER streams (ELECTRICAL, MECHANICAL): allow multiple outputs from source
    // This models electrical bus / mechanical shaft sharing

    // [v4.4.0] Hub-to-hub rejection â€” cascaded hubs silently produce wrong
    // power balances because Step C doesn't propagate demand or curtailment
    // across hub boundaries.  Block until proper hierarchical dispatch exists.
    if (uFrom.defId === 'power_hub' && uTo.defId === 'power_hub') {
      this._lastConnectError = 'Hub-to-hub connection not supported â€” use a motor or converter between hubs.';
      return null;
    }

    // [v4.3.0] Power cycle prevention â€” reject if this connection would
    // create a cycle in the power graph (energy from nothing).
    if (isPowerStreamType(pFrom.type)) {
      if (wouldCreatePowerCycle(from.unitId, to.unitId, this.connections, this.units)) {
        this._lastConnectError = 'Power cycle detected â€” would create infinite energy.';
        return null;
      }
    }

    // Create connection
    this._lastConnectError = null;
    const id = `conn-${++this._idCounter}`;
    this.connections.push({ id, from, to });
    return id;
  }

  exportJSON() {
    const data = {
      version: 8,
      processName: this.processName || '',
      grid: { w: this.gridW, h: this.gridH, tile: this.tile },
      units: [],
      connections: [],
      modelsActive: models.active
    };
    
    for (const u of this.units.values()) {
      data.units.push({
        id: u.id,
        defId: u.defId,
        name: u.name,
        x: u.x,
        y: u.y,
        rot: u.rot,
        params: u.params
      });
    }
    
    data.connections = [...this.connections];
    return JSON.stringify(data, null, 2);
  }

  importJSON(str) {
    const data = JSON.parse(str);
    
    // Process metadata
    this.processName = data.processName || '';
    
    // Guard against missing fields with defaults
    this.gridW = data.grid?.w ?? 50;
    this.gridH = data.grid?.h ?? 50;
    this.tile = data.grid?.tile ?? 48;
    
    this.units.clear();
    this.connections = [];
    
    // Import units and rebuild ID counter to avoid collisions
    let maxUnitId = 0;
    for (const u of (data.units || [])) {
      // Guard against missing unit fields
      const unit = {
        id: u.id || `unit-${++maxUnitId}`,
        defId: u.defId || 'source_gas',
        name: u.name || 'Unit',
        x: u.x ?? 0,
        y: u.y ?? 0,
        rot: u.rot ?? 0,
        params: u.params || {}
      };
      
      this.units.set(unit.id, unit);
      
      // Extract numeric suffix from ID to rebuild counter
      // IDs like "pump-5", "valve-12" â†’ extract max number
      const match = unit.id.match(/-(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        maxUnitId = Math.max(maxUnitId, num);
      }
    }
    
    // Import connections and rebuild ID counter
    let maxConnId = 0;
    for (const c of (data.connections || [])) {
      // Guard against missing connection fields
      const conn = {
        id: c.id || `conn-${++maxConnId}`,
        from: {
          unitId: c.from?.unitId || '',
          portId: c.from?.portId || ''
        },
        to: {
          unitId: c.to?.unitId || '',
          portId: c.to?.portId || ''
        }
      };
      
      this.connections.push(conn);
      
      // Extract numeric suffix from connection ID
      const match = conn.id.match(/-(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        maxConnId = Math.max(maxConnId, num);
      }
    }
    
    // Set _idCounter to max of both to ensure no collisions
    this._idCounter = Math.max(maxUnitId, maxConnId);
    
    // Import active models with validation
    // Skip null/undefined model IDs (models not yet registered)
    if (data.modelsActive) {
      for (const k in data.modelsActive) {
        const modelId = data.modelsActive[k];
        
        // Skip if no model is set for this kind
        if (modelId === null || modelId === undefined) {
          continue;
        }
        
        const success = models.setActive(k, modelId);
        if (!success) {
          console.warn(`Failed to activate model '${modelId}' for kind '${k}' during import`);
        }
        
        // If restoring thermo_package, also switch the actual engine
        if (k === 'thermo_package' && success) {
          const pkg = models.getActive('thermo_package');
          if (pkg && pkg instanceof ThermoPackage) {
            thermo.setPackage(pkg);
          }
        }
      }
    }
  }
}

const scene = new Scene();

/* =========================
   STREAM SIGNATURE â€” tolerant numeric change detection
   Replaces JSON.stringify comparison with field-level numeric tolerances.
   ========================= */

/**
 * Extract a lightweight numeric signature from a stream object.
 * Only key fields that drive convergence are included.
 * Non-numeric fields (type, phase) are kept as-is for exact match.
 * The `demand` field is always excluded â€” it is a backward annotation.
 */
function streamSignature(stream) {
  if (!stream) return null;
  const sig = {};

  // --- categorical (exact match, prefixed with _) ---
  if (stream.type  !== undefined) sig._type  = stream.type;
  if (stream.phase !== undefined) sig._phase = stream.phase;

  // --- key numerics for material streams ---
  if (stream.T             !== undefined) sig.T             = stream.T;
  if (stream.P             !== undefined) sig.P             = stream.P;
  if (stream.beta          !== undefined) sig.beta          = stream.beta;
  if (stream.vaporFraction !== undefined) sig.vaporFraction = stream.vaporFraction;
  if (stream.Hdot_J_s      !== undefined) sig.Hdot_J_s      = stream.Hdot_J_s;

  // --- molar flows (sparse object) ---
  if (stream.n && typeof stream.n === 'object') {
    const keys = Object.keys(stream.n).sort();
    for (const k of keys) sig['n_' + k] = stream.n[k];
  }

  // --- non-material (power) streams ---
  if (stream.capacity           !== undefined) sig.capacity           = stream.capacity;
  if (stream.actual             !== undefined) sig.actual             = stream.actual;
  if (stream.available          !== undefined) sig.available          = stream.available;
  if (stream.curtailmentFactor  !== undefined) sig.curtailmentFactor  = stream.curtailmentFactor;

  return sig;
}

/**
 * Compare two port-maps (portId â†’ stream) using tolerant numeric comparison.
 * Returns true if ANY key numeric field changed beyond its tolerance.
 *
 * Uses combined absolute + relative tolerance (standard for numerical solvers):
 *   effective_tol = max(abs_tol, rel_tol Ã— max(|a|, |b|))
 *
 * This ensures that:
 *   - Near-zero values use the absolute floor (e.g. 1e-12 mol/s)
 *   - Large values use proportional tolerance (1 ppm of 3 mol/s â‰ˆ 3e-6)
 *
 * Without the relative component, a recycle loop with ratio r needs
 * ~log(atol/F)/log(r) iterations (F=feed).  For 50% recycle at 10 mol/s
 * with atol=1e-12 that's ~40 iterations â€” far exceeding MAX_ITER.
 * With rel_tol=1e-6, convergence occurs at ~21 iterations for 50% recycle
 * and ~13 for 30% recycle, well within MAX_ITER=50.
 *
 * Absolute tolerances (floors for near-zero values):
 *   Temperature:  0.001 K       Pressure:  0.1 Pa
 *   Molar flow:   1e-12 mol/s   Enthalpy:  0.01 J/s
 *   Power fields:  0.01 W       Fractions: 1e-8
 * Relative tolerance: 1e-6 (1 ppm) for all numeric fields
 */
function portsChanged(oldPorts, newPorts) {
  const ABS_TOL = {
    T: 0.001, P: 0.1,
    beta: 1e-8, vaporFraction: 1e-8,
    Hdot_J_s: 0.01,
    capacity: 0.01, actual: 0.01, available: 0.01,
    curtailmentFactor: 1e-8
  };
  const FLOW_ABS_TOL = 1e-12;  // mol/s â€” absolute floor for near-zero flows
  const REL_TOL = 1e-6;         // 1 ppm â€” relative tolerance for all numerics

  const allKeys = new Set([...Object.keys(oldPorts), ...Object.keys(newPorts)]);
  for (const portId of allKeys) {
    const oldSig = streamSignature(oldPorts[portId]);
    const newSig = streamSignature(newPorts[portId]);

    if ((oldSig === null) !== (newSig === null)) return true;
    if (oldSig === null) continue;

    const fields = new Set([...Object.keys(oldSig), ...Object.keys(newSig)]);
    for (const f of fields) {
      const a = oldSig[f];
      const b = newSig[f];
      if (a === undefined && b !== undefined) return true;
      if (a !== undefined && b === undefined) return true;

      if (f.startsWith('_')) {
        if (a !== b) return true;
      } else if (typeof a === 'number' && typeof b === 'number') {
        const absTol = f.startsWith('n_') ? FLOW_ABS_TOL : (ABS_TOL[f] ?? 1e-9);
        const tol = Math.max(absTol, REL_TOL * Math.max(Math.abs(a), Math.abs(b)));
        if (Math.abs(a - b) > tol) return true;
      } else if (a !== b) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Strip the `demand` field from every stream in a port map.
 * Demand is a backward annotation and must not affect forward-convergence checks.
 */
function stripDemandFromPorts(ports) {
  const stripped = {};
  for (const [portId, stream] of Object.entries(ports)) {
    if (stream && stream.demand !== undefined) {
      const { demand, ...rest } = stream;
      stripped[portId] = rest;
    } else {
      stripped[portId] = stream;
    }
  }
  return stripped;
}

/* =========================
   POWER CYCLE DETECTION
   DFS reachability check on the power (non-material) connection graph.
   Prevents energy-from-nothing loops like Hub â†’ Motor â†’ Generator â†’ Hub.
   ========================= */

/** True for stream types that carry energy (not material). */
function isPowerStreamType(type) {
  return type === StreamType.ELECTRICAL
      || type === StreamType.MECHANICAL
      || type === StreamType.HEAT;
}

/**
 * Detect whether a power cycle exists among the given connections.
 * Builds a directed adjacency list from all power-type connections,
 * then runs iterative DFS for back-edge detection.
 *
 * @param {Array} connections - The scene's connection array
 * @param {Map}   units       - The scene's unit map (id â†’ unit)
 * @returns {Array|null} Array of unit IDs forming the cycle, or null if acyclic
 */
function detectPowerCycle(connections, units) {
  // Build adjacency list for power-type edges only
  const adj = new Map();   // unitId â†’ Set<unitId>
  for (const c of connections) {
    const fromU = units.get(c.from.unitId);
    const toU   = units.get(c.to.unitId);
    if (!fromU || !toU) continue;

    const defFrom = UnitRegistry.get(fromU.defId);
    const pFrom   = defFrom.ports.find(p => p.portId === c.from.portId);
    if (!pFrom || !isPowerStreamType(pFrom.type)) continue;

    if (!adj.has(c.from.unitId)) adj.set(c.from.unitId, new Set());
    adj.get(c.from.unitId).add(c.to.unitId);
  }

  // DFS with three-colour marking (WHITE / GREY / BLACK)
  const WHITE = 0, GREY = 1, BLACK = 2;
  const colour = new Map();
  const parent = new Map();
  for (const uid of units.keys()) colour.set(uid, WHITE);

  for (const startId of units.keys()) {
    if (colour.get(startId) !== WHITE) continue;

    const stack = [{ id: startId, iter: null }];
    colour.set(startId, GREY);

    while (stack.length > 0) {
      const top = stack[stack.length - 1];

      if (!top.iter) {
        const neighbours = adj.get(top.id);
        top.iter = neighbours ? neighbours.values() : [][Symbol.iterator]();
      }

      const next = top.iter.next();
      if (next.done) {
        colour.set(top.id, BLACK);
        stack.pop();
        continue;
      }

      const nid = next.value;
      const nc  = colour.get(nid);

      if (nc === GREY) {
        // Back edge â†’ cycle found.  Reconstruct the cycle path.
        const cycle = [nid];
        for (let i = stack.length - 1; i >= 0; i--) {
          cycle.push(stack[i].id);
          if (stack[i].id === nid) break;
        }
        return cycle.reverse();
      }

      if (nc === WHITE) {
        colour.set(nid, GREY);
        parent.set(nid, top.id);
        stack.push({ id: nid, iter: null });
      }
    }
  }

  return null;  // acyclic
}

/**
 * Check if adding a proposed power connection would create a cycle.
 * We only need to test reachability: is there already a path from
 * `toUnitId` back to `fromUnitId` in the existing power graph?
 * If yes, the new edge fromUnitId â†’ toUnitId closes a cycle.
 *
 * @param {string} fromUnitId - Source unit of the proposed connection
 * @param {string} toUnitId   - Target unit of the proposed connection
 * @param {Array}  connections - Existing connections
 * @param {Map}    units       - Scene units
 * @returns {boolean} true if the proposed connection would create a power cycle
 */
function wouldCreatePowerCycle(fromUnitId, toUnitId, connections, units) {
  if (fromUnitId === toUnitId) return true;  // self-loop

  // Build adjacency list from existing power connections
  const adj = new Map();
  for (const c of connections) {
    const fromU = units.get(c.from.unitId);
    if (!fromU) continue;
    const defFrom = UnitRegistry.get(fromU.defId);
    const pFrom   = defFrom.ports.find(p => p.portId === c.from.portId);
    if (!pFrom || !isPowerStreamType(pFrom.type)) continue;

    if (!adj.has(c.from.unitId)) adj.set(c.from.unitId, new Set());
    adj.get(c.from.unitId).add(c.to.unitId);
  }

  // BFS/DFS from toUnitId looking for fromUnitId
  const visited = new Set();
  const queue = [toUnitId];
  visited.add(toUnitId);

  while (queue.length > 0) {
    const cur = queue.shift();
    const neighbours = adj.get(cur);
    if (!neighbours) continue;
    for (const nid of neighbours) {
      if (nid === fromUnitId) return true;   // cycle would be closed
      if (!visited.has(nid)) {
        visited.add(nid);
        queue.push(nid);
      }
    }
  }
  return false;
}

/* =========================
   SOLVER
   Successive substitution for flowsheet calculations
   ========================= */
function solveScene(scene) {
  const MAX_ITER = 50;
  let iter = 0;
  let changed = true;

  // Initialize runtime data for all units
  scene.runtime.unitData.clear();
  for (const [id, u] of scene.units) {
    scene.runtime.unitData.set(id, {
      ports: {},
      last: {},
      errors: []
    });

    // [v4.5.7] Wipe all transient solver state from the unit object.
    // These _-prefixed properties are cross-step communication channels
    // (written by Steps B/C/D/E, read by tick functions). They MUST NOT
    // survive across solves â€” a unit that was hub-fed last solve but is
    // now direct-connected would otherwise keep stale curtailment factors,
    // demand values, or actual-draw overrides from the previous topology.
    delete u._hubAllocFactor;   // Step C â†’ Motor/EH tick: per-consumer curtailment
    delete u._hubAllocated_W;   // Step C â†’ diagnostic: allocated watts
    delete u._hubDemand_W;      // Step C/D â†’ Battery/Source tick: regulated demand
    delete u._actualDraw_W;     // Step D/E â†’ Battery/Source tick: actual output
    delete u._powerDemand_W;    // Step B â†’ Motor/EH tick: demand carry-forward
    delete u._hubCurtailment;   // Step C â†’ Hub display: curtailment ratio
    delete u._hubDistAvail_W;   // Step C â†’ Hub display: distributed available
    delete u._hubSurplus_W;     // Step C â†’ Hub heat calc: surplus for heat port
  }

  // [v4.3.0] Pre-solve power cycle check â€” catches cycles introduced via
  // import or test harness that bypass Scene.connect() validation.
  const powerCycle = detectPowerCycle(scene.connections, scene.units);
  if (powerCycle) {
    // Tag every unit in the cycle with a CATASTROPHIC error
    const cycleNames = powerCycle.map(uid => {
      const u = scene.units.get(uid);
      const def = u ? UnitRegistry.get(u.defId) : null;
      return u?.name || def?.name || uid;
    });
    const cycleMsg = `Power cycle detected â€” infinite energy: ${cycleNames.join(' â†’ ')}`;
    for (const uid of powerCycle) {
      const ud = scene.runtime.unitData.get(uid);
      if (ud) {
        ud.errors.push(cycleMsg);
        ud.last = ud.last || {};
        ud.last.error = {
          severity: ErrorSeverity.CATASTROPHIC,
          message: cycleMsg
        };
      }
    }
    // Short-circuit: do not iterate â€” result is meaningless with a power loop
    scene.runtime.lastSolve = { ok: false, iterations: 0, warnings: [cycleMsg] };
    scene.runtime.powerCycle = powerCycle;
    const diagnostics = diagnoseErrors(scene);
    scene.runtime.diagnostics = diagnostics;
    const maxSeverity = diagnostics.length > 0
      ? Math.max(...diagnostics.map(d => d.severity.level))
      : ErrorSeverity.CATASTROPHIC.level;
    return { ok: false, diagnostics, maxSeverity, hasErrors: true };
  }
  scene.runtime.powerCycle = null;

  // [v4.4.0] Hub-to-hub connection check â€” catches connections introduced via
  // import or test harness that bypass Scene.connect() validation.
  for (const c of scene.connections) {
    const fromU = scene.units.get(c.from.unitId);
    const toU   = scene.units.get(c.to.unitId);
    if (fromU?.defId === 'power_hub' && toU?.defId === 'power_hub') {
      const msg = 'Hub-to-hub connection not supported â€” demand and curtailment cannot propagate between hubs. Use a motor or converter between hubs.';
      for (const uid of [c.from.unitId, c.to.unitId]) {
        const ud = scene.runtime.unitData.get(uid);
        if (ud) {
          ud.errors.push(msg);
          ud.last = ud.last || {};
          ud.last.error = { severity: ErrorSeverity.MAJOR, message: msg };
        }
      }
      scene.runtime.lastSolve = { ok: false, iterations: 0, warnings: [msg] };
      const diagnostics = diagnoseErrors(scene);
      scene.runtime.diagnostics = diagnostics;
      const maxSeverity = diagnostics.length > 0
        ? Math.max(...diagnostics.map(d => d.severity.level))
        : ErrorSeverity.MAJOR.level;
      return { ok: false, diagnostics, maxSeverity, hasErrors: true };
    }
  }

  // Iterative successive substitution
  while (changed && iter < MAX_ITER) {
    changed = false;
    iter++;

    for (const [id, u] of scene.units) {
      const def = UnitRegistry.get(u.defId);
      if (!def.tick) continue;

      const ud = scene.runtime.unitData.get(id);
      const inPorts = {};

      // FIX 3: Reset transient state before each tick to prevent stale data
      // This ensures no diagnostics or power demand carries across iterations
      ud.errors = [];           // Clear errors from previous iteration
      u.last = {};              // Clear unit-specific calculation results
      u.powerDemand = 0;        // Reset power demand (will be recalculated)
      u.heatDemand = 0;         // Reset heat demand (will be recalculated)
      ud.last = {};             // Clear runtime diagnostics
      ud.powerDemand = 0;       // Clear runtime power demand
      ud.heatDemand = 0;        // Clear runtime heat demand

      // Gather input streams from connections
      for (const p of def.ports) {
        if (p.dir === PortDir.IN) {
          if (p.multiConnect) {
            // MultiConnect port: merge all connected streams into one
            const conns = scene.connections.filter(
              c => c.to.unitId === id && c.to.portId === p.portId
            );
            if (conns.length === 0) {
              inPorts[p.portId] = null;
            } else {
              // Merge electrical streams: sum capacity and actual
              let totalCapacity = 0;
              let totalActual = 0;
              for (const conn of conns) {
                const fromUD = scene.runtime.unitData.get(conn.from.unitId);
                const stream = fromUD?.ports?.[conn.from.portId];
                if (stream) {
                  totalCapacity += stream.capacity ?? stream.available ?? 0;
                  totalActual += stream.actual ?? stream.available ?? 0;
                }
              }
              inPorts[p.portId] = {
                type: p.type,
                capacity: totalCapacity,
                actual: totalActual,
                available: totalCapacity,  // deprecated alias for capacity
                demand: 0,
                _sourceCount: conns.length  // diagnostic: how many sources
              };
            }
          } else {
            // Standard single-connect port
            const conn = scene.connections.find(
              c => c.to.unitId === id && c.to.portId === p.portId
            );
            if (conn) {
              const fromUD = scene.runtime.unitData.get(conn.from.unitId);
              inPorts[p.portId] = fromUD?.ports?.[conn.from.portId] || null;
            } else {
              inPorts[p.portId] = null;
            }
          }
        }
      }

      // Store old state to detect changes (strip demand â€” backward annotation)
      const oldPortsSnap = stripDemandFromPorts(ud.ports);

      // Execute unit calculation
      def.tick(u, inPorts, u.params);

      // Perform flash calculations through thermo adapter (single entrypoint)
      // Choose flash method based on stream specification
      for (const p of def.ports) {
        if (p.dir === PortDir.OUT && p.type === StreamType.MATERIAL) {
          const stream = inPorts[p.portId];
          if (stream && stream.n) {
            // Skip flash for zero-flow streams (e.g. a splitter outlet at 0%)
            const nTotal = Object.values(stream.n).reduce((a, b) => a + b, 0);
            if (nTotal < 1e-15) {
              stream.phase = 'V';
              stream.beta = 1;
              stream.vaporFraction = 1;
              stream.x = {};
              stream.y = {};
              stream.nV = {};
              stream.nL = {};
              stream.Hdot_J_s = 0;
              // Assign a default T if not set
              if (!stream.T) stream.T = 298.15;
            } else {
            try {
              let result;
              
              // Choose flash method based on what's specified
              if (stream.H_target_Jps !== undefined && stream.H_target_Jps !== null) {
                // PH FLASH: Enthalpy is specified, solve for T
                result = thermo.phFlash(stream, stream.H_target_Jps);
                
                // Write back solved temperature
                stream.T = result.T_K;
                
              } else {
                // TP FLASH: Temperature is specified
                result = thermo.tpFlash(stream);
              }
              
              // Augment stream with flash results
              stream.phase = result.phase;
              stream.vaporFraction = result.vaporFraction || result.beta;
              stream.beta = result.beta;
              stream.x = result.x;
              stream.y = result.y;
              stream.nV = result.nV;
              stream.nL = result.nL;
              
              // Store any flash warnings
              if (result.warning) {
                if (!ud.errors) ud.errors = [];
                ud.errors.push(`${p.portId}: ${result.warning}`);
              }
              
              // Compute enthalpy immediately after flash
              thermo.computeStreamEnthalpy(stream);
              
            } catch (err) {
              ud.errors.push(`Flash failed on ${p.portId}: ${err.message}`);
            }
            } // end else (nTotal > 0)
          }
        }
      }

      // Store output streams and validate types
      for (const p of def.ports) {
        if (p.dir === PortDir.OUT) {
          const stream = inPorts[p.portId];
          ud.ports[p.portId] = stream;
          
          // Validate stream type matches port type
          if (stream && !validateStreamType(stream, p.type)) {
            ud.errors.push(`Port ${p.portId}: stream type mismatch`);
          }
        }
      }

      // Check if anything changed (forward computation only)
      // Exclude 'demand' field from comparison â€” it's a backward annotation
      // written by post-processing, not a forward computation result.
      // Including it causes infinite oscillation (tick resets to 0, post-pass restores).
      const newPortsSnap = stripDemandFromPorts(ud.ports);
      if (portsChanged(oldPortsSnap, newPortsSnap)) changed = true;

      // Store unit-specific calculation results
      ud.last = u.last || {};
    }
    
    // â”€â”€ Demand rollup (inside loop for convergence) â”€â”€
    
    // Step A: Copy demand values from unit calculations into runtime data
    for (const [_id, _u] of scene.units) {
      const _ud = scene.runtime.unitData.get(_id);
      _ud.powerDemand = _u.powerDemand || 0;
      _ud.heatDemand = _u.heatDemand || 0;
    }
    
    // Step B: Propagate demand through power conversion units
    // Motor:          downstream powerDemand â†’ electrical demand (Ã· Î·)
    // Electric heater: downstream heatDemand  â†’ electrical demand (Ã· Î·)
    // IMPORTANT: Do NOT overwrite W_elec_W / W_mech_W (actual throughput from tick).
    //            Store demand as separate fields for hub to read.
    for (const [_id, _u] of scene.units) {
      const _def = UnitRegistry.get(_u.defId);
      const _ud = scene.runtime.unitData.get(_id);
      
      // def.category is a string (stored as .name by register()) â€” compare with .name
      if (_def.category === UnitCategories.POWER_CONVERSION.name) {
        const outConns = scene.connections.filter(c => c.from.unitId === _id);
        
        if (_u.defId === 'motor') {
          let downstreamDemand = 0;
          for (const conn of outConns) {
            const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
            if (consumerUD) downstreamDemand += consumerUD.powerDemand || 0;
          }
          const eta = _u.params.eta || 0.95;
          _ud.powerDemand = downstreamDemand / eta;  // Hub reads this
          _ud.last.W_mech_demand_W = downstreamDemand;
          _ud.last.W_elec_demand_W = _ud.powerDemand;
          // Carry forward for curtailment-aware tick on next iteration
          _u._powerDemand_W = _ud.powerDemand;
          
          for (const p of _def.ports) {
            if (p.dir === PortDir.OUT && _ud.ports[p.portId]) {
              _ud.ports[p.portId].demand = downstreamDemand;
            }
          }
        }
        
        if (_u.defId === 'electric_heater') {
          let downstreamHeat = 0;
          for (const conn of outConns) {
            const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
            if (consumerUD) downstreamHeat += consumerUD.heatDemand || 0;
          }
          const eta = 1.00;  // Resistance heater â€” always 100%
          _ud.powerDemand = downstreamHeat / eta;  // Hub reads this
          _ud.last.Q_heat_demand_W = downstreamHeat;
          _ud.last.W_elec_demand_W = _ud.powerDemand;
          // Carry forward for curtailment-aware tick on next iteration
          _u._powerDemand_W = _ud.powerDemand;
          
          for (const p of _def.ports) {
            if (p.dir === PortDir.OUT && _ud.ports[p.portId]) {
              _ud.ports[p.portId].demand = downstreamHeat;
            }
          }
        }
      }
    }
    
    // Step C: Hub balancing â€” compute dispatch, curtailment, surplus
    for (const [_id, _u] of scene.units) {
      if (_u.defId !== 'power_hub') continue;
      
      const _ud = scene.runtime.unitData.get(_id);
      
      // â”€â”€ Classify sources on elec_in â”€â”€
      const inConns = scene.connections.filter(
        c => c.to.unitId === _id && c.to.portId === 'elec_in'
      );
      let fixedSupply_W = 0;
      let batteryMax_W = 0;
      const sources = [];
      
      for (const conn of inConns) {
        const srcU  = scene.units.get(conn.from.unitId);
        const srcUD = scene.runtime.unitData.get(conn.from.unitId);
        const avail = srcUD?.ports?.[conn.from.portId]?.capacity ?? srcUD?.ports?.[conn.from.portId]?.available ?? 0;
        const isBattery = srcU?.defId === 'battery';
        
        sources.push({ conn, srcU, srcUD, avail, isBattery });
        if (isBattery) batteryMax_W += avail;
        else fixedSupply_W += avail;
      }
      
      // â”€â”€ Build consumer list from elec_out connections â”€â”€
      const outConns = scene.connections.filter(
        c => c.from.unitId === _id && c.from.portId === 'elec_out'
      );
      const consumers = [];
      let totalDemand_W = 0;
      for (const conn of outConns) {
        const consumerU = scene.units.get(conn.to.unitId);
        const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
        const demand_W = consumerUD?.powerDemand || 0;
        const priority = consumerU?.params?.hubPriority ?? 1;
        consumers.push({ unitId: conn.to.unitId, demand_W, priority });
        totalDemand_W += demand_W;
      }
      
      // â”€â”€ Battery dispatch: fixed first, batteries fill gap â”€â”€
      const gap_W = Math.max(0, totalDemand_W - fixedSupply_W);
      const batteryDraw_W = Math.min(gap_W, batteryMax_W);
      const totalSupply_W = fixedSupply_W + batteryDraw_W;
      
      // â”€â”€ Per-consumer allocation â”€â”€
      const consumerAllocation = allocatePower(consumers, totalSupply_W);
      
      // Global curtailment factor (summary for port-level backward compatibility)
      let curtailmentFactor = 1.0;
      if (totalDemand_W > 0 && totalSupply_W < totalDemand_W) {
        curtailmentFactor = totalSupply_W / totalDemand_W;
      }
      
      // Write per-consumer allocation factors on each consumer unit
      for (const conn of outConns) {
        const consumerU = scene.units.get(conn.to.unitId);
        const alloc = consumerAllocation[conn.to.unitId];
        if (consumerU && alloc) {
          consumerU._hubAllocFactor = alloc.factor;
          consumerU._hubAllocated_W = alloc.allocated_W;
        }
      }
      
      // â”€â”€ Surplus: fixed sources always produce, excess â†’ heat â”€â”€
      // Batteries are demand-responsive so they never overproduce.
      const surplus_W = Math.max(0, fixedSupply_W - totalDemand_W);
      
      // â”€â”€ Update output ports â”€â”€
      const stripDemand = (s) => { if (!s) return s; const { demand, ...rest } = s; return rest; };
      const oldHubPorts = {
        elec_out: stripDemand(_ud.ports.elec_out),
        heat_out: stripDemand(_ud.ports.heat_out)
      };
      
      if (_ud.ports.elec_out) {
        _ud.ports.elec_out.capacity = fixedSupply_W + batteryMax_W;  // total potential
        _ud.ports.elec_out.actual = totalSupply_W;                   // after dispatch
        _ud.ports.elec_out.available = totalSupply_W;                // deprecated alias
        _ud.ports.elec_out.curtailmentFactor = curtailmentFactor;
        _ud.ports.elec_out.demand = totalDemand_W;
      }
      if (_ud.ports.heat_out) {
        _ud.ports.heat_out.capacity = surplus_W;
        _ud.ports.heat_out.actual = surplus_W;
        _ud.ports.heat_out.available = surplus_W;  // deprecated alias
      }
      
      const newHubPorts = {
        elec_out: stripDemand(_ud.ports.elec_out),
        heat_out: stripDemand(_ud.ports.heat_out)
      };
      if (portsChanged(oldHubPorts, newHubPorts)) changed = true;
      
      // â”€â”€ Demand writeback to sources on elec_in â”€â”€
      for (const src of sources) {
        if (!src.srcUD || !src.srcUD.ports[src.conn.from.portId]) continue;
        
        if (src.isBattery) {
          // Battery: proportional share of batteryDraw (hub shields from excess)
          const share = batteryMax_W > 0 ? src.avail / batteryMax_W : 0;
          const thisDemand = batteryDraw_W * share;
          const thisActual = thisDemand;  // Hub regulates: battery delivers exactly what's asked
          src.srcUD.ports[src.conn.from.portId].demand = thisDemand;
          src.srcUD.ports[src.conn.from.portId].actual = thisActual;
          if (src.srcU) {
            src.srcU._hubDemand_W = thisDemand;
            src.srcU._actualDraw_W = thisActual;
          }
        } else {
          // Fixed source: demand = capacity (always producing)
          src.srcUD.ports[src.conn.from.portId].demand = src.avail;
          src.srcUD.ports[src.conn.from.portId].actual = src.avail;  // Always at capacity
          if (src.srcU) {
            src.srcU._hubDemand_W = src.avail;
            src.srcU._actualDraw_W = src.avail;
          }
        }
      }
      
      // â”€â”€ Diagnostics â”€â”€
      _ud.last.fixedSupply_W     = fixedSupply_W;
      _ud.last.batteryMax_W      = batteryMax_W;
      _ud.last.totalDemand_W     = totalDemand_W;
      _ud.last.batteryDraw_W     = batteryDraw_W;
      _ud.last.totalSupply_W     = totalSupply_W;
      _ud.last.surplus_W         = surplus_W;
      _ud.last.curtailmentFactor = curtailmentFactor;
      _ud.last.consumerAllocation = consumerAllocation;
      _u.last.fixedSupply_W      = fixedSupply_W;
      _u.last.batteryMax_W       = batteryMax_W;
      _u.last.totalDemand_W      = totalDemand_W;
      _u.last.batteryDraw_W      = batteryDraw_W;
      _u.last.totalSupply_W      = totalSupply_W;
      _u.last.surplus_W          = surplus_W;
      _u.last.curtailmentFactor  = curtailmentFactor;
      _u.last.consumerAllocation = consumerAllocation;
      
      _u._hubSurplus_W    = surplus_W;
      _u._hubDistAvail_W  = totalSupply_W;
      _u._hubCurtailment  = curtailmentFactor;
    }
    
    // Step D: Battery direct-connection demand writeback
    // For batteries NOT connected to a hub, sum downstream demands and report.
    for (const [_id, _u] of scene.units) {
      if (_u.defId !== 'battery') continue;
      
      const _ud = scene.runtime.unitData.get(_id);
      const outConns = scene.connections.filter(c => c.from.unitId === _id && c.from.portId === 'out');
      
      // Skip batteries connected to a hub (hub handles their demand)
      const connectedToHub = outConns.some(c => {
        const targetU = scene.units.get(c.to.unitId);
        return targetU && targetU.defId === 'power_hub';
      });
      if (connectedToHub) continue;
      
      // Direct connection: sum downstream consumer demands
      let downstreamDemand_W = 0;
      for (const conn of outConns) {
        const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
        if (consumerUD) downstreamDemand_W += consumerUD.powerDemand || 0;
      }
      
      const maxPower_W = _ud.ports.out?.capacity ?? _ud.ports.out?.available ?? 0;
      
      if (_ud.ports.out) {
        _ud.ports.out.demand = downstreamDemand_W;
        _ud.ports.out.actual = Math.min(downstreamDemand_W, maxPower_W);
      }
      _u._hubDemand_W = downstreamDemand_W;
      _u._actualDraw_W = Math.min(downstreamDemand_W, maxPower_W);
      
      // Report shortage if demand exceeds capacity
      if (downstreamDemand_W > maxPower_W + 1) {
        _ud.last.shortage_W = downstreamDemand_W - maxPower_W;
        _ud.last.error = {
          severity: ErrorSeverity.MINOR,
          message: `Demand exceeds capacity: ${(downstreamDemand_W/1000).toFixed(1)} kW needed, ${(maxPower_W/1000).toFixed(1)} kW available`
        };
      }
    }
  }
    
    // Step E: Actual computation for direct-connected non-battery sources
    // (source_electrical, source_mechanical not connected to a hub)
    // Batteries are handled in Step D. Hub-connected sources in Step C.
    // This ensures ALL non-material output ports carry a consistent `actual` value.
    for (const [_id, _u] of scene.units) {
      if (_u.defId !== 'source_electrical' && _u.defId !== 'source_mechanical') continue;
      
      const _ud = scene.runtime.unitData.get(_id);
      const outPortId = 'out';
      const outConns = scene.connections.filter(c => c.from.unitId === _id && c.from.portId === outPortId);
      
      // Skip sources connected to a hub (hub handles actual via Step C)
      const connectedToHub = outConns.some(c => {
        const targetU = scene.units.get(c.to.unitId);
        return targetU && targetU.defId === 'power_hub';
      });
      if (connectedToHub) continue;
      
      // Direct connection: sum downstream consumer demands
      let downstreamDemand_W = 0;
      for (const conn of outConns) {
        const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
        if (consumerUD) downstreamDemand_W += consumerUD.powerDemand || 0;
      }
      
      const capacity_W = _ud.ports[outPortId]?.capacity ?? _ud.ports[outPortId]?.available ?? 0;
      const actualDraw_W = Math.min(downstreamDemand_W, capacity_W);
      
      if (_ud.ports[outPortId]) {
        _ud.ports[outPortId].demand = downstreamDemand_W;
        _ud.ports[outPortId].actual = actualDraw_W;
      }
      _u._actualDraw_W = actualDraw_W;
    }

  // â”€â”€ Post-loop processing (only needs final converged values) â”€â”€

  // [v4.7.2] Cache resolved input ports from connections.
  // During iteration, only OUT ports are stored in ud.ports (they are the computed
  // results and drive convergence detection).  IN ports are ephemeral locals inside
  // the loop.  After convergence we walk every connection and clone each upstream
  // OUT port into the downstream unit's IN slot.  This makes ud.ports the single
  // source of truth for every port's resolved state â€” used by computeSystemBalance,
  // postFlashCheck, per-unit balance validation, properties panel, and tests.
  // Cloning prevents downstream post-processing (demand annotation, enthalpy
  // recomputation) from mutating the upstream original.
  (function cacheResolvedInputPorts() {
    // Pass 1: single-connect IN ports (one connection per port)
    for (const c of scene.connections) {
      const fromUD = scene.runtime.unitData.get(c.from.unitId);
      const toUD   = scene.runtime.unitData.get(c.to.unitId);
      if (!fromUD || !toUD) continue;

      const toDef  = UnitRegistry.get(scene.units.get(c.to.unitId)?.defId);
      const portDef = toDef?.ports?.find(p => p.portId === c.to.portId);
      if (!portDef || portDef.dir !== PortDir.IN) continue;

      // Skip multiConnect ports here â€” handled in pass 2
      if (portDef.multiConnect) continue;

      const s = fromUD.ports?.[c.from.portId];
      toUD.ports[c.to.portId] = s
        ? (typeof structuredClone === 'function' ? structuredClone(s) : JSON.parse(JSON.stringify(s)))
        : null;
    }

    // Pass 2: multiConnect IN ports (aggregate all connected sources)
    for (const [id, u] of scene.units) {
      const def = UnitRegistry.get(u.defId);
      const ud  = scene.runtime.unitData.get(id);
      if (!ud) continue;
      for (const p of def.ports) {
        if (p.dir !== PortDir.IN || !p.multiConnect) continue;
        const conns = scene.connections.filter(
          c => c.to.unitId === id && c.to.portId === p.portId
        );
        if (conns.length === 0) { ud.ports[p.portId] = null; continue; }

        let totalCapacity = 0, totalActual = 0;
        for (const conn of conns) {
          const fromUD = scene.runtime.unitData.get(conn.from.unitId);
          const stream = fromUD?.ports?.[conn.from.portId];
          if (stream) {
            totalCapacity += stream.capacity ?? stream.available ?? 0;
            totalActual   += stream.actual   ?? stream.available ?? 0;
          }
        }
        ud.ports[p.portId] = {
          type: p.type,
          capacity: totalCapacity,
          actual: totalActual,
          available: totalCapacity,
          _sourceCount: conns.length
        };
      }
    }
  })();

  // Enthalpy computation for all material streams
  for (const [id, u] of scene.units) {
    const ud = scene.runtime.unitData.get(id);
    const def = UnitRegistry.get(u.defId);
    
    for (const p of def.ports) {
      const stream = ud.ports[p.portId];
      if (stream && stream.type === StreamType.MATERIAL) {
        // Compute and store enthalpy properties
        thermo.computeStreamEnthalpy(stream);
      }
    }
  }
  
  // Post-flash checks: units that need to inspect resolved outlet phase
  // (e.g. gas turbine detecting liquid formation in exhaust)
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    if (def.postFlashCheck) {
      const ud = scene.runtime.unitData.get(id);
      def.postFlashCheck(u, ud.ports);
    }
  }
  
  // [v4.7.5] Merge u.last â†’ ud.last for all units.
  // tick() and postFlashCheck() write diagnostics to u.last (the unit model).
  // Steps B/C/D write demand rollup to ud.last (the runtime data).
  // Tests, properties panel, and balance validation all read ud.last.
  // This merge makes ud.last the single canonical source of all diagnostics.
  // Uses Object.assign so Step B/C fields already in ud.last are preserved,
  // while tick + postFlashCheck fields are added.
  for (const [id, u] of scene.units) {
    const ud = scene.runtime.unitData.get(id);
    if (u.last && typeof u.last === 'object') {
      Object.assign(ud.last, u.last);
    }
  }
  
  // [v4.6.0] Unconnected heat_out warning for power converters.
  // Motor and generator have heat loss ports that should ideally be connected
  // to a heat sink for closed energy balance. Warn if left floating.
  for (const [id, u] of scene.units) {
    if (u.defId !== 'motor' && u.defId !== 'generator') continue;
    const ud = scene.runtime.unitData.get(id);
    const Q_loss = ud.ports?.heat_out?.actual ?? 0;
    if (Q_loss < 0.01) continue;  // No loss to dissipate â†’ no warning needed
    const hasHeatConn = scene.connections.some(
      c => c.from.unitId === id && c.from.portId === 'heat_out'
    );
    if (!hasHeatConn) {
      if (!ud.last) ud.last = {};
      ud.last.heatOutWarning = {
        severity: ErrorSeverity.MINOR,
        message: `Heat loss port unconnected â€” ${(Q_loss/1000).toFixed(2)} kW dissipated to environment (connect to heat sink for closed energy balance)`
      };
    }
  }
  
  // â”€â”€ Per-unit mass and energy balance validation â”€â”€
  // [v4.7.3] Rewritten:
  //   - Category comparisons use .name strings (register() stores category.name)
  //   - Mass balance is global kg/s (reactor-compatible), not per-species mol/s
  //   - Energy balance accounts for all stream types on both IN and OUT
  //   - Boundary units (sources, sinks, power sources/sinks) are excluded â€”
  //     they are system boundary elements, not conservation volumes
  const balanceErrors = [];

  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const ud = scene.runtime.unitData.get(id);

    // Skip boundary elements â€” they don't conserve; they define the boundary.
    // NOTE: UnitRegistry.register() stores category as category.name (a string),
    // so comparisons must use UnitCategories.X.name, not the object itself.
    if (def.category === UnitCategories.SOURCE.name ||
        def.category === UnitCategories.SINK.name ||
        def.category === UnitCategories.POWER_SOURCE.name ||
        def.category === UnitCategories.POWER_MANAGEMENT.name) {
      continue;
    }

    // â”€â”€ Collect all port streams by direction â”€â”€
    const matIn = [], matOut = [];
    let W_in = 0, W_out = 0;  // All work/heat streams (J/s)

    for (const p of def.ports) {
      const stream = ud.ports[p.portId];
      if (!stream) continue;

      if (stream.type === StreamType.MATERIAL && stream.n) {
        if (p.dir === PortDir.IN) matIn.push(stream);
        else matOut.push(stream);
      } else if (stream.type === StreamType.HEAT ||
                 stream.type === StreamType.MECHANICAL ||
                 stream.type === StreamType.ELECTRICAL) {
        const power_W = stream.actual ?? stream.available ?? 0;
        if (p.dir === PortDir.IN)  W_in  += power_W;
        else                       W_out += power_W;
      }
    }

    // â”€â”€ Per-unit mass balance (global kg/s) â”€â”€
    if (matIn.length > 0 && matOut.length > 0) {
      let m_in = 0, m_out = 0;
      for (const s of matIn)  m_in  += streamMass_kgps(s);
      for (const s of matOut) m_out += streamMass_kgps(s);

      const absTol = 1e-9;   // kg/s
      const relTol = 1e-6;
      const tol = Math.max(absTol, relTol * Math.max(m_in, m_out));
      const residual = Math.abs(m_in - m_out);

      if (residual > tol) {
        const uName = u.name || def.name;
        balanceErrors.push({
          unitId: id, unitName: uName, type: 'mass',
          m_in, m_out, residual
        });
        ud.errors.push(
          `Mass imbalance: ${(m_in*1000).toFixed(4)} g/s in, ${(m_out*1000).toFixed(4)} g/s out ` +
          `(Î” = ${(residual*1e6).toFixed(2)} mg/s)`
        );
      }
    }

    // â”€â”€ Per-unit energy balance (J/s) â”€â”€
    // E_in  = Î£ Hdot(mat_in)  + Î£ W_in (elec + mech + heat)
    // E_out = Î£ Hdot(mat_out) + Î£ W_out (elec + mech + heat)
    if (matIn.length > 0 || matOut.length > 0 || W_in > 0 || W_out > 0) {
      let H_mat_in = 0, H_mat_out = 0;
      for (const s of matIn)  H_mat_in  += s.Hdot_J_s || 0;
      for (const s of matOut) H_mat_out += s.Hdot_J_s || 0;

      const E_in  = H_mat_in  + W_in;
      const E_out = H_mat_out + W_out;
      const E_residual = Math.abs(E_in - E_out);

      // Store as INFO diagnostic â€” many units have small numerical residuals
      // from Cp linearisation or PH-flash tolerance.  Only flag if > 0.1 kW.
      if (E_residual > 100) {
        if (!ud.last) ud.last = {};
        ud.last.energyBalance = {
          E_in_kW:       E_in  / 1000,
          E_out_kW:      E_out / 1000,
          H_mat_in_kW:   H_mat_in / 1000,
          H_mat_out_kW:  H_mat_out / 1000,
          W_in_kW:       W_in  / 1000,
          W_out_kW:      W_out / 1000,
          residual_kW:   E_residual / 1000
        };
      }
    }
  }
  
  // Store balance errors in runtime
  scene.runtime.balanceErrors = balanceErrors;

  // Store solve results
  const ok = !changed || iter < MAX_ITER;
  const warnings = [];
  if (!ok) warnings.push('Max iterations reached - loop may not have converged');
  if (balanceErrors.length > 0) {
    warnings.push(`${balanceErrors.length} mass balance violation(s) detected`);
  }
  
  scene.runtime.lastSolve = { ok, iterations: iter, warnings };
  
  // Diagnose errors and determine overall status
  const diagnostics = diagnoseErrors(scene);
  scene.runtime.diagnostics = diagnostics;
  
  // Determine worst severity level
  let maxSeverity = ErrorSeverity.MINOR.level;
  let hasErrors = diagnostics.length > 0;
  
  if (hasErrors) {
    maxSeverity = Math.max(...diagnostics.map(d => d.severity.level));
  }
  
  return { ok, diagnostics, maxSeverity, hasErrors };
}

// Update status indicator
function updateStatusIndicator(solveResult) {
  const indicator = document.getElementById('statusIndicator');
  const icon = indicator.querySelector('.status-icon');
  const text = indicator.querySelector('.status-text');
  const helpBtn = indicator.querySelector('.status-help');
  
  if (!solveResult) {
    // Not run yet
    indicator.style.display = 'none';
    return;
  }
  
  indicator.style.display = 'flex';
  
  // Remove all status classes
  indicator.className = 'status-indicator';
  
  if (!solveResult.ok) {
    // Convergence failure
    indicator.classList.add('critical');
    icon.textContent = 'ðŸ’¥';
    text.textContent = 'Convergence Failed';
    helpBtn.style.display = 'flex';
  } else if (!solveResult.hasErrors) {
    // Success
    indicator.classList.add('success');
    icon.textContent = 'âœ“';
    text.textContent = 'All Systems Operational';
    helpBtn.style.display = 'none';
  } else {
    // Has errors - determine severity
    const maxLevel = solveResult.maxSeverity;
    
    if (maxLevel >= ErrorSeverity.CATASTROPHIC.level) {
      indicator.classList.add('critical');
      icon.textContent = 'ðŸ’¥';
      text.textContent = 'Catastrophic Failure';
    } else if (maxLevel >= ErrorSeverity.MAJOR.level) {
      indicator.classList.add('error');
      icon.textContent = 'ðŸ”§';
      text.textContent = 'Equipment Damage';
    } else {
      indicator.classList.add('warning');
      icon.textContent = 'âš ï¸';
      text.textContent = 'Configuration Issues';
    }
    
    helpBtn.style.display = 'flex';
  }
}

// Show diagnosis dialog
function showDiagnosisDialog() {
  const diagnostics = scene.runtime.diagnostics || [];
  
  if (diagnostics.length === 0) {
    alert('No issues detected in the current simulation.');
    return;
  }
  
  // Create modal dialog
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: #1a1f2e;
    border: 2px solid #2a2f3a;
    border-radius: 16px;
    max-width: 700px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 24px;
    color: #e7e7e7;
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 20px;
    padding-bottom: 16px;
    border-bottom: 2px solid #2a2f3a;
  `;
  header.textContent = `ðŸ” Diagnosis Report (${diagnostics.length} issue${diagnostics.length > 1 ? 's' : ''})`;
  dialog.appendChild(header);
  
  // Group diagnostics by severity
  const critical = diagnostics.filter(d => d.severity.level === ErrorSeverity.CATASTROPHIC.level);
  const major = diagnostics.filter(d => d.severity.level === ErrorSeverity.MAJOR.level);
  const minor = diagnostics.filter(d => d.severity.level === ErrorSeverity.MINOR.level);
  
  const groups = [
    { name: 'CATASTROPHIC FAILURES', items: critical, color: '#ef4444', icon: 'ðŸ’¥' },
    { name: 'MAJOR DAMAGE', items: major, color: '#f97316', icon: 'ðŸ”§' },
    { name: 'WARNINGS', items: minor, color: '#fbbf24', icon: 'âš ï¸' }
  ];
  
  for (const group of groups) {
    if (group.items.length === 0) continue;
    
    const groupHeader = document.createElement('div');
    groupHeader.style.cssText = `
      font-size: 14px;
      font-weight: 700;
      color: ${group.color};
      margin: 20px 0 12px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    `;
    groupHeader.textContent = `${group.icon} ${group.name}`;
    dialog.appendChild(groupHeader);
    
    for (const diag of group.items) {
      const issueBox = document.createElement('div');
      issueBox.style.cssText = `
        background: ${group.color}11;
        border: 2px solid ${group.color};
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
      `;
      
      // Unit name
      const unitName = document.createElement('div');
      unitName.style.cssText = `
        font-weight: 700;
        font-size: 15px;
        margin-bottom: 8px;
        color: ${group.color};
      `;
      unitName.textContent = `${diag.unitName}`;
      issueBox.appendChild(unitName);
      
      // Title
      const title = document.createElement('div');
      title.style.cssText = `
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 8px;
      `;
      title.textContent = diag.title;
      issueBox.appendChild(title);
      
      // Explanation
      const explanation = document.createElement('div');
      explanation.style.cssText = `
        font-size: 13px;
        line-height: 1.5;
        opacity: 0.9;
        margin-bottom: 12px;
      `;
      explanation.textContent = diag.explanation;
      issueBox.appendChild(explanation);
      
      // Causes
      if (diag.causes && diag.causes.length > 0) {
        const causesTitle = document.createElement('div');
        causesTitle.style.cssText = `
          font-weight: 600;
          font-size: 12px;
          margin: 12px 0 6px 0;
          opacity: 0.8;
        `;
        causesTitle.textContent = 'POSSIBLE CAUSES:';
        issueBox.appendChild(causesTitle);
        
        const causesList = document.createElement('ul');
        causesList.style.cssText = `
          margin: 0;
          padding-left: 20px;
          font-size: 12px;
          line-height: 1.6;
          opacity: 0.8;
        `;
        for (const cause of diag.causes) {
          const li = document.createElement('li');
          li.textContent = cause;
          causesList.appendChild(li);
        }
        issueBox.appendChild(causesList);
      }
      
      // Fixes
      if (diag.fixes && diag.fixes.length > 0) {
        const fixesTitle = document.createElement('div');
        fixesTitle.style.cssText = `
          font-weight: 600;
          font-size: 12px;
          margin: 12px 0 6px 0;
          color: #22c55e;
        `;
        fixesTitle.textContent = 'âœ“ SUGGESTED FIXES:';
        issueBox.appendChild(fixesTitle);
        
        const fixesList = document.createElement('ul');
        fixesList.style.cssText = `
          margin: 0;
          padding-left: 20px;
          font-size: 12px;
          line-height: 1.6;
          color: #4ade80;
        `;
        for (const fix of diag.fixes) {
          const li = document.createElement('li');
          li.textContent = fix;
          fixesList.appendChild(li);
        }
        issueBox.appendChild(fixesList);
      }
      
      dialog.appendChild(issueBox);
    }
  }
  
  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.className = 'btn primary';
  closeBtn.style.cssText = `
    margin-top: 20px;
    width: 100%;
  `;
  closeBtn.onclick = () => modal.remove();
  dialog.appendChild(closeBtn);
  
  modal.appendChild(dialog);
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

/* =========================
   UI STATE
   ========================= */
const ui = {
  view: { x: 0, y: 0, w: 1056, h: 672 }, // Updated dynamically by setViewBox
  selectedUnitId: null,
  selectedConnId: null,
  pendingFrom: null, // Connection mode: {unitId, portId}
  isPanning: false,
  panStart: null,
  isDraggingUnit: false,
  dragUnitId: null,
  dragOffset: null, // {cellX, cellY} offset in grid units
  dragDefId: null,
  isHTML5Dragging: false, // Track HTML5 drag from library
  _mouseWorld: { x: 0, y: 0 }
};

/* =========================
   DOM REFERENCES
   ========================= */
const svg = document.getElementById('svg');
const ioEl = document.getElementById('io');
const propEditor = document.getElementById('propEditor');
const btnRun = document.getElementById('btnRun');
const btnAdd = document.getElementById('btnAdd');
const btnMenu = document.getElementById('btnMenu');
const btnFile = document.getElementById('btnFile');
const menuMain = document.getElementById('menuMain');
const menuFile = document.getElementById('menuFile');
const modalModels = document.getElementById('modalModels');
const modalUnits = document.getElementById('modalUnits');
const modalComponents = document.getElementById('modalComponents');
const modelsPanelEl = document.getElementById('modelsPanel');
const componentsPanelEl = document.getElementById('componentsPanel');

// Status is now managed within propEditor
let statusSection = null;
let statusContent = null;

/* =========================
   STREAM CALCULATIONS
   Helper functions for stream property calculations
   ========================= */
function calculateStreamFlowrates(stream) {
  if (!stream || stream.type !== StreamType.MATERIAL) return null;
  
  // Total molar flowrate
  const nTotal = Object.values(stream.n || {}).reduce((sum, val) => sum + val, 0);
  
  // Mass flowrate (kg/s) using thermo adapter
  const mTotal = thermo.streamMassFlow(stream);
  
  // Volumetric flowrate (mÂ³/s) â€” delegated to thermo adapter
  // (uses package-aware Z factor for vapor, density for liquid)
  const vTotal = thermo.streamVolFlow_m3ps(stream);
  
  return { nTotal, mTotal, vTotal };
}

/* =========================
   UI HELPER FUNCTIONS
   ========================= */
function setStatus(s) {
  // Create status section if it doesn't exist
  if (!statusSection) {
    const result = createCollapsibleSection('STATUS', false);
    statusSection = result.section;
    statusContent = result.content;
    
    // Append after propEditor card in the right panel
    const rightPanel = propEditor.parentNode;
    const controlsEl = rightPanel.querySelector('.controlsSection');
    if (controlsEl) {
      rightPanel.insertBefore(statusSection, controlsEl);
    } else {
      rightPanel.appendChild(statusSection);
    }
  }
  
  // Update status text
  statusContent.innerHTML = `<div class="status" style="padding:8px 0; white-space:pre-wrap; font-size:12px; opacity:0.9;">${s}</div>`;
  
  // Auto-expand on update
  const toggle = statusSection.querySelector('.sectionToggle');
  if (toggle && toggle.classList.contains('collapsed')) {
    toggle.classList.remove('collapsed');
    statusContent.classList.remove('collapsed');
  }
}

function closeMenus() {
  menuMain.classList.remove('open');
  menuFile.classList.remove('open');
}

function toggle(el) {
  el.classList.toggle('open');
}

/* =========================
   SVG HELPERS
   ========================= */
function svgEl(tag, attrs) {
  const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k, v] of Object.entries(attrs)) {
    e.setAttribute(k, String(v));
  }
  return e;
}

function clearSVG() {
  // Remove all children except <defs>
  // Find and preserve the defs element
  const defs = svg.querySelector('defs');
  
  // Remove all children
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }
  
  // Re-add defs if it existed
  if (defs) {
    svg.appendChild(defs);
  }
}

function screenToWorld(sx, sy) {
  const r = svg.getBoundingClientRect();
  const nx = (sx - r.left) / r.width;
  const ny = (sy - r.top) / r.height;
  return {
    x: ui.view.x + nx * ui.view.w,
    y: ui.view.y + ny * ui.view.h
  };
}

function worldToCell(wx, wy) {
  return {
    x: Math.floor(wx / scene.tile),
    y: Math.floor(wy / scene.tile)
  };
}

function setViewBox() {
  const rect = svg.getBoundingClientRect();
  const aspectRatio = rect.width / rect.height;
  
  // Initialize view dimensions if needed
  if (!ui.view.w || !ui.view.h) {
    const baseHeight = 672;
    ui.view.w = baseHeight * aspectRatio;
    ui.view.h = baseHeight;
  }
  
  svg.setAttribute('viewBox', `${ui.view.x} ${ui.view.y} ${ui.view.w} ${ui.view.h}`);
}

/* =========================
   PORT EDGE DETECTION
   Determines which edge of a unit a port is on
   ========================= */
function getPortEdge(port, unitDef) {
  const tolerance = 0.1; // Small tolerance for edge detection
  
  // Check if port is on left edge
  if (port.x <= tolerance) return 'left';
  
  // Check if port is on right edge
  if (port.x >= unitDef.w - tolerance) return 'right';
  
  // Check if port is on top edge
  if (port.y <= tolerance) return 'top';
  
  // Check if port is on bottom edge
  if (port.y >= unitDef.h - tolerance) return 'bottom';
  
  // Fallback: determine by which edge is closest
  const distToLeft = port.x;
  const distToRight = unitDef.w - port.x;
  const distToTop = port.y;
  const distToBottom = unitDef.h - port.y;
  
  const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
  
  if (minDist === distToLeft) return 'left';
  if (minDist === distToRight) return 'right';
  if (minDist === distToTop) return 'top';
  return 'bottom';
}

/* =========================
   RENDERING
   ========================= */
function drawGrid() {
  const g = svgEl('g', { id: 'grid' });
  const x1 = ui.view.x, y1 = ui.view.y;
  const x2 = ui.view.x + ui.view.w, y2 = ui.view.y + ui.view.h;
  const t = scene.tile;
  
  // Calculate visible grid range
  const startX = Math.floor(x1 / t) * t;
  const endX = Math.ceil(x2 / t) * t;
  const startY = Math.floor(y1 / t) * t;
  const endY = Math.ceil(y2 / t) * t;
  
  // Draw vertical lines
  for (let wx = startX; wx <= endX; wx += t) {
    g.appendChild(svgEl('line', {
      x1: wx, y1: startY,
      x2: wx, y2: endY,
      stroke: '#1e293b',
      opacity: 0.4,
      'stroke-width': 1
    }));
  }
  
  // Draw horizontal lines
  for (let wy = startY; wy <= endY; wy += t) {
    g.appendChild(svgEl('line', {
      x1: startX, y1: wy,
      x2: endX, y2: wy,
      stroke: '#1e293b',
      opacity: 0.4,
      'stroke-width': 1
    }));
  }
  
  svg.appendChild(g);
}

function drawConnections() {
  const g = svgEl('g', { id: 'connections' });
  
  // Draw existing connections
  for (const c of scene.connections) {
    const fromU = scene.units.get(c.from.unitId);
    const toU = scene.units.get(c.to.unitId);
    if (!fromU || !toU) continue;

    const fromDef = UnitRegistry.get(fromU.defId);
    const toDef = UnitRegistry.get(toU.defId);
    const fromPort = fromDef.ports.find(p => p.portId === c.from.portId);
    const toPort = toDef.ports.find(p => p.portId === c.to.portId);
    if (!fromPort || !toPort) continue;

    const fx = (fromU.x + fromPort.x) * scene.tile;
    const fy = (fromU.y + fromPort.y) * scene.tile;
    const tx = (toU.x + toPort.x) * scene.tile;
    const ty = (toU.y + toPort.y) * scene.tile;
    
    // Determine port edges for proper curve orientation
    const fromEdge = getPortEdge(fromPort, fromDef);
    const toEdge = getPortEdge(toPort, toDef);
    
    // Calculate control points perpendicular to each port's edge
    const controlOffset = 60; // Distance for control points
    
    let c1x, c1y, c2x, c2y;
    
    // From port control point (perpendicular to its edge)
    if (fromEdge === 'left') {
      c1x = fx - controlOffset;
      c1y = fy;
    } else if (fromEdge === 'right') {
      c1x = fx + controlOffset;
      c1y = fy;
    } else if (fromEdge === 'top') {
      c1x = fx;
      c1y = fy - controlOffset;
    } else { // bottom
      c1x = fx;
      c1y = fy + controlOffset;
    }
    
    // To port control point (perpendicular to its edge)
    if (toEdge === 'left') {
      c2x = tx - controlOffset;
      c2y = ty;
    } else if (toEdge === 'right') {
      c2x = tx + controlOffset;
      c2y = ty;
    } else if (toEdge === 'top') {
      c2x = tx;
      c2y = ty - controlOffset;
    } else { // bottom
      c2x = tx;
      c2y = ty + controlOffset;
    }
    
    const pathD = `M${fx},${fy} C${c1x},${c1y} ${c2x},${c2y} ${tx},${ty}`;

    // Get visual properties for this stream type
    const visuals = StreamVisuals[fromPort.type];
    const isSelected = ui.selectedConnId === c.id;
    
    // Power streams (electrical/mechanical) use dashed lines
    const isPowerStream = fromPort.type === StreamType.ELECTRICAL || 
                          fromPort.type === StreamType.MECHANICAL;

    const path = svgEl('path', {
      d: pathD,
      fill: 'none',
      stroke: isSelected ? '#60a5fa' : visuals.color,
      'stroke-width': isSelected ? 4 : 3,
      'stroke-dasharray': isPowerStream ? '8,4' : 'none',
      cursor: 'pointer'
    });

    path.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      ui.selectedConnId = c.id;
      ui.selectedUnitId = null;
      updatePropertiesPanel();
      render();
    });

    g.appendChild(path);
  }

  // Draw pending connection (during connection mode)
  if (ui.pendingFrom) {
    const u = scene.units.get(ui.pendingFrom.unitId);
    if (u) {
      const def = UnitRegistry.get(u.defId);
      const port = def.ports.find(p => p.portId === ui.pendingFrom.portId);
      if (port) {
        const fx = (u.x + port.x) * scene.tile;
        const fy = (u.y + port.y) * scene.tile;
        const mx = ui._mouseWorld.x;
        const my = ui._mouseWorld.y;
        
        const portEdge = getPortEdge(port, def);
        const controlOffset = 60;
        
        let c1x, c1y;
        if (portEdge === 'left') {
          c1x = fx - controlOffset;
          c1y = fy;
        } else if (portEdge === 'right') {
          c1x = fx + controlOffset;
          c1y = fy;
        } else if (portEdge === 'top') {
          c1x = fx;
          c1y = fy - controlOffset;
        } else { // bottom
          c1x = fx;
          c1y = fy + controlOffset;
        }
        
        const pathD = `M${fx},${fy} C${c1x},${c1y} ${mx},${my} ${mx},${my}`;
        
        const visuals = StreamVisuals[port.type];
        
        g.appendChild(svgEl('path', {
          d: pathD,
          fill: 'none',
          stroke: visuals.color,
          'stroke-width': 3,
          opacity: 0.7
        }));
      }
    }
  }

  svg.appendChild(g);
}

function drawUnits() {
  const g = svgEl('g', { id: 'units' });
  
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const wx = u.x * scene.tile;
    const wy = u.y * scene.tile;
    const ww = def.w * scene.tile;
    const wh = def.h * scene.tile;
    
    const group = svgEl('g', {});
    
    // Unit rectangle
    const rect = svgEl('rect', {
      x: wx, y: wy,
      width: ww, height: wh,
      rx: 8,
      fill: def.color,
      stroke: ui.selectedUnitId === id ? '#60a5fa' : '#1e293b',
      'stroke-width': 3,
      cursor: 'grab'
    });

    rect.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      if (ui.pendingFrom) return;
      
      // Don't start dragging existing units during HTML5 drag from library
      if (ui.isHTML5Dragging) return;
      
      ui.selectedUnitId = id;
      ui.selectedConnId = null;
      ui.isDraggingUnit = true;
      ui.dragUnitId = id;
      
      const m = screenToWorld(ev.clientX, ev.clientY);
      // Store offset in grid cell units
      ui.dragOffset = {
        cellX: (m.x / scene.tile) - u.x,
        cellY: (m.y / scene.tile) - u.y
      };
      
      
      updatePropertiesPanel();
      render();
    });

    group.appendChild(rect);

    // Unit icon - map defId to icon name with proper precedence
    let iconName = def.defId;
    if (def.defId === 'battery') {
      iconName = 'electrical';
    } else if (def.defId === 'source_mechanical') {
      iconName = 'mechanical';
    } else if (def.defId === 'source') {
      iconName = 'source';
    } else if (def.defId === 'source_electrical') {
      iconName = 'source_electrical';
    } else if (def.defId === 'sink_heat') {
      iconName = 'sink_heat';
    }
    // Other units use their defId directly (pump, compressor, valve, motor, sink, heater, hex)
    
    const ico = svgEl('use', {
      x: wx + ww / 2 - 16,
      y: wy + wh / 2 - 16,
      width: 32,
      height: 32,
      fill: '#fff',
      opacity: 0.75,
      'pointer-events': 'none'
    });
    
    // Set href with both methods for compatibility
    ico.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#ico-${iconName}`);
    ico.setAttribute('href', `#ico-${iconName}`);
    
    group.appendChild(ico);

    // Unit label (using actual unit name)
    const label = svgEl('text', {
      x: wx + ww / 2,
      y: wy + wh + 14,
      'text-anchor': 'middle',
      'font-size': 10,
      'font-weight': 700,
      fill: '#e7e7e7',
      opacity: 0.9,
      'pointer-events': 'none',
      'data-unit-id': id  // Add data attribute for updates
    });
    label.textContent = u.name || def.name;
    group.appendChild(label);

    // Ports
    for (const p of def.ports) {
      const wp = {
        x: (u.x + p.x) * scene.tile,
        y: (u.y + p.y) * scene.tile
      };
      const portId = p.portId;
      const unitId = u.id;
      
      // Get color for this stream type
      const portVisuals = StreamVisuals[p.type];

      // Port circle with color coding
      const circle = svgEl('circle', {
        cx: wp.x,
        cy: wp.y,
        r: 10,
        fill: p.dir === PortDir.OUT ? portVisuals.portColor : '#1e293b',
        stroke: portVisuals.portColor,
        'stroke-width': 2.5,
        cursor: 'pointer'
      });

      circle.addEventListener('pointerdown', (ev) => {
        ev.stopPropagation();
        const port = p;
        
        if (port.dir === PortDir.OUT && !ui.pendingFrom) {
          // Start connection mode
          ui.selectedUnitId = null;
          ui.pendingFrom = { unitId, portId };
          ui.selectedConnId = null;
          setStatus('Connect: click a compatible IN port.');
          render();
          return;
        }
        
        if (port.dir === PortDir.IN && ui.pendingFrom) {
          // Complete connection
          const id = scene.connect(ui.pendingFrom, { unitId, portId });
          setStatus(id 
            ? 'Connection added.' 
            : (scene._lastConnectError || 'Connection refused: port already connected or incompatible type.'));
          ui.pendingFrom = null;
          updatePropertiesPanel();
          render();
        }
      });

      group.appendChild(circle);

      // Directional arrow - orient based on which edge the port is on
      const portEdge = getPortEdge(p, def);
      
      if (p.dir === PortDir.OUT) {
        // OUT port: arrow points OUTWARD from unit (away from center)
        let arrowPath;
        if (portEdge === 'top') {
          // Points UP (away from unit)
          arrowPath = `M${wp.x - 3},${wp.y + 2} L${wp.x + 3},${wp.y + 2} L${wp.x},${wp.y - 4} Z`;
        } else if (portEdge === 'bottom') {
          // Points DOWN (away from unit)
          arrowPath = `M${wp.x - 3},${wp.y - 2} L${wp.x + 3},${wp.y - 2} L${wp.x},${wp.y + 4} Z`;
        } else if (portEdge === 'right') {
          // Points RIGHT (away from unit) - REVERSED
          arrowPath = `M${wp.x - 2},${wp.y - 3} L${wp.x - 2},${wp.y + 3} L${wp.x + 4},${wp.y} Z`;
        } else { // left
          // Points LEFT (away from unit) - REVERSED
          arrowPath = `M${wp.x + 2},${wp.y - 3} L${wp.x + 2},${wp.y + 3} L${wp.x - 4},${wp.y} Z`;
        }
        const arrow = svgEl('path', {
          d: arrowPath,
          fill: '#0b0e14',
          'pointer-events': 'none'
        });
        group.appendChild(arrow);
      } else {
        // IN port: arrow points INWARD to unit (toward center)
        let arrowPath;
        if (portEdge === 'top') {
          // Points DOWN (into unit)
          arrowPath = `M${wp.x - 3},${wp.y - 2} L${wp.x + 3},${wp.y - 2} L${wp.x},${wp.y + 4} Z`;
        } else if (portEdge === 'bottom') {
          // Points UP (into unit)
          arrowPath = `M${wp.x - 3},${wp.y + 2} L${wp.x + 3},${wp.y + 2} L${wp.x},${wp.y - 4} Z`;
        } else if (portEdge === 'right') {
          // Points LEFT (into unit)
          arrowPath = `M${wp.x - 4},${wp.y} L${wp.x + 2},${wp.y - 3} L${wp.x + 2},${wp.y + 3} Z`;
        } else { // left
          // Points RIGHT (into unit)
          arrowPath = `M${wp.x + 4},${wp.y} L${wp.x - 2},${wp.y - 3} L${wp.x - 2},${wp.y + 3} Z`;
        }
        const arrow = svgEl('path', {
          d: arrowPath,
          fill: portVisuals.portColor,
          'pointer-events': 'none'
        });
        group.appendChild(arrow);
      }
    }

    g.appendChild(group);
  }
  
  svg.appendChild(g);
}

function render() {
  clearSVG();
  setViewBox();
  drawGrid();
  drawConnections();
  drawUnits();
}

/* =========================
   UNIT LIBRARY
   Displayed in right panel when "Add Unit" is clicked
   ========================= */
function showUnitLibrary() {
  propEditor.innerHTML = '';
  
  // Title
  const titleDiv = el('div', { 
    class: 'unitTitle', 
    style: 'cursor:default;',
    html: 'Add Unit' 
  });
  propEditor.appendChild(titleDiv);
  
  // Subtitle
  const subtitleDiv = el('div', { 
    class: 'unitSubtitle', 
    html: 'Drag a unit onto the canvas' 
  });
  propEditor.appendChild(subtitleDiv);
  
  // Organize units by category
  const byCategory = UnitRegistry.listByCategory();
  
  for (const [categoryName, units] of Object.entries(byCategory)) {
    // Category header
    const catHeader = el('div', {
      style: 'margin-top:16px; margin-bottom:8px; font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px; opacity:0.7;'
    });
    catHeader.textContent = categoryName;
    propEditor.appendChild(catHeader);
    
    // Units grid for this category
    const grid = el('div', { 
      class: 'unitLibraryGrid'
    });
    
    for (const def of units) {
      const card = document.createElement('div');
      card.className = 'unitLibraryCard';
      card.draggable = true;
      card.innerHTML = `
        <div class="name">
          <span class="swatch" style="background:${def.color}"></span>${def.name}
        </div>
        <div class="desc">${def.defId}</div>
      `;
      
      card.addEventListener('dragstart', (ev) => {
        ui.dragDefId = def.defId;
        ui.isHTML5Dragging = true;
        ev.dataTransfer.setData('text/plain', def.defId);
        ev.dataTransfer.effectAllowed = 'copy';
      });
      
      grid.appendChild(card);
    }
    
    propEditor.appendChild(grid);
  }
}

/* =========================
   UNITS PANEL
   ========================= */
function buildUnitsPanel() {
  const panel = document.getElementById('unitsPanel');
  panel.innerHTML = '';
  
  const unitsList = models.list('units');
  const activeId = models.active.units;
  
  for (const sys of unitsList) {
    const card = el('div', {
      class: 'modelCard',
      style: `cursor:pointer; padding:12px; margin-bottom:8px; border:1px solid ${sys.id === activeId ? '#3b82f6' : '#2a2f3a'}; border-radius:8px; background:${sys.id === activeId ? '#3b82f611' : 'transparent'};`
    });
    
    card.innerHTML = `
      <div style="font-weight:700; margin-bottom:4px;">${sys.name}</div>
      <div class="small">${sys.desc}</div>
    `;
    
    card.addEventListener('click', () => {
      models.setActive('units', sys.id);
      buildUnitsPanel();
      updatePropertiesPanel();
      render();
    });
    
    panel.appendChild(card);
  }
}

/* =========================
   COMPONENTS PANEL
   ========================= */
function buildComponentsPanel() {
  const panel = document.getElementById('componentsPanel');
  panel.innerHTML = '';
  
  // Create table
  const table = el('table', { 
    style: 'width:100%; border-collapse:collapse; font-size:11px;' 
  });
  
  // Header
  const thead = el('thead', {});
  const headerRow = el('tr', {});
  ['Formula', 'Name', 'MW', 'Tc (K)', 'Pc (bar)', 'Tb (K)'].forEach(text => {
    const th = el('th', { 
      style: 'text-align:left; padding:6px 4px; border-bottom:1px solid #2a2f3a; font-weight:700; opacity:0.8;' 
    });
    th.textContent = text;
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  // Body
  const tbody = el('tbody', {});
  for (const comp of ComponentRegistry.list()) {
    const row = el('tr', { 
      style: 'border-bottom:1px solid #2a2f3a22;' 
    });
    
    const cells = [
      { text: comp.formula, bold: true },
      { text: comp.name },
      { text: comp.MW.toFixed(3) },
      { text: comp.Tc.toFixed(1) },
      { text: (comp.Pc / 100000).toFixed(2) },
      { text: comp.Tb.toFixed(1) }
    ];
    
    cells.forEach(({ text, bold }) => {
      const td = el('td', { 
        style: `padding:6px 4px; ${bold ? 'font-weight:700; font-family:ui-monospace, monospace;' : ''}` 
      });
      td.textContent = text;
      row.appendChild(td);
    });
    
    tbody.appendChild(row);
  }
  table.appendChild(tbody);
  
  panel.appendChild(table);
}

/* =========================
   MODELS PANEL
   ========================= */
function buildModelsPanel() {
  modelsPanelEl.innerHTML = '';
  
  // â”€â”€ Thermo Package Section â”€â”€
  const pkgSection = document.createElement('div');
  pkgSection.className = 'card';
  
  const pkgTitle = document.createElement('div');
  pkgTitle.className = 'models-section-title';
  pkgTitle.textContent = 'Property Package';
  pkgSection.appendChild(pkgTitle);
  
  const packages = models.list('thermo_package');
  const activePkgId = models.active.thermo_package;
  
  for (const pkg of packages) {
    const card = document.createElement('div');
    card.className = 'pkg-card' + (pkg.id === activePkgId ? ' active' : '');
    card.dataset.pkgId = pkg.id;
    
    const radio = document.createElement('div');
    radio.className = 'radio';
    
    const info = document.createElement('div');
    
    const nameRow = document.createElement('div');
    nameRow.className = 'pkg-name';
    nameRow.textContent = pkg.name;
    
    if (pkg.status && pkg.status !== 'stable') {
      const badge = document.createElement('span');
      badge.className = 'pkg-badge ' + pkg.status;
      badge.textContent = pkg.status;
      nameRow.appendChild(badge);
    }
    
    const desc = document.createElement('div');
    desc.className = 'pkg-desc';
    desc.textContent = pkg.description;
    
    info.appendChild(nameRow);
    info.appendChild(desc);
    card.appendChild(radio);
    card.appendChild(info);
    
    card.addEventListener('click', () => {
      // Activate this package
      models.setActive('thermo_package', pkg.id);
      
      // Switch the actual thermo engine
      thermo.setPackage(pkg);
      
      // Update UI
      pkgSection.querySelectorAll('.pkg-card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      
      setStatus(`Thermo package: ${pkg.name}`);
      solveScene(scene);
      updatePropertiesPanel();
      render();
    });
    
    pkgSection.appendChild(card);
  }
  
  modelsPanelEl.appendChild(pkgSection);
  
  // â”€â”€ Auxiliary Models Section â”€â”€
  const auxKinds = [
    { kind: 'hx', label: 'Heat Exchanger' },
    { kind: 'pressure_drop', label: 'Pressure Drop' }
  ];
  
  // Only show auxiliary section if there are models to show
  const hasAux = auxKinds.some(a => models.list(a.kind).length > 0);
  if (hasAux) {
    const auxSection = document.createElement('div');
    auxSection.className = 'card';
    auxSection.style.marginTop = '10px';
    
    const auxTitle = document.createElement('div');
    auxTitle.className = 'models-section-title';
    auxTitle.textContent = 'Auxiliary Models';
    auxSection.appendChild(auxTitle);
    
    for (const { kind, label } of auxKinds) {
      const items = models.list(kind);
      if (items.length === 0) continue;
      
      const row = document.createElement('div');
      row.className = 'row';
      
      const lab = document.createElement('label');
      lab.textContent = label;
      
      const sel = document.createElement('select');
      for (const m of items) {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.name;
        opt.title = m.desc || '';
        sel.appendChild(opt);
      }
      sel.value = models.active[kind];
      
      sel.addEventListener('change', () => {
        models.setActive(kind, sel.value);
        setStatus(`Model changed: ${label} â†’ ${sel.options[sel.selectedIndex].text}`);
        solveScene(scene);
        updatePropertiesPanel();
        render();
      });
      
      row.appendChild(lab);
      row.appendChild(sel);
      auxSection.appendChild(row);
    }
    
    modelsPanelEl.appendChild(auxSection);
  }
}

/* =========================
   COMPONENTS PANEL
   Displays all registered components and their properties
   ========================= */
function buildComponentsPanel() {
  componentsPanelEl.innerHTML = '';
  
  const components = ComponentRegistry.list();
  
  if (components.length === 0) {
    componentsPanelEl.innerHTML = '<div style="padding:20px; opacity:0.6;">No components registered</div>';
    return;
  }
  
  // Validation summary button
  const validationBtn = el('button', {
    class: 'btn',
    style: 'margin-bottom: 12px; width: 100%;',
    html: 'ðŸ” Validate Component Database'
  });
  
  validationBtn.addEventListener('click', () => {
    const results = ComponentRegistry.validateAll();
    showValidationReport(results);
  });
  
  componentsPanelEl.appendChild(validationBtn);
  
  // Create table
  const table = el('table', { 
    style: 'width:100%; border-collapse:collapse; font-size:12px;'
  });
  
  // Header
  const thead = el('thead');
  const headerRow = el('tr', { 
    style: 'background:#1e293b; position:sticky; top:0; z-index:1;'
  });
  
  const headerCells = [
    'Formula',
    'Name',
    'MW',
    'Tc',
    'Pc',
    'Ï‰',
    'Tb',
    'Phase',
    'Details'
  ];
  
  for (const label of headerCells) {
    headerRow.appendChild(el('th', {
      style: 'padding:8px; text-align:left; border-bottom:2px solid #2a2f3a; font-weight:700; font-size:11px; text-transform:uppercase; letter-spacing:0.5px;',
      html: label
    }));
  }
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  // Body
  const tbody = el('tbody');
  
  for (const comp of components) {
    const row = el('tr', {
      style: 'border-bottom:1px solid #2a2f3a; cursor:pointer; transition:background 0.15s;'
    });
    
    row.addEventListener('mouseenter', () => {
      row.style.background = '#1e293b';
    });
    row.addEventListener('mouseleave', () => {
      row.style.background = 'transparent';
    });
    
    // Formula (bold)
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-weight:700; color:#60a5fa;',
      html: comp.formula
    }));
    
    // Name
    row.appendChild(el('td', {
      style: 'padding:10px 8px;',
      html: comp.name
    }));
    
    // MW
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.MW.toFixed(3)
    }));
    
    // Tc
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.Tc.toFixed(1) + ' K'
    }));
    
    // Pc
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: (comp.Pc / 100000).toFixed(2) + ' bar'
    }));
    
    // omega
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.omega.toFixed(3)
    }));
    
    // Tb
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.Tb.toFixed(1) + ' K'
    }));
    
    // Phase at 298K
    row.appendChild(el('td', {
      style: 'padding:10px 8px;',
      html: comp.phase298
    }));
    
    // Details button
    const detailsBtn = el('button', {
      class: 'btn',
      style: 'padding:4px 8px; font-size:11px; margin:0;',
      html: 'View'
    });
    
    detailsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      showComponentDetails(comp);
    });
    
    const td = el('td', { style: 'padding:10px 8px;' });
    td.appendChild(detailsBtn);
    row.appendChild(td);
    
    tbody.appendChild(row);
  }
  
  table.appendChild(tbody);
  componentsPanelEl.appendChild(table);
}

function showComponentDetails(comp) {
  // Create modal dialog
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: #1a1f2e;
    border: 2px solid #2a2f3a;
    border-radius: 16px;
    max-width: 800px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 24px;
    color: #e7e7e7;
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 8px;
    color: #60a5fa;
  `;
  header.textContent = `${comp.formula} â€” ${comp.name}`;
  dialog.appendChild(header);
  
  // CAS number
  if (comp.CAS) {
    const cas = document.createElement('div');
    cas.style.cssText = `
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 20px;
    `;
    cas.textContent = `CAS: ${comp.CAS}`;
    dialog.appendChild(cas);
  }
  
  // Properties grid
  const grid = document.createElement('div');
  grid.style.cssText = `
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 20px;
  `;
  
  function addProperty(label, value, unit = '') {
    if (value === null || value === undefined) return;
    
    const prop = document.createElement('div');
    prop.style.cssText = `
      background: #0f1419;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
    `;
    
    const labelEl = document.createElement('div');
    labelEl.style.cssText = `
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.7;
      margin-bottom: 6px;
    `;
    labelEl.textContent = label;
    prop.appendChild(labelEl);
    
    const valueEl = document.createElement('div');
    valueEl.style.cssText = `
      font-size: 15px;
      font-family: monospace;
    `;
    
    if (typeof value === 'object') {
      valueEl.textContent = JSON.stringify(value, null, 2);
      valueEl.style.fontSize = '12px';
      valueEl.style.whiteSpace = 'pre';
    } else {
      valueEl.textContent = value + (unit ? ' ' + unit : '');
    }
    
    prop.appendChild(valueEl);
    grid.appendChild(prop);
  }
  
  addProperty('Molecular Weight', comp.MW.toFixed(3), 'g/mol');
  addProperty('Critical Temperature', comp.Tc.toFixed(2), 'K');
  addProperty('Critical Pressure', (comp.Pc / 100000).toFixed(3), 'bar');
  addProperty('Acentric Factor', comp.omega.toFixed(3));
  addProperty('Normal Boiling Point', comp.Tb.toFixed(2), 'K');
  addProperty('Phase at 298K', comp.phase298);
  
  if (comp.Tm) addProperty('Melting Point', comp.Tm.toFixed(2), 'K');
  if (comp.Vc) addProperty('Critical Volume', (comp.Vc * 1e6).toFixed(2), 'cmÂ³/mol');
  if (comp.Zc) addProperty('Critical Z-factor', comp.Zc.toFixed(3));
  if (comp.Hv) addProperty('Heat of Vaporization', (comp.Hv / 1000).toFixed(1), 'kJ/mol');
  
  dialog.appendChild(grid);
  
  // Antoine coefficients (if present)
  if (comp.antoine) {
    const antoineSection = document.createElement('div');
    antoineSection.style.cssText = `
      background: #0f1419;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      margin-bottom: 12px;
    `;
    
    const title = document.createElement('div');
    title.style.cssText = `
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 8px;
      color: #fbbf24;
    `;
    title.textContent = 'Antoine Coefficients';
    antoineSection.appendChild(title);
    
    const equation = document.createElement('div');
    equation.style.cssText = `
      font-family: monospace;
      font-size: 12px;
      margin-bottom: 12px;
      padding: 8px;
      background: #1e293b;
      border-radius: 4px;
    `;
    equation.textContent = 'logâ‚â‚€(Psat[mmHg]) = A - B/(C + T[Â°C])';
    antoineSection.appendChild(equation);
    
    // Handle both single-range and multi-range Antoine
    const antoineRanges = Array.isArray(comp.antoine) ? comp.antoine : [comp.antoine];
    
    antoineRanges.forEach((range, idx) => {
      // For multi-range, add range header
      if (antoineRanges.length > 1) {
        const rangeHeader = document.createElement('div');
        rangeHeader.style.cssText = `
          font-size: 11px;
          font-weight: 600;
          margin-top: ${idx > 0 ? '12px' : '0'};
          margin-bottom: 6px;
          color: #94a3b8;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        `;
        rangeHeader.textContent = range.desc || `Range ${idx + 1}`;
        antoineSection.appendChild(rangeHeader);
      }
      
      const coeffs = document.createElement('div');
      coeffs.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        font-family: monospace;
        font-size: 12px;
      `;
      
      coeffs.innerHTML = `
        <div><strong>A:</strong> ${range.A.toFixed(5)}</div>
        <div><strong>B:</strong> ${range.B.toFixed(2)}</div>
        <div><strong>C:</strong> ${range.C.toFixed(2)}</div>
      `;
      antoineSection.appendChild(coeffs);
      
      if (range.Tmin || range.Tmax) {
        const rangeInfo = document.createElement('div');
        rangeInfo.style.cssText = `
          font-size: 11px;
          opacity: 0.7;
          margin-top: 6px;
        `;
        rangeInfo.textContent = `Valid: ${range.Tmin || '?'} - ${range.Tmax || '?'} K`;
        antoineSection.appendChild(rangeInfo);
      }
    });
    
    dialog.appendChild(antoineSection);
  }
  
  // Cp correlations (if present)
  if (comp.cpig) {
    const cpSection = document.createElement('div');
    cpSection.style.cssText = `
      background: #0f1419;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      margin-bottom: 12px;
    `;
    
    const title = document.createElement('div');
    title.style.cssText = `
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 8px;
      color: #22c55e;
    `;
    title.textContent = 'Ideal Gas Heat Capacity';
    cpSection.appendChild(title);
    
    const equation = document.createElement('div');
    equation.style.cssText = `
      font-family: monospace;
      font-size: 12px;
      margin-bottom: 12px;
      padding: 8px;
      background: #1e293b;
      border-radius: 4px;
    `;
    equation.textContent = 'Cp = A + BÂ·T + CÂ·TÂ² + DÂ·TÂ³ + EÂ·Tâ´  [J/(molÂ·K)]';
    cpSection.appendChild(equation);
    
    const coeffs = document.createElement('div');
    coeffs.style.cssText = `
      font-family: monospace;
      font-size: 12px;
    `;
    
    coeffs.innerHTML = `
      <div><strong>A:</strong> ${comp.cpig.A}</div>
      <div><strong>B:</strong> ${comp.cpig.B}</div>
      <div><strong>C:</strong> ${comp.cpig.C}</div>
      <div><strong>D:</strong> ${comp.cpig.D}</div>
      ${comp.cpig.E !== undefined ? `<div><strong>E:</strong> ${comp.cpig.E}</div>` : ''}
    `;
    cpSection.appendChild(coeffs);
    
    dialog.appendChild(cpSection);
  }
  
  if (comp.cpLiq) {
    const cpLiqSection = document.createElement('div');
    cpLiqSection.style.cssText = `
      background: #0f1419;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      margin-bottom: 12px;
      font-family: monospace;
      font-size: 12px;
    `;
    cpLiqSection.innerHTML = `<strong>Liquid Cp:</strong> ${typeof comp.cpLiq === 'number' ? comp.cpLiq.toFixed(1) + ' J/(molÂ·K)' : JSON.stringify(comp.cpLiq)}`;
    dialog.appendChild(cpLiqSection);
  }
  
  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.className = 'btn primary';
  closeBtn.style.cssText = `
    margin-top: 20px;
    width: 100%;
  `;
  closeBtn.onclick = () => modal.remove();
  dialog.appendChild(closeBtn);
  
  modal.appendChild(dialog);
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

function showValidationReport(results) {
  // Create modal dialog
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: #1a1f2e;
    border: 2px solid #2a2f3a;
    border-radius: 16px;
    max-width: 800px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 24px;
    color: #e7e7e7;
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 20px;
    color: #60a5fa;
  `;
  header.textContent = 'Component Database Validation Report';
  dialog.appendChild(header);
  
  // Summary
  let totalErrors = 0;
  let totalWarnings = 0;
  let validComponents = 0;
  
  for (const [formula, result] of Object.entries(results)) {
    if (result.valid) validComponents++;
    totalErrors += result.errors.length;
    totalWarnings += result.warnings.length;
  }
  
  const summary = document.createElement('div');
  summary.style.cssText = `
    background: ${totalErrors === 0 ? '#0f2d1a' : '#2d1a0f'};
    border: 2px solid ${totalErrors === 0 ? '#22c55e' : '#ef4444'};
    padding: 16px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-weight: 700;
  `;
  
  summary.innerHTML = `
    <div style="font-size: 16px; margin-bottom: 8px;">
      ${totalErrors === 0 ? 'âœ… All Components Valid' : 'âš ï¸ Validation Issues Found'}
    </div>
    <div style="font-size: 13px; opacity: 0.9;">
      ${validComponents}/${Object.keys(results).length} components valid â€¢ 
      ${totalErrors} errors â€¢ 
      ${totalWarnings} warnings
    </div>
  `;
  dialog.appendChild(summary);
  
  // Per-component results
  for (const [formula, result] of Object.entries(results)) {
    const compSection = document.createElement('div');
    compSection.style.cssText = `
      background: #0f1419;
      border: 1px solid ${result.valid ? '#2a2f3a' : '#ef4444'};
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 12px;
    `;
    
    const compHeader = document.createElement('div');
    compHeader.style.cssText = `
      font-weight: 700;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    `;
    compHeader.innerHTML = `
      <span style="color: ${result.valid ? '#22c55e' : '#ef4444'};">
        ${result.valid ? 'âœ“' : 'âœ—'}
      </span>
      <span style="color: #60a5fa;">${formula}</span>
      <span style="opacity: 0.7;">â€” ${ComponentRegistry.get(formula).name}</span>
    `;
    compSection.appendChild(compHeader);
    
    // Errors
    if (result.errors.length > 0) {
      const errorsDiv = document.createElement('div');
      errorsDiv.style.cssText = `
        margin-top: 8px;
        padding: 8px;
        background: #2d1a0f;
        border-radius: 4px;
      `;
      
      const errorsHeader = document.createElement('div');
      errorsHeader.style.cssText = `
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        color: #ef4444;
        margin-bottom: 6px;
      `;
      errorsHeader.textContent = `Errors (${result.errors.length})`;
      errorsDiv.appendChild(errorsHeader);
      
      const errorsList = document.createElement('ul');
      errorsList.style.cssText = `
        margin: 0;
        padding-left: 20px;
        font-size: 12px;
      `;
      for (const error of result.errors) {
        const li = document.createElement('li');
        li.textContent = error;
        li.style.marginBottom = '4px';
        errorsList.appendChild(li);
      }
      errorsDiv.appendChild(errorsList);
      compSection.appendChild(errorsDiv);
    }
    
    // Warnings
    if (result.warnings.length > 0) {
      const warningsDiv = document.createElement('div');
      warningsDiv.style.cssText = `
        margin-top: 8px;
        padding: 8px;
        background: #1e1a0f;
        border-radius: 4px;
      `;
      
      const warningsHeader = document.createElement('div');
      warningsHeader.style.cssText = `
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        color: #fbbf24;
        margin-bottom: 6px;
      `;
      warningsHeader.textContent = `Warnings (${result.warnings.length})`;
      warningsDiv.appendChild(warningsHeader);
      
      const warningsList = document.createElement('ul');
      warningsList.style.cssText = `
        margin: 0;
        padding-left: 20px;
        font-size: 12px;
      `;
      for (const warning of result.warnings) {
        const li = document.createElement('li');
        li.textContent = warning;
        li.style.marginBottom = '4px';
        warningsList.appendChild(li);
      }
      warningsDiv.appendChild(warningsList);
      compSection.appendChild(warningsDiv);
    }
    
    // Success message if no issues
    if (result.errors.length === 0 && result.warnings.length === 0) {
      const successMsg = document.createElement('div');
      successMsg.style.cssText = `
        font-size: 12px;
        color: #22c55e;
        margin-top: 8px;
      `;
      successMsg.textContent = 'All required properties present';
      compSection.appendChild(successMsg);
    }
    
    dialog.appendChild(compSection);
  }
  
  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.className = 'btn primary';
  closeBtn.style.cssText = `
    margin-top: 20px;
    width: 100%;
  `;
  closeBtn.onclick = () => modal.remove();
  dialog.appendChild(closeBtn);
  
  modal.appendChild(dialog);
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

/* =========================
   PROPERTIES PANEL
   ========================= */
function el(tag, attrs = {}, children = []) {
  const e = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs)) {
    if (k === 'class') e.className = v;
    else if (k === 'html') e.innerHTML = v;
    else e.setAttribute(k, v);
  }
  for (const c of children) e.appendChild(c);
  return e;
}

function addNumberEditor(container, label, get, set, step = 0.1) {
  const row = el('div', { class: 'row' });
  row.appendChild(el('label', { html: label }));
  
  const inp = el('input', { type: 'number', step: String(step) });
  inp.value = String(get() ?? '');
  inp.addEventListener('input', () => { set(Number(inp.value)); });
  
  row.appendChild(inp);
  container.appendChild(row);
}

function addSelectEditor(container, label, get, set, options) {
  const row = el('div', { class: 'row' });
  row.appendChild(el('label', { html: label }));
  
  const sel = el('select', {});
  for (const [val, txt] of options) {
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = txt;
    sel.appendChild(opt);
  }
  sel.value = get();
  sel.addEventListener('change', () => {
    set(sel.value);
    updatePropertiesPanel();
  });
  
  row.appendChild(sel);
  container.appendChild(row);
}

function createCollapsibleSection(title, isOpen = true) {
  const section = el('div', { class: 'borderedSection' });
  
  const header = el('div', { class: 'sectionHeader' });
  header.innerHTML = `
    <span>${title}</span>
    <span class="sectionToggle ${isOpen ? '' : 'collapsed'}">â–¼</span>
  `;
  
  const content = el('div', { 
    class: `sectionContent ${isOpen ? '' : 'collapsed'}` 
  });
  
  header.addEventListener('click', () => {
    const toggle = header.querySelector('.sectionToggle');
    toggle.classList.toggle('collapsed');
    content.classList.toggle('collapsed');
  });
  
  section.appendChild(header);
  section.appendChild(content);
  
  return { section, content };
}

function createCollapsibleSubSection(title, isOpen = true) {
  const section = el('div', { class: 'subSection' });
  
  const header = el('div', { class: 'subSectionHeader' });
  header.innerHTML = `
    <span>${title}</span>
    <span class="subSectionToggle ${isOpen ? '' : 'collapsed'}">â–¼</span>
  `;
  
  const content = el('div', { 
    class: `subSectionContent ${isOpen ? '' : 'collapsed'}` 
  });
  
  header.addEventListener('click', () => {
    const toggle = header.querySelector('.subSectionToggle');
    toggle.classList.toggle('collapsed');
    content.classList.toggle('collapsed');
  });
  
  section.appendChild(header);
  section.appendChild(content);
  
  return { section, content };
}

function renderStreamProperties(container, s) {
  if (!s) {
    container.appendChild(el('div', { 
      class: 'small', 
      html: 'No data available' 
    }));
    return;
  }

  const unitSys = models.getActive('units');
  const propGrid = el('div', { class: 'propGrid' });
  
  if (s.type === StreamType.MATERIAL) {
    // GROUP 1: Temperature & Pressure
    propGrid.appendChild(el('div', { 
      style: 'grid-column:1/-1; margin-top:4px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
      html: 'Conditions'
    }));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Temperature' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.temperature.from(s.T).toFixed(unitSys.temperature.decimals)}<span class="propUnit">${unitSys.temperature.symbol}</span>` 
      })
    ]));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Pressure' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.pressure.from(s.P).toFixed(unitSys.pressure.decimals)}<span class="propUnit">${unitSys.pressure.symbol}</span>` 
      })
    ]));
    
    // GROUP 2: Phase & Composition
    propGrid.appendChild(el('div', { 
      style: 'grid-column:1/-1; margin-top:12px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
      html: 'Phase & Composition'
    }));
    
    const phaseText = s.phase === 'V' ? 'Vapor' : 
                      s.phase === 'L' ? 'Liquid' : 
                      s.phase === 'VL' ? `Two-Phase (Î²=${s.vaporFraction.toFixed(3)})` : 
                      'Unknown';
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Phase' }),
      el('div', { 
        class: 'propValue', 
        style: 'font-size:12px;',
        html: phaseText
      })
    ]));
    
    // Calculate flowrates
    const flowrates = calculateStreamFlowrates(s);
    
    // Composition
    const components = Object.keys(s.n || {})
      .filter(k => s.n[k] > 1e-9)
      .sort((a, b) => s.n[b] - s.n[a]);
      
    if (components.length) {
      const compSection = el('div', { style: 'grid-column:1/-1; margin-top:6px;' });
      compSection.appendChild(el('div', { 
        class: 'propLabel', 
        html: 'Components', 
        style: 'margin-bottom:6px;' 
      }));
      
      const compWrap = el('div', { style: 'display:flex; flex-wrap:wrap; gap:4px;' });
      for (const comp of components) {
        const n = s.n[comp];
        const molFrac = flowrates.nTotal > 0 ? (n / flowrates.nTotal) : 0;
        const badge = el('div', { class: 'compBadge' });
        badge.innerHTML = `<span class="spec">${comp}</span><span class="pct">${(100 * molFrac).toFixed(1)}%</span>`;
        compWrap.appendChild(badge);
      }
      compSection.appendChild(compWrap);
      propGrid.appendChild(compSection);
    }
    
    // GROUP 3: Flowrates
    propGrid.appendChild(el('div', { 
      style: 'grid-column:1/-1; margin-top:12px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
      html: 'Flowrates'
    }));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Molar' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.molarFlow.from(flowrates.nTotal).toFixed(unitSys.molarFlow.decimals)}<span class="propUnit">${unitSys.molarFlow.symbol}</span>` 
      })
    ]));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Mass' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.massFlow.from(flowrates.mTotal).toFixed(unitSys.massFlow.decimals)}<span class="propUnit">${unitSys.massFlow.symbol}</span>` 
      })
    ]));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Volumetric' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.volumeFlow.from(flowrates.vTotal).toFixed(unitSys.volumeFlow.decimals)}<span class="propUnit">${unitSys.volumeFlow.symbol}</span>` 
      })
    ]));
    
    // GROUP 4: Enthalpy (Energy Balance)
    if (s.hMolarMix !== undefined || s.Hdot_J_s !== undefined) {
      propGrid.appendChild(el('div', { 
        style: 'grid-column:1/-1; margin-top:12px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
        html: 'Energy (Enthalpy)'
      }));
      
      if (s.hMolarMix !== undefined) {
        propGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Molar Enthalpy' }),
          el('div', { 
            class: 'propValue', 
            html: `${formatEnthalpy_kJmol(s.hMolarMix)}<span class="propUnit">kJ/mol</span>` 
          })
        ]));
      }
      
      if (s.Hdot_J_s !== undefined) {
        propGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Enthalpy Flow' }),
          el('div', { 
            class: 'propValue', 
            html: `${formatPower_kW(s.Hdot_J_s)}<span class="propUnit">kW</span>` 
          })
        ]));
      }
    }
    
  } else if (s.type === StreamType.ELECTRICAL || s.type === StreamType.MECHANICAL) {
    // Power streams: show capacity, actual, demand (internal W â†’ display kW)
    const capacity_W = s.capacity ?? s.available ?? 0;
    const actual_W = s.actual ?? s.available ?? 0;
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Capacity' }),
      el('div', { 
        class: 'propValue', 
        html: `${(capacity_W/1000).toFixed(1)}<span class="propUnit">kW</span>` 
      })
    ]));
    
    // Show actual if it differs from capacity (demand-limited)
    if (Math.abs(actual_W - capacity_W) > 1) {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Actual' }),
        el('div', { 
          class: 'propValue', 
          style: actual_W < capacity_W - 1 ? 'color:#fbbf24' : '',
          html: `${(actual_W/1000).toFixed(1)}<span class="propUnit">kW</span>` 
        })
      ]));
    }
    
    if (s.demand !== undefined) {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Demand' }),
        el('div', { 
          class: 'propValue', 
          html: `${(s.demand/1000).toFixed(1)}<span class="propUnit">kW</span>` 
        })
      ]));
      
      // Utilization bar: actual / capacity
      const util = capacity_W > 0 ? (actual_W / capacity_W) : 0;
      const bar = el('div', { class: 'bar', style: 'margin-top:8px;' });
      const fill = el('div', {});
      fill.style.width = `${clamp(util, 0, 1) * 100}%`;
      fill.style.background = util > 1.0 ? '#ef4444' : util > 0.8 ? '#f97316' : '#22c55e';
      bar.appendChild(fill);
      propGrid.appendChild(bar);
      propGrid.appendChild(el('div', { 
        class: 'kv', 
        style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
        html: `<span>0%</span><span>${(util * 100).toFixed(0)}%</span><span>100%</span>` 
      }));
    }
  } else if (s.type === StreamType.HEAT) {
    // Heat streams: show capacity, actual, demand (internal W â†’ display kW)
    const capacity_W = s.capacity ?? s.available ?? 0;
    const actual_W = s.actual ?? s.available ?? 0;
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Capacity' }),
      el('div', { 
        class: 'propValue', 
        html: `${(capacity_W/1000).toFixed(1)}<span class="propUnit">kW</span>` 
      })
    ]));
    
    // Show actual if it differs from capacity
    if (Math.abs(actual_W - capacity_W) > 1) {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Actual' }),
        el('div', { 
          class: 'propValue', 
          style: actual_W < capacity_W - 1 ? 'color:#fbbf24' : '',
          html: `${(actual_W/1000).toFixed(1)}<span class="propUnit">kW</span>` 
        })
      ]));
    }
    
    if (s.demand !== undefined && s.demand > 0) {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Demand' }),
        el('div', { 
          class: 'propValue', 
          html: `${(s.demand/1000).toFixed(1)}<span class="propUnit">kW</span>` 
        })
      ]));
      
      // Utilization bar: actual / capacity
      const util = capacity_W > 0 ? (actual_W / capacity_W) : 0;
      const bar = el('div', { class: 'bar', style: 'margin-top:8px;' });
      const fill = el('div', {});
      fill.style.width = `${clamp(util, 0, 1) * 100}%`;
      fill.style.background = util > 1.0 ? '#ef4444' : util > 0.8 ? '#f97316' : '#22c55e';
      bar.appendChild(fill);
      propGrid.appendChild(bar);
      propGrid.appendChild(el('div', { 
        class: 'kv', 
        style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
        html: `<span>0%</span><span>${(util * 100).toFixed(0)}%</span><span>100%</span>` 
      }));
    }
  }
  
  container.appendChild(propGrid);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// [v4.6.1] System Balance Report
// Walks the topology boundary (sources, sinks, unconnected heat ports)
// and computes mass + energy closure for the entire flowsheet.
// Mass is tracked in kg/s (reactor-compatible: total mass conserved even
// when species change).  Energy in watts across all stream types.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function streamMass_kgps(stream) {
  if (!stream?.n) return 0;
  let mass = 0;
  for (const [sp, n] of Object.entries(stream.n)) {
    if (n < 1e-15) continue;
    const comp = ComponentRegistry.get(sp);
    mass += n * (comp?.MW || 28) / 1000;  // mol/s Ã— g/mol Ã· 1000 = kg/s
  }
  return mass;
}

function computeSystemBalance(scene) {
  if (!scene.runtime?.unitData) return null;

  // â”€â”€ Mass balance (global, kg/s) â”€â”€
  const massInItems  = [];   // { name, mass_kgps, detail: { species: mol/s, ... } }
  const massOutItems = [];
  let totalMassIn  = 0;
  let totalMassOut = 0;

  // â”€â”€ Energy balance (W) â”€â”€
  const energyIn  = { material: 0, electrical: 0, mechanical: 0, heat: 0, items: [] };
  const energyOut = { material: 0, electrical: 0, mechanical: 0, heat: 0, dissipated: 0, items: [] };

  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const ud = scene.runtime.unitData.get(id);
    if (!ud) continue;
    const uName = u.name || def.name;

    // â”€â”€ Material source â†’ IN â”€â”€
    if (u.defId === 'source') {
      const s = ud.ports?.out;
      if (s && s.n) {
        const m = streamMass_kgps(s);
        if (m > 1e-15) {
          totalMassIn += m;
          massInItems.push({ name: uName, mass_kgps: m, detail: { ...s.n } });
        }
        const H = s.Hdot_J_s ?? thermo.getHdot_Jps(s);
        if (isFinite(H)) {
          energyIn.material += H;
          energyIn.items.push({ name: uName, type: 'material', value: H });
        }
      }
    }

    // â”€â”€ Material sink â†’ OUT â”€â”€
    if (u.defId === 'sink') {
      const s = ud.ports?.in;
      if (s && s.n) {
        const m = streamMass_kgps(s);
        if (m > 1e-15) {
          totalMassOut += m;
          massOutItems.push({ name: uName, mass_kgps: m, detail: { ...s.n } });
        }
        const H = s.Hdot_J_s ?? thermo.getHdot_Jps(s);
        if (isFinite(H)) {
          energyOut.material += H;
          energyOut.items.push({ name: uName, type: 'material', value: H });
        }
      }
    }

    // â”€â”€ Electrical / mechanical sources â†’ IN â”€â”€
    if (u.defId === 'source_electrical' || u.defId === 'source_mechanical' || u.defId === 'battery') {
      const s = ud.ports?.out;
      const W = s?.actual ?? 0;
      if (W > 0) {
        const eType = u.defId === 'source_mechanical' ? 'mechanical' : 'electrical';
        energyIn[eType] += W;
        energyIn.items.push({ name: uName, type: eType, value: W });
      }
    }

    // â”€â”€ Electrical / heat sinks â†’ OUT â”€â”€
    if (u.defId === 'sink_electrical') {
      const W = ud.last?.absorbed_W ?? ud.ports?.in?.actual ?? 0;
      if (W > 0) {
        energyOut.electrical += W;
        energyOut.items.push({ name: uName, type: 'electrical', value: W });
      }
    }
    if (u.defId === 'sink_heat') {
      const W = ud.last?.absorbed_W ?? ud.ports?.in?.actual ?? 0;
      if (W > 0) {
        energyOut.heat += W;
        energyOut.items.push({ name: uName, type: 'heat', value: W });
      }
    }
  }

  // â”€â”€ Unconnected heat_out ports â†’ dissipated OUT â”€â”€
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const ud = scene.runtime.unitData.get(id);
    if (!ud) continue;
    for (const p of def.ports) {
      if (p.portId === 'heat_out' && p.dir === PortDir.OUT) {
        const Q = ud.ports?.heat_out?.actual ?? 0;
        if (Q < 0.01) continue;
        const hasConn = scene.connections.some(
          c => c.from.unitId === id && c.from.portId === 'heat_out'
        );
        if (!hasConn) {
          const uName = u.name || def.name;
          energyOut.dissipated += Q;
          energyOut.items.push({ name: uName, type: 'dissipated', value: Q });
        }
      }
    }
  }

  // â”€â”€ Totals â”€â”€
  const massBalance = totalMassIn - totalMassOut;
  const massTol = Math.max(totalMassIn, totalMassOut) * 1e-6 + 1e-10;

  const totalEnergyIn  = energyIn.material + energyIn.electrical + energyIn.mechanical + energyIn.heat;
  const totalEnergyOut = energyOut.material + energyOut.electrical + energyOut.mechanical + energyOut.heat + energyOut.dissipated;
  const energyBalance  = totalEnergyIn - totalEnergyOut;

  return {
    mass: {
      inItems: massInItems,
      outItems: massOutItems,
      totalIn: totalMassIn,
      totalOut: totalMassOut,
      balance: massBalance,
      closed: Math.abs(massBalance) < massTol
    },
    energy: {
      in: energyIn,
      out: energyOut,
      totalIn: totalEnergyIn,
      totalOut: totalEnergyOut,
      balance: energyBalance,
      relError: totalEnergyIn !== 0 ? Math.abs(energyBalance / totalEnergyIn) : 0,
      closed: totalEnergyIn !== 0 ? Math.abs(energyBalance / totalEnergyIn) < 0.01 : Math.abs(energyBalance) < 1
    }
  };
}

function updatePropertiesPanel() {
  propEditor.innerHTML = '';
  
  // UNIT SELECTED
  if (ui.selectedUnitId) {
    const u = scene.units.get(ui.selectedUnitId);
    if (!u) {
      ui.selectedUnitId = null;
      return updatePropertiesPanel();
    }
    
    const def = UnitRegistry.get(u.defId);
    
    // Header (no border): Unit name + type + category
    const headerDiv = el('div', { class: 'unitHeader' });
    
    const titleDiv = el('div', { class: 'unitTitle' });
    const nameInput = el('input', { 
      type: 'text', 
      value: u.name || `${def.name} ${u.id.slice(-2)}` 
    });
    nameInput.addEventListener('input', () => {
      u.name = nameInput.value;
      // Update label on canvas immediately
      const label = svg.querySelector(`[data-unit-id="${u.id}"]`);
      if (label) label.textContent = u.name;
    });
    nameInput.addEventListener('blur', () => {
      if (!nameInput.value.trim()) {
        u.name = `${def.name} ${u.id.slice(-2)}`;
        nameInput.value = u.name;
      }
    });
    titleDiv.appendChild(nameInput);
    headerDiv.appendChild(titleDiv);
    
    const subtitleDiv = el('div', { 
      class: 'unitSubtitle', 
      html: `${def.defId} Â· <span style="color:${def.color}">${def.category}</span>` 
    });
    headerDiv.appendChild(subtitleDiv);
    
    propEditor.appendChild(headerDiv);

    // Bordered Section 1: Parameters (only for units with editable parameters)
    if (u.defId === 'source') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      // Build species dropdown from ComponentRegistry
      const speciesOptions = ComponentRegistry.list().map(comp => 
        [comp.formula, comp.formula]  // Display formula, value is formula
      );
      
      addSelectEditor(paramsSection.content, 'Species', 
        () => u.params.species, 
        v => u.params.species = v, 
        speciesOptions
      );
      
      // Pressure with unit conversion
      addNumberEditor(paramsSection.content, `P (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.P), 
        v => u.params.P = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      // Temperature with unit conversion
      addNumberEditor(paramsSection.content, `T (${unitSys.temperature.symbol})`, 
        () => unitSys.temperature.from(u.params.T + 273.15), 
        v => u.params.T = unitSys.temperature.to(v) - 273.15, 
        1
      );
      
      // Molar flow with unit conversion
      addNumberEditor(paramsSection.content, `á¹… (${unitSys.molarFlow.symbol})`, 
        () => unitSys.molarFlow.from(u.params.nDot), 
        v => u.params.nDot = unitSys.molarFlow.to(v), 
        0.1
      );
      
      // Phase constraint
      if (!u.params.phaseConstraint) u.params.phaseConstraint = 'V';
      addSelectEditor(paramsSection.content, 'Phase', 
        () => u.params.phaseConstraint, 
        v => u.params.phaseConstraint = v, 
        [['V', 'Vapor only'], ['L', 'Liquid only'], ['VL', 'Vapor-Liquid (flash)']]
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'battery' || u.defId === 'source_mechanical' || u.defId === 'source_electrical') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (!u.params.maxPower) u.params.maxPower = 50;
      addNumberEditor(paramsSection.content, 'Max Power (kW)', 
        () => u.params.maxPower, 
        v => u.params.maxPower = v, 
        10
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'motor') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (!u.params.eta) u.params.eta = 0.95;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'electric_heater') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      // Resistance heater â€” efficiency is always 1.00 (1st law), display only
      u.params.eta = 1.00;
      const etaRow = el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Efficiency (-)' }),
        el('div', { class: 'propValue', style: 'opacity:0.6;', html: '1.00 <span style="font-size:10px; opacity:0.7;">(fixed)</span>' })
      ]);
      paramsSection.content.appendChild(etaRow);
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'valve') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 101325;
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'pump') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 500000;
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      if (!u.params.eta) u.params.eta = 0.75;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'compressor') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 300000;
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      if (!u.params.eta) u.params.eta = 0.80;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    // Gas Turbine parameters
    if (u.defId === 'gas_turbine') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 101325;  // Default 1 atm outlet
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      if (!u.params.eta) u.params.eta = 0.88;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    // Generator parameters
    if (u.defId === 'generator') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (!u.params.eta) u.params.eta = 0.97;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    // Heater parameters
    if (u.defId === 'heater') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (u.params.T_out === undefined) u.params.T_out = 150;  // Default 150Â°C
      addNumberEditor(paramsSection.content, `T outlet setpoint (${unitSys.temperature.symbol})`, 
        () => unitSys.temperature.from(u.params.T_out + 273.15), 
        v => { u.params.T_out = unitSys.temperature.to(v) - 273.15; },
        1
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    // Two-Stream Heat Exchanger parameters
    if (u.defId === 'hex') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      const modeLabel = el('div', { 
        class: 'small', 
        style: 'margin-bottom:8px; opacity:0.8;',
        html: 'Specify approach temp OR one outlet temperature:'
      });
      paramsSection.content.appendChild(modeLabel);
      
      if (u.params.T_approach === undefined) u.params.T_approach = 10;
      addNumberEditor(paramsSection.content, 'Approach Î”T (K)', 
        () => u.params.T_approach, 
        v => { u.params.T_approach = v; u.params.T_hot_out = undefined; u.params.T_cold_out = undefined; },
        1
      );
      
      addNumberEditor(paramsSection.content, `T hot out (${unitSys.temperature.symbol})`, 
        () => u.params.T_hot_out !== undefined ? unitSys.temperature.from(u.params.T_hot_out + 273.15) : '', 
        v => { u.params.T_hot_out = unitSys.temperature.to(v) - 273.15; u.params.T_approach = 0; u.params.T_cold_out = undefined; },
        1
      );
      
      addNumberEditor(paramsSection.content, `T cold out (${unitSys.temperature.symbol})`, 
        () => u.params.T_cold_out !== undefined ? unitSys.temperature.from(u.params.T_cold_out + 273.15) : '', 
        v => { u.params.T_cold_out = unitSys.temperature.to(v) - 273.15; u.params.T_approach = 0; u.params.T_hot_out = undefined; },
        1
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'splitter') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (u.params.splitPct === undefined) u.params.splitPct = 50;
      addNumberEditor(paramsSection.content, 'Split to out1 (%)', 
        () => u.params.splitPct, 
        v => u.params.splitPct = Math.max(0, Math.min(100, v)), 
        1
      );
      
      propEditor.appendChild(paramsSection.section);
    }

    // Bordered Section 2: Properties
    const ud = scene.runtime.unitData.get(u.id);
    const propsSection = createCollapsibleSection('Properties', true);

    if (!ud) {
      propsSection.content.appendChild(el('div', { 
        class: 'small', 
        style: 'padding: 8px 0; opacity:0.6;',
        html: 'Not computed yet â€” press Run' 
      }));
    } else if (u.defId === 'sink') {
      // For sink, show incoming stream properties in Properties section
      if (ud.last && ud.last.stream) {
        renderStreamProperties(propsSection.content, ud.last.stream);
      } else {
        propsSection.content.appendChild(el('div', { 
          class: 'small', 
          style: 'padding: 8px 0; opacity:0.6;',
          html: 'No incoming stream' 
        }));
      }
    } else {
      // Check for unit-level errors first (like phase violations)
      if (ud.last && ud.last.error) {
        const err = ud.last.error;
        const sev = err.severity || ErrorSeverity.MINOR;
        
        propsSection.content.appendChild(el('div', { 
          style: `padding:12px; margin-bottom:12px; background:${sev.color}22; border:2px solid ${sev.color}; border-radius:8px;`, 
        }, [
          el('div', { 
            style: `font-size:14px; font-weight:700; color:${sev.color}; margin-bottom:4px;`,
            html: `${sev.icon} ${sev.prefix}`
          }),
          el('div', { 
            style: 'font-size:13px; opacity:0.9;',
            html: err.message
          })
        ]));
      }
      
      // [v4.7.0] Special display for Heat Exchanger (post-flash validated temperatures)
      if (u.defId === 'hex' && ud.last && ud.last.Q !== undefined) {
        const unitSys = models.getActive('units');
        const hxBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        hxBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”„ Heat Exchange' 
        }));
        const dg = el('div', { class: 'propGrid' });

        // Use actual (post-flash) temperatures if available, else tick estimates
        const Thi = ud.last.T_hot_in;
        const Tho = ud.last.T_hot_out_actual ?? ud.last.T_hot_out;
        const Tci = ud.last.T_cold_in;
        const Tco = ud.last.T_cold_out_actual ?? ud.last.T_cold_out;
        const fmtT = (T_K) => `${unitSys.temperature.from(T_K).toFixed(1)}<span class="propUnit">${unitSys.temperature.symbol}</span>`;

        dg.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'T hot in' }),
          el('div', { class: 'propValue', html: fmtT(Thi) })
        ]));
        dg.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'T hot out' }),
          el('div', { class: 'propValue', html: fmtT(Tho) })
        ]));
        dg.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'T cold in' }),
          el('div', { class: 'propValue', html: fmtT(Tci) })
        ]));
        dg.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'T cold out' }),
          el('div', { class: 'propValue', html: fmtT(Tco) })
        ]));
        dg.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Duty' }),
          el('div', { class: 'propValue', html: `${ud.last.Q.toFixed(2)}<span class="propUnit">kW</span>` })
        ]));

        const pinch = ud.last.hxPinch_K;
        if (pinch !== undefined) {
          const pinchColor = ud.last.hxCross ? '#ef4444' : (pinch < 5 ? '#f97316' : '#6ee7b7');
          dg.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Î”T min (pinch)' }),
            el('div', { class: 'propValue', style: `color:${pinchColor};`, html: `${pinch.toFixed(2)}<span class="propUnit">K</span>` })
          ]));
        }

        if (ud.last.effectiveness && ud.last.effectiveness !== 'N/A') {
          dg.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Effectiveness' }),
            el('div', { class: 'propValue', html: `${ud.last.effectiveness}<span class="propUnit">%</span>` })
          ]));
        }

        hxBox.appendChild(dg);

        // Post-flash validation warnings/errors
        if (ud.last.errors && ud.last.errors.length > 0) {
          for (const err of ud.last.errors) {
            const sev = err.severity || ErrorSeverity.MINOR;
            const bg = sev === ErrorSeverity.MAJOR ? '#7f1d1d' : '#78350f';
            const fg = sev === ErrorSeverity.MAJOR ? '#fca5a5' : '#fbbf24';
            hxBox.appendChild(el('div', { style: `margin-top:6px; padding:6px 8px; background:${bg}; border-radius:4px; font-size:11px; color:${fg};`, html: `${sev.icon || 'âš '} ${err.message}` }));
          }
        }

        propsSection.content.appendChild(hxBox);
      }
      
      // Special display for power-consuming equipment
      if ((u.defId === 'compressor' || u.defId === 'pump') && ud.last && ud.last.W_shaft !== undefined) {
        const powerBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        const unitSys = models.getActive('units');
        
        powerBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power & Pressure' 
        }));
        
        const dataGrid = el('div', { class: 'propGrid' });
        
        // Pressure setpoint vs actual
        if (ud.last.Pout_setpoint !== undefined) {
          const Pset = unitSys.pressure.from(ud.last.Pout_setpoint);
          const Pact = unitSys.pressure.from(ud.last.Pout_actual);
          const isCurt = ud.last.curtailed;
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'P setpoint' }),
            el('div', { class: 'propValue', html: `${Pset.toFixed(unitSys.pressure.decimals)}<span class="propUnit">${unitSys.pressure.symbol}</span>` })
          ]));
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'P actual' }),
            el('div', { class: 'propValue', style: isCurt ? 'color:#f97316;' : '', 
              html: `${Pact.toFixed(unitSys.pressure.decimals)}<span class="propUnit">${unitSys.pressure.symbol}</span>` })
          ]));
        }
        
        // Shaft power actual (W â†’ kW)
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Shaft power' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_shaft/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        
        // Shaft power setpoint if curtailed
        if (ud.last.curtailed && ud.last.W_shaft_setpoint !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Shaft needed' }),
            el('div', { class: 'propValue', style: 'color:#f97316;', 
              html: `${(ud.last.W_shaft_setpoint/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        }
        
        // Hydraulic/Isentropic power
        if (ud.last.W_hydraulic !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Hydraulic' }),
            el('div', { class: 'propValue', html: `${(ud.last.W_hydraulic/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        } else if (ud.last.W_isentropic !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Isentropic' }),
            el('div', { class: 'propValue', html: `${(ud.last.W_isentropic/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        }
        
        // Efficiency
        if (ud.last.eta !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Efficiency' }),
            el('div', { class: 'propValue', html: `${(ud.last.eta * 100).toFixed(0)}<span class="propUnit">%</span>` })
          ]));
        }
        
        powerBox.appendChild(dataGrid);
        propsSection.content.appendChild(powerBox);
      }
      
      // Special display for heater (setpoint vs actual)
      if (u.defId === 'heater' && ud.last && ud.last.T_setpoint_C !== undefined) {
        const unitSys = models.getActive('units');
        const heatBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        heatBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”¥ Heat Duty' 
        }));
        
        const dataGrid = el('div', { class: 'propGrid' });
        
        // T setpoint
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'T setpoint' }),
          el('div', { class: 'propValue', 
            html: `${unitSys.temperature.from(ud.last.T_setpoint_C + 273.15).toFixed(1)}<span class="propUnit">${unitSys.temperature.symbol}</span>` 
          })
        ]));
        
        // T actual (from PH flash)
        const matOut = ud.ports?.mat_out;
        if (matOut && matOut.T) {
          const T_actual_disp = unitSys.temperature.from(matOut.T);
          const T_set_disp = unitSys.temperature.from(ud.last.T_setpoint_C + 273.15);
          const deviation = Math.abs(T_actual_disp - T_set_disp);
          const devColor = deviation > 1 ? '#f97316' : '#22c55e';
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'T actual' }),
            el('div', { class: 'propValue', style: `color:${devColor};`,
              html: `${T_actual_disp.toFixed(1)}<span class="propUnit">${unitSys.temperature.symbol}</span>` 
            })
          ]));
        }
        
        // Q demand vs actual (internal W â†’ display kW)
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Q demand' }),
          el('div', { class: 'propValue', 
            html: `${(ud.last.Q_demand_W/1000).toFixed(2)}<span class="propUnit">kW</span>` 
          })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Q actual' }),
          el('div', { class: 'propValue', 
            style: ud.last.supplyLimited ? 'color:#f97316;' : '',
            html: `${(ud.last.Q_actual_W/1000).toFixed(2)}<span class="propUnit">kW</span>` 
          })
        ]));
        
        heatBox.appendChild(dataGrid);
        propsSection.content.appendChild(heatBox);
      }
      
      // Special display for motor (actual power, not capacity)
      if (u.defId === 'motor' && ud.last && ud.last.W_elec_W !== undefined) {
        const convBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        convBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power Conversion' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Electrical in' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_elec_W/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Mechanical out' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_mech_W/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Heat loss' }),
          el('div', { class: 'propValue', style: 'color:#f97316;', html: `${((ud.last.Q_loss_W||0)/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Efficiency' }),
          el('div', { class: 'propValue', html: `${ud.last.efficiency_pct}<span class="propUnit">%</span>` })
        ]));
        convBox.appendChild(dataGrid);
        if (ud.last.heatOutWarning) {
          convBox.appendChild(el('div', { style: 'margin-top:8px; padding:6px 8px; background:#78350f; border-radius:4px; font-size:11px; color:#fbbf24;', html: 'âš  ' + ud.last.heatOutWarning.message }));
        }
        propsSection.content.appendChild(convBox);
      }
      
      // Special display for electric heater (actual power, not capacity)
      if (u.defId === 'electric_heater' && ud.last) {
        const convBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        convBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power â†’ Heat' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        const Welec = (ud.last.W_elec_actual_W || 0) / 1000;
        const Qheat = (ud.last.Q_available_W || 0) / 1000;
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Electrical in' }),
          el('div', { class: 'propValue', html: `${Welec.toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Heat out' }),
          el('div', { class: 'propValue', html: `${Qheat.toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Efficiency' }),
          el('div', { class: 'propValue', html: `${ud.last.efficiency_pct}<span class="propUnit">%</span>` })
        ]));
        convBox.appendChild(dataGrid);
        propsSection.content.appendChild(convBox);
      }
      
      // Special display for Power Hub
      if (u.defId === 'power_hub' && ud.last) {
        const hubBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        hubBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power Balance' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        const fields = [
          ['Fixed supply', ud.last.fixedSupply_W, 'kW'],
          ['Battery max', ud.last.batteryMax_W, 'kW'],
          ['Battery draw', ud.last.batteryDraw_W, 'kW'],
          ['Total supply', ud.last.totalSupply_W, 'kW'],
          ['Total demand', ud.last.totalDemand_W, 'kW'],
          ['Surplus â†’ heat', ud.last.surplus_W, 'kW'],
        ];
        for (const [label, val, unit] of fields) {
          if (val === undefined) continue;
          const isHighlight = label === 'Total demand' && ud.last.curtailmentFactor < 1;
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: label }),
            el('div', { class: 'propValue', style: isHighlight ? 'color:#f97316;' : '',
              html: `${(val/1000).toFixed(2)}<span class="propUnit">${unit}</span>` })
          ]));
        }
        // Curtailment factor
        const cf = ud.last.curtailmentFactor ?? 1;
        const cfColor = cf < 1 ? '#f97316' : '#22c55e';
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Curtailment' }),
          el('div', { class: 'propValue', style: `color:${cfColor};`,
            html: `${(cf * 100).toFixed(1)}<span class="propUnit">%</span>` })
        ]));
        hubBox.appendChild(dataGrid);
        propsSection.content.appendChild(hubBox);
      }
      
      // Special display for Heat Sink
      if (u.defId === 'sink_heat' && ud.last) {
        const hBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        hBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”¥ Heat Absorbed' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Total' }),
          el('div', { class: 'propValue', html: `${((ud.last.absorbed_W || 0)/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        if ((ud.last.sourceCount || 0) > 1) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Sources' }),
            el('div', { class: 'propValue', html: `${ud.last.sourceCount}` })
          ]));
        }
        hBox.appendChild(dataGrid);
        propsSection.content.appendChild(hBox);
      }
      
      // Special display for Electrical Sink
      if (u.defId === 'sink_electrical' && ud.last) {
        const eBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        eBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Electrical Load' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Absorbed' }),
          el('div', { class: 'propValue', html: `${((ud.last.absorbed_W || 0)/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        eBox.appendChild(dataGrid);
        propsSection.content.appendChild(eBox);
      }
      
      // Special display for Battery
      if (u.defId === 'battery' && ud.last) {
        const bBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        bBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”‹ Battery Status' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Capacity' }),
          el('div', { class: 'propValue', html: `${((ud.last.maxPower_W || 0)/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        const outPort = ud.ports?.out;
        const bActual = outPort?.actual ?? outPort?.available ?? 0;
        const demand = outPort?.demand || 0;
        // Show actual draw if it differs from capacity
        if (Math.abs(bActual - (ud.last.maxPower_W || 0)) > 1) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Actual' }),
            el('div', { class: 'propValue', style: 'color:#fbbf24;',
              html: `${(bActual/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        }
        const shortage = ud.last.shortage_W;
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Demand' }),
          el('div', { class: 'propValue', style: shortage ? 'color:#f97316;' : '',
            html: `${(demand/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        if (shortage) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Shortage' }),
            el('div', { class: 'propValue', style: 'color:#ef4444;',
              html: `${(shortage/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        }
        bBox.appendChild(dataGrid);
        propsSection.content.appendChild(bBox);
      }
      
      // Special display for Fixed Power Source
      if (u.defId === 'source_electrical' && ud.last) {
        const sBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        sBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power Source' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Capacity' }),
          el('div', { class: 'propValue', html: `${((ud.last.maxPower_W || 0)/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        const srcPort = ud.ports?.out;
        const srcActual = srcPort?.actual ?? srcPort?.available ?? 0;
        if (Math.abs(srcActual - (ud.last.maxPower_W || 0)) > 1) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Actual' }),
            el('div', { class: 'propValue', style: 'color:#fbbf24;',
              html: `${(srcActual/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        }
        sBox.appendChild(dataGrid);
        propsSection.content.appendChild(sBox);
      }
      
      // Special display for Gas Turbine
      if (u.defId === 'gas_turbine' && ud.last && ud.last.W_shaft !== undefined) {
        const unitSys = models.getActive('units');
        const tBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        tBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš™ï¸ Turbine Performance' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        
        // Pressures
        if (ud.last.Pin !== undefined) {
          const Pdisp = unitSys.pressure.from(ud.last.Pin);
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'P inlet' }),
            el('div', { class: 'propValue', html: `${Pdisp.toFixed(unitSys.pressure.decimals)}<span class="propUnit">${unitSys.pressure.symbol}</span>` })
          ]));
        }
        if (ud.last.Pout_actual !== undefined) {
          const Pdisp = unitSys.pressure.from(ud.last.Pout_actual);
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'P outlet' }),
            el('div', { class: 'propValue', html: `${Pdisp.toFixed(unitSys.pressure.decimals)}<span class="propUnit">${unitSys.pressure.symbol}</span>` })
          ]));
        }
        if (ud.last.ratio !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Expansion ratio' }),
            el('div', { class: 'propValue', html: `${ud.last.ratio}` })
          ]));
        }
        
        // Work output
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Shaft output' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_shaft/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        if (ud.last.W_isentropic !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Isentropic' }),
            el('div', { class: 'propValue', html: `${(ud.last.W_isentropic/1000).toFixed(2)}<span class="propUnit">kW</span>` })
          ]));
        }
        if (ud.last.eta !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Efficiency' }),
            el('div', { class: 'propValue', html: `${(ud.last.eta * 100).toFixed(0)}<span class="propUnit">%</span>` })
          ]));
        }
        
        tBox.appendChild(dataGrid);
        propsSection.content.appendChild(tBox);
      }
      
      // Special display for Generator
      if (u.defId === 'generator' && ud.last && ud.last.W_mech_W !== undefined) {
        const gBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        gBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power Generation' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Mechanical in' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_mech_W/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Electrical out' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_elec_W/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Heat loss' }),
          el('div', { class: 'propValue', style: 'color:#f97316;', html: `${((ud.last.Q_loss_W||0)/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Efficiency' }),
          el('div', { class: 'propValue', html: `${ud.last.efficiency_pct}<span class="propUnit">%</span>` })
        ]));
        gBox.appendChild(dataGrid);
        if (ud.last.heatOutWarning) {
          gBox.appendChild(el('div', { style: 'margin-top:8px; padding:6px 8px; background:#78350f; border-radius:4px; font-size:11px; color:#fbbf24;', html: 'âš  ' + ud.last.heatOutWarning.message }));
        }
        propsSection.content.appendChild(gBox);
      }
      
      // Special display for LV separator (phase split)
      if (u.defId === 'flash_drum' && ud.last && ud.last.nTotal > 0) {
        const unitSys = models.getActive('units');
        const sepBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        sepBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”¬ Phase Split' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Inlet phase' }),
          el('div', { class: 'propValue', html: ud.last.phase === 'VL' ? 'Two-Phase' : ud.last.phase === 'V' ? 'Vapor' : 'Liquid' })
        ]));
        
        if (ud.last.beta !== null && ud.last.beta !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Vapor fraction' }),
            el('div', { class: 'propValue', html: `${(ud.last.beta * 100).toFixed(1)}<span class="propUnit">%</span>` })
          ]));
        }
        
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Vapor flow' }),
          el('div', { class: 'propValue', html: `${ud.last.nV_total.toFixed(3)}<span class="propUnit">mol/s</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Liquid flow' }),
          el('div', { class: 'propValue', html: `${ud.last.nL_total.toFixed(3)}<span class="propUnit">mol/s</span>` })
        ]));
        
        // V/L split bar
        const vPct = ud.last.vap_pct || 0;
        const bar = el('div', { class: 'bar', style: 'margin-top:8px; display:flex; border-radius:4px; overflow:hidden;' });
        if (vPct > 0.1) {
          const vFill = el('div', { style: `width:${vPct}%; background:#60a5fa; height:8px;` });
          bar.appendChild(vFill);
        }
        if (vPct < 99.9) {
          const lFill = el('div', { style: `width:${100-vPct}%; background:#f472b6; height:8px;` });
          bar.appendChild(lFill);
        }
        dataGrid.appendChild(bar);
        dataGrid.appendChild(el('div', { 
          class: 'kv', 
          style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
          html: `<span style="color:#60a5fa">V ${vPct.toFixed(1)}%</span><span style="color:#f472b6">L ${(100-vPct).toFixed(1)}%</span>` 
        }));
        
        sepBox.appendChild(dataGrid);
        propsSection.content.appendChild(sepBox);
      }
      
      // Output ports
      for (const p of def.ports) {
        if (p.dir !== PortDir.OUT) continue;
        const s = ud.ports[p.portId];
        const portBox = el('div', { style: 'margin-bottom:12px;' });
        portBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:6px; opacity:0.8;', 
          html: `${p.portId}` 
        }));
        renderStreamProperties(portBox, s);
        propsSection.content.appendChild(portBox);
      }
      
      // General errors from solver
      if (ud.errors?.length) {
        propsSection.content.appendChild(el('div', { 
          class: 'small', 
          style: 'color:#ef4444; margin-top:8px; padding:8px; background:#7f1d1d22; border-radius:8px;', 
          html: `âš  ${ud.errors.join('; ')}` 
        }));
      }
      
      // Subsection: Details (inside Properties, closed by default)
      if (ud.last && Object.keys(ud.last).length) {
        const detailsSubSection = createCollapsibleSubSection('Details', false);
        
        const dataGrid = el('div', { class: 'propGrid' });
        for (const [key, value] of Object.entries(ud.last)) {
          // Skip error object (already displayed above)
          if (key === 'error') continue;
          
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: key }),
            el('div', { 
              class: 'propValue', 
              style: 'font-size:12px;', 
              html: typeof value === 'number' ? value.toFixed(3) : String(value) 
            })
          ]));
        }
        detailsSubSection.content.appendChild(dataGrid);
        propsSection.content.appendChild(detailsSubSection.section);
      }
    }

    propEditor.appendChild(propsSection.section);
    return;
  }

  // STREAM SELECTED
  if (ui.selectedConnId) {
    const c = scene.connections.find(x => x.id === ui.selectedConnId);
    if (!c) {
      ui.selectedConnId = null;
      return updatePropertiesPanel();
    }
    
    const fromU = scene.units.get(c.from.unitId);
    const toU = scene.units.get(c.to.unitId);
    
    // Header (no border): Stream title
    const headerDiv = el('div', { class: 'unitHeader' });
    
    const titleDiv = el('div', { 
      class: 'unitTitle', 
      style: 'cursor:default;',
      html: 'Stream' 
    });
    headerDiv.appendChild(titleDiv);
    
    const subtitleDiv = el('div', { 
      class: 'unitSubtitle', 
      html: `${fromU?.name || '?'} â†’ ${toU?.name || '?'}` 
    });
    headerDiv.appendChild(subtitleDiv);
    
    propEditor.appendChild(headerDiv);
    
    // Bordered Section: Properties
    const propsSection = createCollapsibleSection('Properties', true);
    
    const fromUD = scene.runtime.unitData.get(c.from.unitId);
    const s = fromUD?.ports?.[c.from.portId] || null;
    renderStreamProperties(propsSection.content, s);
    
    propEditor.appendChild(propsSection.section);
    return;
  }

  // NOTHING SELECTED â€” show system balance report
  const balance = computeSystemBalance(scene);
  
  if (!balance || (balance.mass.inItems.length === 0 && balance.energy.in.items.length === 0)) {
    const emptyDiv = el('div', { 
      class: 'small', 
      style: 'padding:40px 20px; text-align:center; opacity:0.5;',
      html: 'Click a unit or stream to inspect' 
    });
    propEditor.appendChild(emptyDiv);
    return;
  }

  // â”€â”€ Header â”€â”€
  const headerDiv = el('div', { class: 'unitHeader' });
  headerDiv.appendChild(el('div', { class: 'unitTitle' }, [
    el('span', { html: 'System Balance' })
  ]));
  headerDiv.appendChild(el('div', { 
    class: 'unitSubtitle', 
    html: 'Flowsheet boundary audit' 
  }));
  propEditor.appendChild(headerDiv);

  // â”€â”€ Mass Balance Section (global, kg/s) â”€â”€
  if (balance.mass.inItems.length > 0 || balance.mass.outItems.length > 0) {
    const massSection = createCollapsibleSection('Mass Balance', true);
    const mc = massSection.content;

    const massClosed = balance.mass.closed;
    mc.appendChild(el('div', { 
      style: `margin-bottom:10px; padding:6px 10px; border-radius:6px; font-size:12px; font-weight:600; text-align:center; background:${massClosed ? '#064e3b' : '#7f1d1d'}; color:${massClosed ? '#6ee7b7' : '#fca5a5'};`,
      html: massClosed ? 'âœ“ Mass balance closed' : `âœ— Mass balance violation: Î” = ${(balance.mass.balance * 1000).toFixed(4)} g/s`
    }));

    const tbl = el('div', { style: 'font-size:11px; font-family:monospace;' });

    // Inputs
    tbl.appendChild(el('div', { style: 'font-weight:700; opacity:0.7; padding:4px 0; text-transform:uppercase; font-size:10px;', html: 'â†’ Mass In' }));
    for (const item of balance.mass.inItems) {
      const detail = Object.entries(item.detail).map(([sp, n]) => `${sp}: ${n.toFixed(3)}`).join(', ');
      tbl.appendChild(el('div', { style: 'display:flex; justify-content:space-between; padding:2px 0;', html:
        `<span>${item.name} <span style="opacity:0.5; font-size:10px">(${detail} mol/s)</span></span><span style="font-weight:600">${(item.mass_kgps * 1000).toFixed(3)} g/s</span>`
      }));
    }

    // Outputs
    tbl.appendChild(el('div', { style: 'font-weight:700; opacity:0.7; padding:6px 0 4px; text-transform:uppercase; font-size:10px; border-top:1px solid #334155; margin-top:4px;', html: 'â† Mass Out' }));
    for (const item of balance.mass.outItems) {
      const detail = Object.entries(item.detail).map(([sp, n]) => `${sp}: ${n.toFixed(3)}`).join(', ');
      tbl.appendChild(el('div', { style: 'display:flex; justify-content:space-between; padding:2px 0;', html:
        `<span>${item.name} <span style="opacity:0.5; font-size:10px">(${detail} mol/s)</span></span><span style="font-weight:600">${(item.mass_kgps * 1000).toFixed(3)} g/s</span>`
      }));
    }

    // Totals
    tbl.appendChild(el('div', { style: 'border-top:1px solid #475569; margin-top:4px; padding-top:4px; display:flex; justify-content:space-between; font-weight:700;', html:
      `<span>Total In</span><span>${(balance.mass.totalIn * 1000).toFixed(3)} g/s</span>`
    }));
    tbl.appendChild(el('div', { style: 'display:flex; justify-content:space-between; font-weight:700;', html:
      `<span>Total Out</span><span>${(balance.mass.totalOut * 1000).toFixed(3)} g/s</span>`
    }));
    tbl.appendChild(el('div', { style: `display:flex; justify-content:space-between; font-weight:700; padding:4px 0; color:${massClosed ? '#6ee7b7' : '#fca5a5'};`, html:
      `<span>Residual</span><span>${(balance.mass.balance * 1000).toFixed(6)} g/s</span>`
    }));
    mc.appendChild(tbl);

    propEditor.appendChild(massSection.section);
  }

  // â”€â”€ Energy Balance Section â”€â”€
  if (balance.energy.in.items.length > 0 || balance.energy.out.items.length > 0) {
    const enSection = createCollapsibleSection('Energy Balance', true);
    const ec = enSection.content;

    // Status badge
    const enClosed = balance.energy.closed;
    ec.appendChild(el('div', { 
      style: `margin-bottom:10px; padding:6px 10px; border-radius:6px; font-size:12px; font-weight:600; text-align:center; background:${enClosed ? '#064e3b' : '#7f1d1d'}; color:${enClosed ? '#6ee7b7' : '#fca5a5'};`,
      html: enClosed ? 'âœ“ Energy balance closed' : `âœ— Energy balance error: ${(balance.energy.relError * 100).toFixed(2)}%`
    }));

    // â”€â”€ Inputs â”€â”€
    ec.appendChild(el('div', { style: 'font-weight:700; font-size:11px; margin:8px 0 4px; opacity:0.7; text-transform:uppercase;', html: 'â†’ Energy In' }));
    const inTbl = el('div', { style: 'font-size:11px; font-family:monospace; margin-bottom:8px;' });
    const typeColors = { material: '#60a5fa', electrical: '#facc15', mechanical: '#a78bfa', heat: '#f97316', dissipated: '#fb923c' };
    const typeLabels = { material: 'Enthalpy', electrical: 'Electrical', mechanical: 'Mechanical', heat: 'Heat', dissipated: 'Dissipated' };
    for (const item of balance.energy.in.items) {
      const c = typeColors[item.type] || '#e2e8f0';
      inTbl.appendChild(el('div', { style: `display:flex; justify-content:space-between; padding:2px 0; color:${c};`, html:
        `<span>${item.name} <span style="opacity:0.6">(${typeLabels[item.type]})</span></span><span>${(item.value/1000).toFixed(2)} kW</span>`
      }));
    }
    // Subtotals by type
    inTbl.appendChild(el('div', { style: 'border-top:1px solid #334155; margin-top:4px; padding-top:4px;' }));
    for (const type of ['material', 'electrical', 'mechanical', 'heat']) {
      const v = balance.energy.in[type];
      if (Math.abs(v) > 0.01) {
        const c = typeColors[type];
        inTbl.appendChild(el('div', { style: `display:flex; justify-content:space-between; padding:1px 0; font-weight:600; color:${c};`, html:
          `<span>Î£ ${typeLabels[type]}</span><span>${(v/1000).toFixed(2)} kW</span>`
        }));
      }
    }
    inTbl.appendChild(el('div', { style: 'display:flex; justify-content:space-between; padding:3px 0; font-weight:700; border-top:1px solid #475569;', html:
      `<span>Total In</span><span>${(balance.energy.totalIn/1000).toFixed(2)} kW</span>`
    }));
    ec.appendChild(inTbl);

    // â”€â”€ Outputs â”€â”€
    ec.appendChild(el('div', { style: 'font-weight:700; font-size:11px; margin:8px 0 4px; opacity:0.7; text-transform:uppercase;', html: 'â† Energy Out' }));
    const outTbl = el('div', { style: 'font-size:11px; font-family:monospace; margin-bottom:8px;' });
    for (const item of balance.energy.out.items) {
      const c = typeColors[item.type] || '#e2e8f0';
      outTbl.appendChild(el('div', { style: `display:flex; justify-content:space-between; padding:2px 0; color:${c};`, html:
        `<span>${item.name} <span style="opacity:0.6">(${typeLabels[item.type]})</span></span><span>${(item.value/1000).toFixed(2)} kW</span>`
      }));
    }
    outTbl.appendChild(el('div', { style: 'border-top:1px solid #334155; margin-top:4px; padding-top:4px;' }));
    for (const type of ['material', 'electrical', 'mechanical', 'heat', 'dissipated']) {
      const v = balance.energy.out[type];
      if (Math.abs(v) > 0.01) {
        const c = typeColors[type];
        outTbl.appendChild(el('div', { style: `display:flex; justify-content:space-between; padding:1px 0; font-weight:600; color:${c};`, html:
          `<span>Î£ ${typeLabels[type]}</span><span>${(v/1000).toFixed(2)} kW</span>`
        }));
      }
    }
    outTbl.appendChild(el('div', { style: 'display:flex; justify-content:space-between; padding:3px 0; font-weight:700; border-top:1px solid #475569;', html:
      `<span>Total Out</span><span>${(balance.energy.totalOut/1000).toFixed(2)} kW</span>`
    }));
    ec.appendChild(outTbl);

    // â”€â”€ Residual â”€â”€
    const residual = el('div', { style: 'display:flex; justify-content:space-between; padding:6px 8px; border-radius:6px; font-weight:700; font-size:12px; background:#1e293b;', html:
      `<span>Residual (In âˆ’ Out)</span><span style="color:${enClosed ? '#6ee7b7' : '#fca5a5'}">${(balance.energy.balance/1000).toFixed(4)} kW</span>`
    });
    ec.appendChild(residual);

    propEditor.appendChild(enSection.section);
  }
}

function describeSolve() {
  const ls = scene.runtime.lastSolve;
  if (!scene.units.size) return 'Empty scene.';
  
  let txt = ls.ok 
    ? `âœ… Converged in ${ls.iterations} iteration(s)\n` 
    : `âš  ${ls.warnings.join(' | ')}\n`;
  txt += `Units: ${scene.units.size} Â· Connections: ${scene.connections.length}\n`;
  txt += `Models: ` + Object.entries(models.active)
    .map(([k, v]) => `${k}:${v}`)
    .join(' Â· ');
  return txt;
}

/* =========================
   EVENT HANDLERS
   ========================= */
function deselectAll() {
  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  updatePropertiesPanel();
  render();
}

function rotateSelected() {
  if (!ui.selectedUnitId) return;
  scene.rotateUnit(ui.selectedUnitId);
  render();
  updatePropertiesPanel();
}

function deleteSelected() {
  if (ui.selectedUnitId) {
    scene.deleteUnit(ui.selectedUnitId);
    ui.selectedUnitId = null;
    updatePropertiesPanel();
    render();
  } else if (ui.selectedConnId) {
    // Delete stream
    scene.connections = scene.connections.filter(c => c.id !== ui.selectedConnId);
    ui.selectedConnId = null;
    updatePropertiesPanel();
    render();
  }
}

// SVG Events
svg.addEventListener('pointerdown', (ev) => {
  closeMenus();
  
  // Pan mode: Shift+click OR middle mouse button
  if (ev.shiftKey || ev.button === 1) {
    ev.preventDefault(); // Prevent default middle-click behavior
    ui.isPanning = true;
    ui.panStart = { 
      x: ev.clientX, 
      y: ev.clientY, 
      view: { ...ui.view } 
    };
    svg.setPointerCapture(ev.pointerId);
    return;
  }

  const w = screenToWorld(ev.clientX, ev.clientY);
  const cell = worldToCell(w.x, w.y);
  const existing = scene.unitAt(cell.x, cell.y);
  
  if (!existing) {
    if (ui.pendingFrom) {
      ui.pendingFrom = null;
      setStatus('Connect cancelled.');
      
      render();
      return;
    }
    ui.selectedUnitId = null;
    ui.selectedConnId = null;
    
    updatePropertiesPanel();
    render();
  }
});

svg.addEventListener('pointermove', (ev) => {
  ui._mouseWorld = screenToWorld(ev.clientX, ev.clientY);

  // Panning
  if (ui.isPanning && ui.panStart) {
    const dx = ev.clientX - ui.panStart.x;
    const dy = ev.clientY - ui.panStart.y;
    const rect = svg.getBoundingClientRect();
    const wx = dx / rect.width * ui.panStart.view.w;
    const wy = dy / rect.height * ui.panStart.view.h;
    ui.view.x = ui.panStart.view.x - wx;
    ui.view.y = ui.panStart.view.y - wy;
    render();
    return;
  }

  // Unit dragging
  if (ui.isDraggingUnit && ui.dragUnitId && ui.dragOffset) {
    const u = scene.units.get(ui.dragUnitId);
    if (u) {
      const wpos = ui._mouseWorld;
      const cellX = (wpos.x / scene.tile) - ui.dragOffset.cellX;
      const cellY = (wpos.y / scene.tile) - ui.dragOffset.cellY;
      const nx = Math.round(cellX);
      const ny = Math.round(cellY);
      scene.moveUnit(u.id, nx, ny);
      render();
    }
    return;
  }

  // Redraw pending connection
  if (ui.pendingFrom) render();
});

svg.addEventListener('pointerup', () => {
  ui.isPanning = false;
  ui.panStart = null;

  if (ui.isDraggingUnit) {
    ui.isDraggingUnit = false;
    ui.dragUnitId = null;
    ui.dragOffset = null;
    
    updatePropertiesPanel();
    render();
  }
});

svg.addEventListener('wheel', (ev) => {
  ev.preventDefault();
  const z = (ev.deltaY < 0) ? 0.9 : 1.1;
  const m = screenToWorld(ev.clientX, ev.clientY);
  const v = ui.view;
  const newW = v.w * z;
  const newH = v.h * z;
  const rx = (m.x - v.x) / v.w;
  const ry = (m.y - v.y) / v.h;
  v.x = m.x - rx * newW;
  v.y = m.y - ry * newH;
  v.w = newW;
  v.h = newH;
  render();
}, { passive: false });

// Drag & drop from unit library
svg.addEventListener('dragover', (ev) => {
  ev.preventDefault();
  ev.dataTransfer.dropEffect = 'copy';
});

svg.addEventListener('dragleave', (ev) => {
  // Clear flag if drag leaves the canvas without dropping
  if (ev.target === svg) {
    ui.isHTML5Dragging = false;
  }
});

svg.addEventListener('drop', (ev) => {
  ev.preventDefault();
  const defId = ev.dataTransfer.getData('text/plain') || ui.dragDefId;
  if (!defId) return;
  
  const w = screenToWorld(ev.clientX, ev.clientY);
  const cell = worldToCell(w.x, w.y);
  const id = scene.placeUnit(defId, cell.x, cell.y);
  
  if (!id) {
    setStatus('Cannot place here (collision).');
    ui.dragDefId = null;
    ui.isHTML5Dragging = false;
    return;
  }
  
  ui.selectedUnitId = id;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  ui.dragDefId = null;
  ui.isHTML5Dragging = false;
  setStatus(`Placed: ${UnitRegistry.get(defId).name}`);
  
  updatePropertiesPanel();
  render();
});

// Keyboard shortcuts
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'Escape') {
    ui.pendingFrom = null;
    closeMenus();
    setStatus('Cancelled.');
    
    render();
  }
  if (ev.key.toLowerCase() === 'r') rotateSelected();
  if (ev.key === 'Delete') deleteSelected();
});

/* =========================
   BUTTONS & MENUS
   ========================= */
btnRun.addEventListener('click', () => {
  const solveResult = solveScene(scene);
  setStatus(describeSolve());
  updateStatusIndicator(solveResult);
  updatePropertiesPanel();
  render();
});

// Status indicator help button
const statusHelp = document.querySelector('.status-help');
if (statusHelp) {
  statusHelp.addEventListener('click', (ev) => {
    ev.stopPropagation();
    showDiagnosisDialog();
  });
}

btnAdd.addEventListener('click', () => {
  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  showUnitLibrary();
  
  render();
});

// Status card toggle
btnMenu.addEventListener('click', (ev) => {
  ev.stopPropagation();
  menuFile.classList.remove('open');
  toggle(menuMain);
});

btnFile.addEventListener('click', (ev) => {
  ev.stopPropagation();
  menuMain.classList.remove('open');
  toggle(menuFile);
});

document.addEventListener('pointerdown', (ev) => {
  const t = ev.target;
  if (!(t.closest && (t.closest('.menuWrap') || t.closest('.menu')))) {
    closeMenus();
  }
});

document.getElementById('mComponents').addEventListener('click', () => {
  buildComponentsPanel();
  modalComponents.classList.add('open');
  closeMenus();
});

document.getElementById('mModels').addEventListener('click', () => {
  buildModelsPanel();  // Rebuild to reflect current state
  modalModels.classList.add('open');
  closeMenus();
});

document.getElementById('mUnits').addEventListener('click', () => {
  buildUnitsPanel();
  modalUnits.classList.add('open');
  closeMenus();
});

// Close modals when clicking outside
modalModels.addEventListener('click', (ev) => {
  if (ev.target === modalModels) {
    modalModels.classList.remove('open');
  }
});

modalUnits.addEventListener('click', (ev) => {
  if (ev.target === modalUnits) {
    modalUnits.classList.remove('open');
  }
});

modalComponents.addEventListener('click', (ev) => {
  if (ev.target === modalComponents) {
    modalComponents.classList.remove('open');
  }
});

document.getElementById('mLoadDemo').addEventListener('click', () => {
  if (confirm('Load demo? This will replace the current scene.')) {
    loadDemo();
  }
  closeMenus();
});

document.getElementById('mClear').addEventListener('click', () => {
  if (confirm('Clear the entire scene? This cannot be undone.')) {
    scene.importJSON(JSON.stringify({
      version: 8,
      processName: '',
      grid: { w: 22, h: 14, tile: 48 },
      units: [],
      connections: [],
      modelsActive: models.active
    }));
    document.getElementById('processNameInput').value = '';
    deselectAll();
    setStatus('Scene cleared.');
  }
  closeMenus();
});

document.getElementById('mRunTests').addEventListener('click', () => {
  closeMenus();
  if (typeof runTests === 'function') {
    runTests();
  } else {
    console.warn('Test suite not loaded.');
    setStatus('Test suite not available.');
  }
});

document.getElementById('mExport').addEventListener('click', () => {
  // Sync process name from input before export
  scene.processName = document.getElementById('processNameInput').value.trim();
  const json = scene.exportJSON();
  
  // Build filename from process name (sanitised) or fallback
  const baseName = scene.processName
    ? scene.processName.replace(/[^a-zA-Z0-9_\-\s]/g, '').replace(/\s+/g, '_').substring(0, 60)
    : 'process_grid';
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
  const filename = `${baseName}_${timestamp}.json`;
  
  // Trigger browser download
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  setStatus(`Exported: ${filename}`);
  closeMenus();
});

// Hidden file input for import
const fileImportInput = document.getElementById('fileImportInput');

document.getElementById('mImport').addEventListener('click', () => {
  fileImportInput.value = '';  // reset so same file can be re-imported
  fileImportInput.click();
  closeMenus();
});

fileImportInput.addEventListener('change', (ev) => {
  const file = ev.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      scene.importJSON(e.target.result);
      document.getElementById('processNameInput').value = scene.processName;
      buildModelsPanel();
      deselectAll();
      const solveResult = solveScene(scene);
      updateStatusIndicator(solveResult);
      updatePropertiesPanel();
      render();
      setStatus(`Imported: ${file.name} (${scene.units.size} units, ${scene.connections.length} connections)`);
    } catch (err) {
      setStatus('Import failed: ' + err.message);
    }
  };
  reader.onerror = () => setStatus('Failed to read file.');
  reader.readAsText(file);
});

// Sync process name from input â†’ scene on every edit
document.getElementById('processNameInput').addEventListener('input', (e) => {
  scene.processName = e.target.value.trim();
});

/* =========================
   DEMO
   ========================= */
function loadDemo() {
  scene.importJSON(JSON.stringify({
    version: 11,
    grid: { w: 24, h: 18, tile: 48 },
    units: [
      // â”€â”€ Power Sources â”€â”€
      { id: 'pwr-a', defId: 'source_electrical', name: 'Grid', x: 0, y: 4, rot: 0, 
        params: { maxPower: 50 } },
      { id: 'batt-a', defId: 'battery', name: 'Battery', x: 0, y: 8, rot: 0, 
        params: { maxPower: 30 } },
      
      // â”€â”€ Turbine + Generator (third power source) â”€â”€
      { id: 'src-hot', defId: 'source', name: 'Hot N2', x: 0, y: 12, rot: 0,
        params: { species: 'N2', P: 500000, T: 400, nDot: 0.5, phaseConstraint: 'V' } },
      { id: 'turb', defId: 'gas_turbine', name: 'Turbine', x: 4, y: 12, rot: 0,
        params: { Pout: 101325, eta: 0.88 } },
      { id: 'snk-exh', defId: 'sink', name: 'Exhaust', x: 8, y: 12, rot: 0,
        params: {} },
      { id: 'gen', defId: 'generator', name: 'Generator', x: 4, y: 15, rot: 0,
        params: { eta: 0.97 } },
      
      // â”€â”€ Power Hub â”€â”€
      { id: 'hub', defId: 'power_hub', name: 'Hub', x: 8, y: 5, rot: 0, 
        params: {} },
      
      // â”€â”€ Heat Sink (surplus) â”€â”€
      { id: 'hsink', defId: 'sink_heat', name: 'Dump Load', x: 8, y: 1, rot: 0, 
        params: {} },
      
      // â”€â”€ Heat Sink (converter losses) â€” multiConnect from motor + generator â”€â”€
      { id: 'hsink-loss', defId: 'sink_heat', name: 'Loss Dump', x: 8, y: 15, rot: 0, 
        params: {} },
      
      // â”€â”€ Construct A: Motor + Compressor Chain â”€â”€
      { id: 'motor-a', defId: 'motor', name: 'Motor', x: 12, y: 4, rot: 0, 
        params: { eta: 0.95 } },
      { id: 'src-a', defId: 'source', name: 'N2 Feed', x: 12, y: 8, rot: 0, 
        params: { species: 'N2', P: 100000, T: 25, nDot: 1.0, phaseConstraint: 'V' } },
      { id: 'comp-a', defId: 'compressor', name: 'Compressor', x: 16, y: 6, rot: 0, 
        params: { Pout: 300000, eta: 0.80 } },
      { id: 'snk-a', defId: 'sink', name: 'Product', x: 20, y: 6, rot: 0, 
        params: {} },
      
      // â”€â”€ Construct B: Electric Heater Chain â”€â”€
      { id: 'eh-b', defId: 'electric_heater', name: 'E.Heater', x: 12, y: 11, rot: 0, 
        params: {} },
      { id: 'src-b', defId: 'source', name: 'H2O Feed', x: 12, y: 15, rot: 0, 
        params: { species: 'H2O', P: 200000, T: 27, nDot: 2.0, phaseConstraint: 'L' } },
      { id: 'htr-b', defId: 'heater', name: 'Heater', x: 16, y: 12, rot: 0, 
        params: { T_out: 80 } },
      { id: 'snk-b', defId: 'sink', name: 'Hot H2O', x: 20, y: 12, rot: 0, 
        params: {} },
    ],
    connections: [
      // Sources â†’ Hub (all on elec_in)
      { id: 'h1', from: { unitId: 'pwr-a', portId: 'out' }, 
        to: { unitId: 'hub', portId: 'elec_in' } },
      { id: 'h2', from: { unitId: 'batt-a', portId: 'out' }, 
        to: { unitId: 'hub', portId: 'elec_in' } },
      { id: 'h5', from: { unitId: 'gen', portId: 'elec_out' }, 
        to: { unitId: 'hub', portId: 'elec_in' } },
      
      // Turbine chain: hot gas â†’ turbine â†’ exhaust, shaft â†’ generator
      { id: 't1', from: { unitId: 'src-hot', portId: 'out' }, 
        to: { unitId: 'turb', portId: 'mat_in' } },
      { id: 't2', from: { unitId: 'turb', portId: 'mat_out' }, 
        to: { unitId: 'snk-exh', portId: 'in' } },
      { id: 't3', from: { unitId: 'turb', portId: 'mech_out' }, 
        to: { unitId: 'gen', portId: 'mech_in' } },
      
      // Hub surplus â†’ Heat Sink
      { id: 'h3', from: { unitId: 'hub', portId: 'heat_out' }, 
        to: { unitId: 'hsink', portId: 'in' } },
      
      // Hub â†’ Motor â†’ Compressor chain
      { id: 'a1', from: { unitId: 'hub', portId: 'elec_out' }, 
        to: { unitId: 'motor-a', portId: 'elec_in' } },
      { id: 'a2', from: { unitId: 'motor-a', portId: 'mech_out' }, 
        to: { unitId: 'comp-a', portId: 'power_in' } },
      { id: 'a3', from: { unitId: 'src-a', portId: 'out' }, 
        to: { unitId: 'comp-a', portId: 'mat_in' } },
      { id: 'a4', from: { unitId: 'comp-a', portId: 'mat_out' }, 
        to: { unitId: 'snk-a', portId: 'in' } },
      
      // Hub â†’ E.Heater â†’ Heater chain
      { id: 'b1', from: { unitId: 'hub', portId: 'elec_out' }, 
        to: { unitId: 'eh-b', portId: 'elec_in' } },
      { id: 'b2', from: { unitId: 'eh-b', portId: 'heat_out' }, 
        to: { unitId: 'htr-b', portId: 'heat_in' } },
      { id: 'b3', from: { unitId: 'src-b', portId: 'out' }, 
        to: { unitId: 'htr-b', portId: 'mat_in' } },
      { id: 'b4', from: { unitId: 'htr-b', portId: 'mat_out' }, 
        to: { unitId: 'snk-b', portId: 'in' } },
      
      // Converter heat losses â†’ shared heat sink (multiConnect)
      { id: 'q1', from: { unitId: 'motor-a', portId: 'heat_out' }, 
        to: { unitId: 'hsink-loss', portId: 'in' } },
      { id: 'q2', from: { unitId: 'gen', portId: 'heat_out' }, 
        to: { unitId: 'hsink-loss', portId: 'in' } },
    ],
    modelsActive: models.active
  }));

  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  scene.processName = 'Demo Process';
  document.getElementById('processNameInput').value = scene.processName;
  const solveResult = solveScene(scene);
  setStatus(describeSolve() + "\nDemo: 3 sources (grid + battery + turbine/gen) â†’ hub â†’ compressor + heater.");
  updateStatusIndicator(solveResult);
  
  updatePropertiesPanel();
  render();
}

/* =========================
   INITIALIZATION
   ========================= */
buildModelsPanel();
buildComponentsPanel();

// Initialize viewport and handle window resize
window.addEventListener('resize', () => {
  setViewBox();
  render();
});

setViewBox();

updatePropertiesPanel();
render();
loadDemo();

/* =========================
   TEST SUITE v2.0 â€” Declarative Framework
   
   Runs via: Menu â†’ Run Tests, or window.runTests(), or ?test URL param.
   Each test is a standalone function receiving a TestCtx helper.
   
   TestCtx API:
     t.clearScene()                         - reset scene
     t.place(defId, x, y, params?)          - place unit, set params, return id
     t.wire(fromId, fromPort, toId, toPort) - add connection
     t.solve() / t.solveRaw()               - solve (assert ok / no assert)
     t.unit(id) / t.ud(id) / t.port(id,p)  - get unit / unitData / port stream
     t.last(id)                             - unit.last or ud.last
     t.assertClose(actual, expected, tol, name) - numeric tolerance check
     t.assertOK(condition, name, details?)      - boolean check
     t.assertRange(actual, lo, hi, name)        - range check
   ========================= */

class TestCtx {
  constructor(name, num) {
    this.name = name; this.num = num;
    this.passed = 0; this.failed = 0; this.results = [];
  }
  clearScene() {
    scene.units.clear(); scene.connections = []; scene._idCounter = 0;
  }
  place(defId, x, y, params) {
    const id = scene.placeUnit(defId, x, y);
    if (!id) throw new Error(`Failed to place ${defId} at (${x},${y})`);
    if (params) scene.units.get(id).params = params;
    return id;
  }
  wire(fromId, fromPort, toId, toPort) {
    scene.connections.push({
      id: `tc-${scene.connections.length}`,
      from: { unitId: fromId, portId: fromPort },
      to: { unitId: toId, portId: toPort }
    });
  }
  solve() {
    const r = solveScene(scene);
    if (!r.ok) throw new Error(`Solver failed: ${JSON.stringify(r.diagnostics)}`);
    return r;
  }
  solveRaw() { return solveScene(scene); }
  unit(id) { return scene.units.get(id); }
  ud(id) { return scene.runtime.unitData.get(id); }
  port(id, p) { return this.ud(id)?.ports?.[p]; }
  last(id) { return this.unit(id)?.last || this.ud(id)?.last; }

  assertClose(actual, expected, tol, name) {
    if (actual === undefined || actual === null || isNaN(actual)) {
      this.failed++;
      this.results.push({ name, calc: 'N/A', ref: expected, delta: 'N/A', tol, status: 'âœ—' });
      return false;
    }
    // [v4.7.7] Float epsilon: tol=0 with floats fails on rounding noise (e.g. 2e-16).
    // Use 1e-12 as minimum tolerance for any comparison involving non-integer values.
    const effectiveTol = (tol === 0 && !(Number.isInteger(actual) && Number.isInteger(expected)))
      ? 1e-12 : tol;
    const diff = Math.abs(actual - expected);
    const pass = diff <= effectiveTol;
    pass ? this.passed++ : this.failed++;
    this.results.push({ name, calc: actual, ref: expected, delta: diff, tol, status: pass ? 'âœ“' : 'âœ—' });
    return pass;
  }
  assertOK(cond, name, detail) {
    const pass = !!cond;
    pass ? this.passed++ : this.failed++;
    this.results.push({ name, calc: detail || (pass ? 'OK' : 'FAIL'), ref: 'OK', delta: pass ? 'match' : 'FAIL', tol: 'exact', status: pass ? 'âœ“' : 'âœ—' });
    return pass;
  }
  assertRange(actual, lo, hi, name) {
    const pass = actual >= lo && actual <= hi;
    pass ? this.passed++ : this.failed++;
    this.results.push({ name, calc: typeof actual === 'number' ? actual.toFixed(4) : actual, ref: `${lo}â€“${hi}`, delta: pass ? 'in range' : 'OUT', tol: 'range', status: pass ? 'âœ“' : 'âœ—' });
    return pass;
  }
  // Enthalpy balance helper: |H_out - H_ref| within relative tolerance
  assertHBalance(H_out, H_ref, relTol, name) {
    const err = Math.abs(H_out - H_ref);
    const tol = Math.max(Math.abs(H_ref) * relTol, 1);
    return this.assertClose(err, 0, tol, name);
  }

  _printTable() {
    if (!this.results.length) return;
    console.log(`  â”Œ${'â”€'.repeat(78)}â”`);
    console.log(`  â”‚ Parameter          Calculated    Reference     Delta       Tolerance  Status â”‚`);
    console.log(`  â”œ${'â”€'.repeat(78)}â”¤`);
    for (const r of this.results) {
      // [v4.7.7] Use scientific notation for very small numbers to avoid misleading "0.0000 vs Â±0.0000 â†’ âœ—"
      const fmtNum = (v) => {
        if (typeof v !== 'number') return v;
        const abs = Math.abs(v);
        if (abs === 0) return '0';
        if (abs < 1e-3 && abs > 0) return v.toExponential(2);
        return v.toFixed(4);
      };
      const fmt = (v, w) => String(typeof v === 'number' ? fmtNum(v) : v).substring(0, w).padEnd(w);
      const tolS = (typeof r.tol === 'number' ? `Â±${fmtNum(r.tol)}` : String(r.tol)).substring(0, 10).padEnd(10);
      console.log(`  â”‚ ${fmt(r.name,18)} ${fmt(r.calc,13)} ${fmt(r.ref,13)} ${fmt(r.delta,11)} ${tolS} ${r.status.padEnd(6)} â”‚`);
    }
    console.log(`  â””${'â”€'.repeat(78)}â”˜`);
  }
}

function runTests() {
  const tests = [];
  function test(name, fn) { tests.push({ name, fn }); }

  const savedJSON = scene.exportJSON();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION A: Thermo-physical â€” Valve, Compressor, Pump (Tests 1-5)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Water Throttling Flash', t => {
    // Source(H2O,200Â°C,20bar,L) â†’ Valve(2bar) â†’ Sink
    const src = t.place('source', 0, 0, { species:'H2O', nDot:10, T:200, P:2000000, phaseConstraint:'L' });
    const vlv = t.place('valve', 3, 0, { Pout:200000 });
    const snk = t.place('sink', 6, 0);
    t.wire(src,'out', vlv,'in'); t.wire(vlv,'out', snk,'in');
    t.solve();
    const out = t.port(vlv, 'out');
    const srcOut = t.port(src, 'out');
    t.assertClose(out.T, 393.475, 0.2, 'T [K]');
    t.assertClose(out.beta || 0, 0.150650, 0.002, 'beta');
    t.assertClose(out.nV?.H2O || 0, 1.506502, 0.02, 'nV[H2O]');
    t.assertClose(out.nL?.H2O || 0, 8.493498, 0.02, 'nL[H2O]');
    t.assertOK(out.phase === 'VL', 'Phase = VL', out.phase);
    if (srcOut?.Hdot_J_s !== undefined && out.Hdot_J_s !== undefined) {
      t.assertClose(Math.abs(out.Hdot_J_s - srcOut.Hdot_J_s), 0, 10, 'Î”H [J/s]');
    }
  });

  test('Nitrogen Compressor', t => {
    // Source(N2,300K,1bar) â†’ Compressor(10bar,Î·=0.75) â†’ Sink + MechSource(200kW)
    const src = t.place('source', 0, 0, { species:'N2', nDot:10, T:27, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 3, 0, { Pout:1000000, eta:0.75 });
    const snk = t.place('sink', 6, 0);
    const mech = t.place('source_mechanical', 3, -3, { maxPower:200 });
    t.wire(src,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.wire(mech,'out', comp,'power_in');
    t.solve();
    const out = t.port(comp, 'mat_out');
    const srcS = t.port(src, 'out');
    t.assertClose(out.P, 1000000, 1, 'P_out [Pa]');
    t.assertOK(out.T > srcS.T + 50, 'T_out >> T_in', `${out.T.toFixed(1)}K > ${srcS.T.toFixed(1)}K`);
    const W = t.unit(comp).powerDemand || 0;
    t.assertRange(W / 1000, 50, 150, 'W_shaft [kW]');
    // Energy balance
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T:300, P:100000, n:{N2:10} });
    const H_out = thermo.getHdot_Jps(out);
    t.assertClose(Math.abs((H_out - H_in) - W) / 1000, 0, 0.5, 'H balance [kW]');
  });

  test('Methane Valve (Ideal Gas)', t => {
    // Source(CH4,300K,50bar,V) â†’ Valve(1bar) â†’ Sink
    const src = t.place('source', 0, 0, { species:'CH4', nDot:5, T:27, P:5000000, phaseConstraint:'V' });
    const vlv = t.place('valve', 3, 0, { Pout:100000 });
    const snk = t.place('sink', 6, 0);
    t.wire(src,'out', vlv,'in'); t.wire(vlv,'out', snk,'in');
    t.solve();
    const out = t.port(vlv, 'out');
    const srcS = t.port(src, 'out');
    t.assertClose(out.P, 100000, 1, 'P_out [Pa]');
    t.assertOK(out.phase === 'V', 'Phase = V', out.phase);
    // Ideal gas isenthalpic: T should stay ~300K
    t.assertClose(out.T, srcS.T, 5, 'T â‰ˆ T_in (ideal)');
    // Energy balance
    if (srcS?.Hdot_J_s !== undefined && out.Hdot_J_s !== undefined) {
      t.assertClose(Math.abs(out.Hdot_J_s - srcS.Hdot_J_s), 0, 10, 'Î”H [J/s]');
    }
    t.assertClose(out.n?.CH4 || 0, 5, 0.001, 'n conserved');
  });

  test('Water Pump (Hydraulic Work)', t => {
    // Source(H2O,25Â°C,1bar,L) â†’ Pump(50bar,Î·=0.70) â†’ Sink + MechSource(5kW)
    const src = t.place('source', 0, 0, { species:'H2O', nDot:10, T:25, P:100000, phaseConstraint:'L' });
    const pmp = t.place('pump', 3, 0, { Pout:5000000, eta:0.70 });
    const snk = t.place('sink', 6, 0);
    const mech = t.place('source_mechanical', 3, -3, { maxPower:5 });
    t.wire(src,'out', pmp,'mat_in'); t.wire(pmp,'mat_out', snk,'in');
    t.wire(mech,'out', pmp,'power_in');
    t.solve();
    const out = t.port(pmp, 'mat_out');
    t.assertClose(out.P, 5000000, 1, 'P_out [Pa]');
    t.assertOK(out.phase === 'L', 'Phase = L', out.phase);
    // Pump work for incompressible: W_ideal = nDot * V_mol * Î”P / Î·
    const V_mol = 18.015e-3 / 1000;  // mÂ³/mol â€” MW(kg/mol) / Ï(kg/mÂ³)
    const W_ideal = 10 * V_mol * (5000000 - 100000);
    const W_actual = t.unit(pmp).powerDemand || 0;
    t.assertRange(W_actual, W_ideal * 0.5, W_ideal * 3, 'W_shaft range');
    // T should barely change
    t.assertRange(out.T, 295, 305, 'T â‰ˆ 298K (liquid)');
    // Energy balance
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T:298.15, P:100000, n:{H2O:10} });
    const H_out = thermo.getHdot_Jps(out);
    t.assertClose(Math.abs((H_out - H_in) - W_actual) / 1000, 0, 0.5, 'H balance [kW]');
  });

  test('Oxygen Compressor (Low T)', t => {
    // Source(O2,120K,2bar,V) â†’ Compressor(10bar,Î·=0.8) â†’ Sink + MechSource
    const src = t.place('source', 0, 0, { species:'O2', nDot:5, T:-153.15, P:200000, phaseConstraint:'V' });
    const comp = t.place('compressor', 3, 0, { Pout:1000000, eta:0.80 });
    const snk = t.place('sink', 6, 0);
    const mech = t.place('source_mechanical', 3, -3, { maxPower:50 });
    t.wire(src,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.wire(mech,'out', comp,'power_in');
    t.solve();
    const out = t.port(comp, 'mat_out');
    t.assertClose(out.P, 1000000, 1, 'P_out [Pa]');
    t.assertOK(out.T > 120, 'T_out > T_in', `${out.T?.toFixed(1)}K`);
    t.assertOK(out.phase === 'V', 'Phase = V', out.phase);
    const W = t.unit(comp).powerDemand || 0;
    t.assertRange(W / 1000, 1, 50, 'W_shaft [kW]');
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T:120, P:200000, n:{O2:5} });
    const H_out = thermo.getHdot_Jps(out);
    t.assertClose(Math.abs((H_out - H_in) - W) / 1000, 0, 0.5, 'H balance [kW]');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION B: Thermo engine unit tests (Tests 6-17)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Antoine Range Selection', t => {
    const Psat = thermo.saturationPressure('H2O', 400);
    t.assertClose(Psat, 245036, 245036 * 0.05, 'Psat [Pa]');
    t.assertOK(Psat !== null && !isNaN(Psat), 'Psat valid');
  });

  test('Antoine Out-of-Range', t => {
    const orig = new Set(thermo._warnedRanges);
    thermo._warnedRanges.clear();
    const Psat_low = thermo.saturationPressure('H2O', 200);
    const Psat_high = thermo.saturationPressure('H2O', 700);
    thermo.saturationPressure('H2O', 250);   // dedup
    thermo.saturationPressure('H2O', 750);   // dedup
    t.assertOK(Psat_low > 0 && !isNaN(Psat_low), 'Psat_low valid');
    t.assertOK(Psat_high > 0 && !isNaN(Psat_high), 'Psat_high valid');
    t.assertClose(thermo._warnedRanges.size, 2, 0, 'Warnings dedup');
    thermo._warnedRanges = orig;
  });

  test('ComponentRegistry Validation', t => {
    const vr = ComponentRegistry.validateAll();
    t.assertOK(Object.values(vr).every(r => r.valid), 'All comps valid');
    t.assertOK(ComponentRegistry.validate('H2O').valid, 'H2O multi-range');
    // Malformed: missing Tmin/Tmax
    let caught = false;
    try {
      ComponentRegistry.register('TEST_BAD', { name:'Bad', MW:18, Tc:647, Pc:22064000, omega:0.344, Tb:373, phase298:'liquid',
        antoine:[{A:8,B:1730,C:233}], cpig:{A:33,B:-0.008,C:3e-5,D:-2e-8,E:4e-12,Tmin:273,Tmax:1500}, cpLiq:75.3 });
      const bv = ComponentRegistry.validate('TEST_BAD');
      if (!bv.valid) caught = true;
      ComponentRegistry._components.delete('TEST_BAD');
    } catch(e) { caught = true; }
    t.assertOK(caught, 'Malformed rejected');
    // Range ordering
    let orderCaught = false;
    try {
      ComponentRegistry.register('TEST_ORD', { name:'Ord', MW:18, Tc:647, Pc:22064000, omega:0.344, Tb:373, phase298:'liquid',
        antoine:[{A:8,B:1730,C:233,Tmin:400,Tmax:300}], cpig:{A:33,B:-0.008,C:3e-5,D:-2e-8,E:4e-12,Tmin:273,Tmax:1500}, cpLiq:75.3 });
      const ov = ComponentRegistry.validate('TEST_ORD');
      if (!ov.valid) orderCaught = true;
      ComponentRegistry._components.delete('TEST_ORD');
    } catch(e) { orderCaught = true; }
    t.assertOK(orderCaught, 'Range ordering rejected');
  });

  test('Gamma Mixture Calculation', t => {
    const R = 8.314;
    const Cp_He = thermo.cpMolar('He', 300, 101325, 'V');
    const Cp_CO2 = thermo.cpMolar('CO2', 300, 101325, 'V');
    const Cp_mix = 0.5 * Cp_He + 0.5 * Cp_CO2;
    const gamma_correct = Cp_mix / (Cp_mix - R);
    const gamma_wrong = 0.5 * (Cp_He/(Cp_He-R)) + 0.5 * (Cp_CO2/(Cp_CO2-R));
    t.assertClose(gamma_correct, 1.404, 0.01, 'gamma_mix');
    t.assertOK(Math.abs(gamma_wrong - 1.404) > 0.03, 'Avg â‰  correct');
    t.assertClose(Cp_mix, 0.5*Cp_He + 0.5*Cp_CO2, 0.01, 'Cp_mix');
  });

  test('VL Fallback Phase Normalization', t => {
    const cases = [['V','L','V'],['L','V','L'],['VL','L','L'],['VL','V','V'],[null,'L','L'],[undefined,'V','V'],['','L','L']];
    const allOK = cases.every(([inp,def,exp]) => thermo.normalizeSinglePhaseHint(inp,def) === exp);
    t.assertOK(allOK, 'Normalize helper');
    const s = { type:StreamType.MATERIAL, phase:'VL', phaseConstraint:'VL', T:300, P:101325, n:{N2:1} };
    let cpOK = false; try { const cp = thermo.streamCp(s); cpOK = cp > 0 && !isNaN(cp); } catch(e) {}
    t.assertOK(cpOK, 'streamCp VL safe');
    let hOK = false; try { thermo.computeStreamEnthalpy(s); hOK = s.Hdot_J_s !== undefined && !isNaN(s.Hdot_J_s); } catch(e) {}
    t.assertOK(hOK, 'computeH VL safe');
  });

  test('PH Flash Unachievable Target', t => {
    const P = 101325, n = {N2:1};
    const H_min = thermo.hMolar('N2', 100, P, 'V') * 1;
    const rLow = thermo.phFlash({ P, n, H_target_Jps: H_min - 10000 });
    t.assertOK(!rLow.converged, 'Low: !converged');
    t.assertOK(rLow.warning, 'Low: warning');
    t.assertOK(isFinite(rLow.T_K), 'Low: T finite');
    t.assertOK(rLow.residual_Jps !== undefined, 'Low: residual');
    const H_max = thermo.hMolar('N2', 3000, P, 'V') * 1;
    const rHigh = thermo.phFlash({ P, n, H_target_Jps: H_max + 10000 });
    t.assertOK(!rHigh.converged, 'High: !converged');
    t.assertOK(isFinite(rHigh.T_K), 'High: T finite');
  });

  test('PH Flash Near-Zero Denominator', t => {
    const P = 101325, n = {He:0.01};
    const H1 = thermo.hMolar('He', 300, P, 'V') * 0.01;
    const H2 = thermo.hMolar('He', 305, P, 'V') * 0.01;
    const r = thermo.phFlash({ P, n, H_target_Jps: (H1+H2)/2 });
    t.assertOK(isFinite(r.T_K) && !isNaN(r.T_K), 'T finite');
    t.assertRange(r.T_K, 200, 400, 'T reasonable');
    t.assertOK(r.residual_Jps !== undefined && r.iterations !== undefined, 'Metadata');
  });

  test('Density from ComponentRegistry', t => {
    const comps = ['H2O','O2','H2','N2','Ar','CH4','He','CO2'];
    const expected = { H2O:1000, O2:1141, H2:71, N2:807, Ar:1394, CH4:423, He:125, CO2:1101 };
    t.assertOK(comps.every(c => ComponentRegistry.get(c)?.rhoLiq !== undefined), 'All rhoLiq present');
    t.assertOK(comps.every(c => thermo.density(c, 298, 101325, 'L') === expected[c]), 'density(L) correct');
    const rhoV = thermo.density('N2', 300, 101325, 'V');
    t.assertClose(rhoV, (101325 * 28.014/1000) / (8.314 * 300), 0.01, 'density(V) ideal');
  });

  test('Cp Polynomial Clamping', t => {
    const Cp100 = thermo.cpMolar('N2', 100, 101325, 'V');
    const Cp50 = thermo.cpMolar('N2', 50, 101325, 'V');
    const Cp2000 = thermo.cpMolar('N2', 2000, 101325, 'V');
    const Cp5000 = thermo.cpMolar('N2', 5000, 101325, 'V');
    t.assertClose(Cp50, Cp100, 0.001, 'Cp clamp low');
    t.assertClose(Cp5000, Cp2000, 0.001, 'Cp clamp high');
    const h2k = thermo.hMolar('N2',2000,101325,'V'), h3k = thermo.hMolar('N2',3000,101325,'V'), h5k = thermo.hMolar('N2',5000,101325,'V');
    t.assertOK(h2k < h3k && h3k < h5k, 'h monotonic');
    t.assertClose((h5k-h3k)/(h3k-h2k), 2.0, 0.01, 'h linear extrap');
  });

  test('Canonical FlashResult Fields', t => {
    const mf = ['phase','beta','vaporFraction','x','y','nL','nV','iterations','converged','T_K','bracketed','residual_Jps'];
    const check = (lbl, r, flds) => t.assertOK(flds.every(f => r[f] !== undefined), lbl);
    check('Normal vapor', thermo.phFlash({P:101325, n:{H2O:1}, H_target_Jps:50000}), mf);
    check('Empty stream', thermo.phFlash({P:101325, n:{H2O:0}, H_target_Jps:0}), mf);
    check('Unachievable', thermo.phFlash({P:101325, n:{N2:1}, H_target_Jps:-999999}), [...mf,'warning']);
    const Tsat = thermo._findSaturationTemperature('H2O', 101325);
    const hf = thermo.hMolar('H2O', Tsat, 101325, 'L'), hg = thermo.hMolar('H2O', Tsat, 101325, 'V');
    const r2ph = thermo.phFlash({P:101325, n:{H2O:1}, H_target_Jps:(hf+hg)/2});
    t.assertOK(r2ph.phase === 'VL' && r2ph.residual_Jps === 0 && r2ph.bracketed, 'Two-phase exact');
  });

  test('Heater Enthalpy Energy Balance', t => {
    const inS = { type:StreamType.MATERIAL, T:363.15, P:101325, n:{H2O:1} };
    const outS = { type:StreamType.MATERIAL, T:383.15, P:101325, n:{H2O:1} };
    const H_in = thermo.getHdot_Jps(inS), H_out = thermo.getHdot_Jps(outS);
    const Q_exact_kW = (H_out - H_in) / 1000;
    const Q_Cp_kW = thermo.streamCp(inS) * 20 / 1000;
    t.assertOK(Q_exact_kW > 30, 'Latent captured', `${Q_exact_kW.toFixed(1)} kW`);
    t.assertOK(Q_exact_kW / Q_Cp_kW > 5, 'Q_exact/Q_Cp > 5');
    // Integration test: heater T_out mode
    const src = t.place('source', 0, 0, { species:'H2O', nDot:1, T:90, P:101325, phaseConstraint:'VL' });
    const htr = t.place('heater', 3, 0, { T_out:110 });
    const snk = t.place('sink', 6, 0);
    t.wire(src,'out', htr,'mat_in'); t.wire(htr,'mat_out', snk,'in');
    t.solve();
    t.assertOK(t.port(htr,'mat_out')?.H_target_Jps !== undefined, 'H_target_Jps set');
  });

  test('Thermo Package System', t => {
    const pkg = thermo.getPackage();
    t.assertOK(pkg.id === 'ideal_raoult', 'Default pkg', pkg.id);
    const Cp_d = idealRaoultPkg.cpMolar('H2O', 400, 101325, 'V');
    t.assertClose(thermo.cpMolar('H2O', 400, 101325, 'V'), Cp_d, 0.001, 'Delegation Cp');
    thermo.setPackage(pengRobinsonPkg);
    t.assertClose(thermo.cpMolar('H2O', 400, 101325, 'V'), Cp_d, 0.001, 'PR stub Cp');
    t.assertOK(thermo.getPackage().id === 'peng_robinson', 'Switched to PR');
    thermo.setPackage(idealRaoultPkg);
    t.assertClose(thermo.cpMolar('H2O', 400, 101325, 'V'), Cp_d, 0.001, 'Switch back Cp');
    const pkgs = models.list('thermo_package');
    t.assertOK(pkgs.length >= 2 && pkgs.some(p=>p.id==='ideal_raoult') && pkgs.some(p=>p.id==='peng_robinson'), 'Registry has both');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION C: Mixer, Splitter, Recycle, Heater, HEX (Tests 18-26)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Mixer: N2 Sensible Mixing', t => {
    const s1 = t.place('source', 0, 0, { species:'N2', nDot:10, T:27, P:200000, phaseConstraint:'V' });
    const s2 = t.place('source', 0, 3, { species:'N2', nDot:10, T:227, P:100000, phaseConstraint:'V' });
    const mix = t.place('mixer', 4, 1); const snk = t.place('sink', 8, 1);
    t.wire(s1,'out', mix,'in1'); t.wire(s2,'out', mix,'in2'); t.wire(mix,'out', snk,'in');
    t.solve();
    const out = t.port(mix, 'out');
    t.assertClose(out.P, 100000, 1, 'P_out [Pa]');
    t.assertClose(Object.values(out.n).reduce((a,b)=>a+b,0), 20, 0.001, 'n_total');
    t.assertOK(out.phase === 'V', 'Phase = V', out.phase);
    const H1 = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:300, P:200000, n:{N2:10}});
    const H2 = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:500, P:100000, n:{N2:10}});
    t.assertHBalance(out.Hdot_J_s || thermo.getHdot_Jps(out), H1+H2, 5e-3, 'H balance');
    const ref = thermo.phFlash({P:100000, n:{N2:20}, H_target_Jps:H1+H2});
    t.assertClose(out.T, ref.T_K, 0.5, 'T_out [K]');
    t.assertRange(out.T, 300, 500, 'T in range');
  });

  test('Mixer: CO2+N2 Composition', t => {
    const s1 = t.place('source', 0, 0, { species:'CO2', nDot:10, T:77, P:300000, phaseConstraint:'V' });
    const s2 = t.place('source', 0, 3, { species:'N2', nDot:30, T:77, P:100000, phaseConstraint:'V' });
    const mix = t.place('mixer', 4, 1); const snk = t.place('sink', 8, 1);
    t.wire(s1,'out', mix,'in1'); t.wire(s2,'out', mix,'in2'); t.wire(mix,'out', snk,'in');
    t.solve();
    const out = t.port(mix, 'out');
    t.assertClose(out.P, 100000, 1, 'P_out [Pa]');
    t.assertClose(out.n.CO2 || 0, 10, 0.001, 'n_CO2');
    t.assertClose(out.n.N2 || 0, 30, 0.001, 'n_N2');
    const H1 = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:350, P:300000, n:{CO2:10}});
    const H2 = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:350, P:100000, n:{N2:30}});
    t.assertHBalance(out.Hdot_J_s || thermo.getHdot_Jps(out), H1+H2, 5e-3, 'H balance');
    const ref = thermo.phFlash({P:100000, n:{CO2:10,N2:30}, H_target_Jps:H1+H2});
    t.assertClose(out.T, ref.T_K, 0.5, 'T_out [K]');
    t.assertClose((out.n.CO2||0)/((out.n.CO2||0)+(out.n.N2||0)), 0.25, 0.001, 'y_CO2');
  });

  test('Splitter: N2 50/50', t => {
    const src = t.place('source', 0, 1, { species:'N2', nDot:10, T:127, P:200000, phaseConstraint:'V' });
    const spl = t.place('splitter', 4, 1, { splitPct:50 });
    const sk1 = t.place('sink', 8, 0); const sk2 = t.place('sink', 8, 3);
    t.wire(src,'out', spl,'in'); t.wire(spl,'out1', sk1,'in'); t.wire(spl,'out2', sk2,'in');
    t.solve();
    const o1 = t.port(spl,'out1'), o2 = t.port(spl,'out2');
    t.assertClose(o1.n.N2||0, 5, 0.001, 'n_out1'); t.assertClose(o2.n.N2||0, 5, 0.001, 'n_out2');
    t.assertClose(o1.P, 200000, 1, 'P preserved'); t.assertClose(o1.T, 400, 1, 'T preserved');
    const H_in = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:400, P:200000, n:{N2:10}});
    t.assertHBalance(thermo.getHdot_Jps(o1)+thermo.getHdot_Jps(o2), H_in, 5e-3, 'H balance');
  });

  test('Splitter: CO2+N2 70/30', t => {
    const sCO2 = t.place('source', 0, 0, { species:'CO2', nDot:10, T:77, P:200000, phaseConstraint:'V' });
    const sN2 = t.place('source', 0, 3, { species:'N2', nDot:30, T:77, P:200000, phaseConstraint:'V' });
    const mix = t.place('mixer', 4, 1); const spl = t.place('splitter', 8, 1, { splitPct:70 });
    const sk1 = t.place('sink', 12, 0); const sk2 = t.place('sink', 12, 3);
    t.wire(sCO2,'out', mix,'in1'); t.wire(sN2,'out', mix,'in2');
    t.wire(mix,'out', spl,'in'); t.wire(spl,'out1', sk1,'in'); t.wire(spl,'out2', sk2,'in');
    t.solve();
    const o1 = t.port(spl,'out1'), o2 = t.port(spl,'out2');
    t.assertClose(o1.n.CO2||0, 7, 0.01, 'out1 CO2'); t.assertClose(o1.n.N2||0, 21, 0.01, 'out1 N2');
    t.assertClose(o2.n.CO2||0, 3, 0.01, 'out2 CO2'); t.assertClose(o2.n.N2||0, 9, 0.01, 'out2 N2');
    t.assertClose((o1.n.CO2||0)/((o1.n.CO2||0)+(o1.n.N2||0)), 0.25, 0.001, 'y_CO2 preserved');
    const nT = (o1.n.CO2||0)+(o1.n.N2||0)+(o2.n.CO2||0)+(o2.n.N2||0);
    t.assertClose(nT, 40, 0.01, 'n_total');
  });

  test('Splitter: Edge Cases 100%/0%', t => {
    // Case A: 100% to out1
    const sA = t.place('source', 0, 1, { species:'H2O', nDot:5, T:27, P:101325, phaseConstraint:'L' });
    const spA = t.place('splitter', 4, 1, { splitPct:100 });
    const sk1 = t.place('sink', 8, 0); const sk2 = t.place('sink', 8, 3);
    t.wire(sA,'out', spA,'in'); t.wire(spA,'out1', sk1,'in'); t.wire(spA,'out2', sk2,'in');
    t.solve();
    t.assertClose(t.port(spA,'out1').n.H2O||0, 5, 0.001, '100%: out1');
    t.assertClose(t.port(spA,'out2').n.H2O||0, 0, 1e-10, '100%: out2');
    // Case B: 0% to out1
    t.clearScene();
    const sB = t.place('source', 0, 1, { species:'N2', nDot:10, T:127, P:200000, phaseConstraint:'V' });
    const spB = t.place('splitter', 4, 1, { splitPct:0 });
    const sk3 = t.place('sink', 8, 0); const sk4 = t.place('sink', 8, 3);
    t.wire(sB,'out', spB,'in'); t.wire(spB,'out1', sk3,'in'); t.wire(spB,'out2', sk4,'in');
    t.solve();
    t.assertClose(t.port(spB,'out1').n.N2||0, 0, 1e-10, '0%: out1');
    t.assertClose(t.port(spB,'out2').n.N2||0, 10, 0.001, '0%: out2');
  });

  test('Recycle Loop: Mixer+Splitter', t => {
    const src = t.place('source', 0, 1, { species:'N2', nDot:10, T:127, P:200000, phaseConstraint:'V' });
    const mix = t.place('mixer', 4, 1); const spl = t.place('splitter', 8, 1, { splitPct:50 });
    const snk = t.place('sink', 12, 0);
    t.wire(src,'out', mix,'in1'); t.wire(mix,'out', spl,'in');
    t.wire(spl,'out1', snk,'in'); t.wire(spl,'out2', mix,'in2');
    t.solve();
    const mOut = t.port(mix,'out');
    const nMix = Object.values(mOut.n).reduce((a,b)=>a+b,0);
    const nProd = Object.values(t.port(spl,'out1').n).reduce((a,b)=>a+b,0);
    const nRecy = Object.values(t.port(spl,'out2').n).reduce((a,b)=>a+b,0);
    t.assertClose(nMix, 20, 0.1, 'M_mixer [mol/s]');
    t.assertClose(nProd, 10, 0.1, 'n_product');
    t.assertClose(nRecy, 10, 0.1, 'n_recycle');
    t.assertClose(mOut.T, 400, 1, 'T preserved');
    t.assertClose(mOut.P, 200000, 1, 'P preserved');
    t.assertClose(nProd, 10, 0.1, 'Global balance');
  });

  test('Heater: N2 Sensible (T_out)', t => {
    const src = t.place('source', 0, 1, { species:'N2', nDot:10, T:27, P:200000, phaseConstraint:'V' });
    const htr = t.place('heater', 4, 1, { T_out:127 }); const snk = t.place('sink', 8, 1);
    t.wire(src,'out', htr,'mat_in'); t.wire(htr,'mat_out', snk,'in');
    t.solve();
    const out = t.port(htr, 'mat_out');
    t.assertClose(out.T, 400, 1, 'T_out [K]');
    t.assertOK(out.phase === 'V', 'Phase = V', out.phase);
    const H_in = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:300, P:200000, n:{N2:10}});
    const H_ref = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:400, P:200000, n:{N2:10}});
    t.assertHBalance(thermo.getHdot_Jps(out), H_ref, 5e-3, 'H balance');
    t.assertOK((thermo.getHdot_Jps(out)-H_in)/1000 > 0, 'Q > 0');
  });

  test('Heater: H2O Boiling', t => {
    const src = t.place('source', 0, 1, { species:'H2O', nDot:1, T:90, P:101325, phaseConstraint:'L' });
    const htr = t.place('heater', 4, 1, { T_out:150 }); const snk = t.place('sink', 8, 1);
    t.wire(src,'out', htr,'mat_in'); t.wire(htr,'mat_out', snk,'in');
    t.solve();
    const out = t.port(htr, 'mat_out');
    t.assertClose(out.T, 423.15, 1, 'T_out [K]');
    t.assertOK(out.phase === 'V', 'Phase = V', out.phase);
    const Q_kW = (t.ud(htr).last.Q_actual_W || 0) / 1000;
    t.assertOK(Q_kW > 40, 'Q includes Hv', `${Q_kW.toFixed(1)} kW`);
    const H_in = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:363.15, P:101325, n:{H2O:1}});
    t.assertClose((thermo.getHdot_Jps(out)-H_in)/1000, Q_kW, Math.max(Q_kW*5e-3, 0.1), 'Q balance [kW]');
  });

  test('HEX: N2 Energy Balance', t => {
    const sH = t.place('source', 0, 2, { species:'N2', nDot:10, T:227, P:200000, phaseConstraint:'V' });
    const sC = t.place('source', 3, 0, { species:'N2', nDot:10, T:27, P:200000, phaseConstraint:'V' });
    const hex = t.place('hex', 4, 2, { T_hot_out:77 });
    const skH = t.place('sink', 8, 2); const skC = t.place('sink', 3, 5);
    t.wire(sH,'out', hex,'hot_in'); t.wire(hex,'hot_out', skH,'in');
    t.wire(sC,'out', hex,'cold_in'); t.wire(hex,'cold_out', skC,'in');
    t.solve();
    const hOut = t.port(hex,'hot_out'), cOut = t.port(hex,'cold_out');
    t.assertClose(hOut.T, 350, 1, 'T_hot_out [K]');
    t.assertOK(cOut.T > 300, 'T_cold_out > T_cold_in', cOut.T.toFixed(1));
    const Hi = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:500, P:200000, n:{N2:10}})
             + thermo.getHdot_Jps({type:StreamType.MATERIAL, T:300, P:200000, n:{N2:10}});
    const Ho = thermo.getHdot_Jps(hOut) + thermo.getHdot_Jps(cOut);
    t.assertClose(Math.abs(Ho-Hi), 0, Math.max(Math.abs(Hi)*5e-3, 10), '1st Law [J/s]');
    t.assertOK(t.ud(hex).last?.Q > 0, 'Q > 0');
    const Qh = (thermo.getHdot_Jps({type:StreamType.MATERIAL,T:500,P:200000,n:{N2:10}})-thermo.getHdot_Jps(hOut))/1000;
    const Qc = (thermo.getHdot_Jps(cOut)-thermo.getHdot_Jps({type:StreamType.MATERIAL,T:300,P:200000,n:{N2:10}}))/1000;
    t.assertClose(Qh, Qc, Math.max(Math.abs(Qh)*5e-3, 0.1), 'Q_hot â‰ˆ Q_cold');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION D: Power system â€” demand chains (Tests 27-30)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('ElecHeater: Demand Propagation', t => {
    const elSrc = t.place('battery', 0, 0, { maxPower:100 });
    const eh = t.place('electric_heater', 3, 0);  // eta hardcoded to 1.00
    const src = t.place('source', 0, 3, { species:'N2', nDot:10, T:27, P:200000, phaseConstraint:'V' });
    const htr = t.place('heater', 6, 1, { T_out:200 }); const snk = t.place('sink', 10, 1);
    t.wire(elSrc,'out', eh,'elec_in'); t.wire(eh,'heat_out', htr,'heat_in');
    t.wire(src,'out', htr,'mat_in'); t.wire(htr,'mat_out', snk,'in');
    t.solve();
    const out = t.port(htr, 'mat_out');
    const Qd = (t.ud(htr).last.Q_demand_W||0)/1000, Qa = (t.ud(htr).last.Q_actual_W||0)/1000;
    t.assertClose(out.T, 473.15, 1, 'T_out [K]');
    t.assertClose(Qa, Qd, 0.1, 'Q_actual=Q_demand');
    t.assertClose((t.ud(eh).last.Q_heat_demand_W||0)/1000, Qa, 0.1, 'EH Q [kW]');
    t.assertClose((t.ud(eh).powerDemand||0)/1000, Qa, 0.2, 'EH elec demand');  // Î·=1.00 â†’ elec = heat
    const Hin = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:300, P:200000, n:{N2:10}});
    t.assertClose((thermo.getHdot_Jps(out)-Hin)/1000, Qa, 1, 'H balance [kW]');
  });

  test('Motor+Compressor Demand', t => {
    const src = t.place('source', 0, 3, { species:'H2O', nDot:1, T:125, P:100000, phaseConstraint:'VL' });
    const comp = t.place('compressor', 4, 3, { Pout:500000, eta:0.75 });
    const snk = t.place('sink', 8, 3);
    const elSrc = t.place('battery', 0, 0, { maxPower:100 });
    const mot = t.place('motor', 3, 0, { eta:0.92 });
    t.wire(src,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.wire(elSrc,'out', mot,'elec_in'); t.wire(mot,'mech_out', comp,'power_in');
    t.solve();
    const Ws = (t.unit(comp).powerDemand||0)/1000;
    const Wm = (t.ud(mot).powerDemand||0)/1000;
    t.assertRange(Ws, 6, 12, 'W_shaft range [kW]');
    t.assertClose(Wm/Ws, 1/0.92, 0.01, 'Motor ratio');
    t.assertOK(t.port(comp,'mat_out').T > 390, 'T_out > 390K', t.port(comp,'mat_out').T?.toFixed(1));
  });

  test('Converters Need Elec Input', t => {
    const mot = t.place('motor', 0, 0);
    const eh = t.place('electric_heater', 0, 4);
    t.solveRaw();
    t.assertOK(!t.ud(mot)?.ports?.mech_out, 'Motor: no output');
    t.assertOK(!t.ud(eh)?.ports?.heat_out, 'EH: no output');
    t.assertClose(t.ud(mot)?.powerDemand || 0, 0, 1e-10, 'Motor demand=0');
    t.assertClose(t.ud(eh)?.powerDemand || 0, 0, 1e-10, 'EH demand=0');
  });

  test('Heater: Supply Limited', t => {
    const elSrc = t.place('battery', 0, 0, { maxPower:10 });
    const eh = t.place('electric_heater', 3, 0);  // eta hardcoded to 1.00
    const src = t.place('source', 0, 3, { species:'N2', nDot:10, T:27, P:200000, phaseConstraint:'V' });
    const htr = t.place('heater', 6, 1, { T_out:200 }); const snk = t.place('sink', 10, 1);
    t.wire(elSrc,'out', eh,'elec_in'); t.wire(eh,'heat_out', htr,'heat_in');
    t.wire(src,'out', htr,'mat_in'); t.wire(htr,'mat_out', snk,'in');
    t.solve();
    const out = t.port(htr, 'mat_out');
    t.assertOK(!!out, 'Output produced');
    t.assertOK(t.ud(htr).last?.supplyLimited === true, 'Supply limited');
    const Qa = (t.ud(htr).last.Q_actual_W||0)/1000, Qd = (t.ud(htr).last.Q_demand_W||0)/1000;
    t.assertOK(Qa < Qd * 0.5, 'Q_actual << Q_demand', `${Qa.toFixed(1)} vs ${Qd.toFixed(1)}`);
    t.assertOK(out.T < 473 - 10, 'T_actual < T_set', `${(out.T-273.15).toFixed(1)}Â°C`);
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION E: LV Separator & Flash Drum (Tests 31-34)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('LV-Sep: H2O Valve Flash', t => {
    const src = t.place('source', 0, 1, { species:'H2O', nDot:1, T:150, P:500000, phaseConstraint:'L' });
    const vlv = t.place('valve', 3, 1, { Pout:100000 });
    const sep = t.place('flash_drum', 6, 0);
    const skV = t.place('sink', 10, 0); const skL = t.place('sink', 10, 3);
    t.wire(src,'out', vlv,'in'); t.wire(vlv,'out', sep,'mat_in');
    t.wire(sep,'vap_out', skV,'in'); t.wire(sep,'liq_out', skL,'in');
    t.solve();
    const V = t.port(sep,'vap_out'), L = t.port(sep,'liq_out'), beta = t.last(sep)?.beta;
    t.assertOK(t.last(sep)?.phase === 'VL', 'Inlet VL');
    t.assertRange(beta, 0.01, 0.99, 'beta');
    t.assertClose((V.n?.H2O||0)+(L.n?.H2O||0), 1, 1e-6, 'Mass balance');
    t.assertClose(V.T, 373.15, 2, 'T_vap [K]'); t.assertClose(L.T, 373.15, 2, 'T_liq [K]');
    t.assertOK(V.phase === 'V', 'Vap phase=V'); t.assertOK(L.phase === 'L', 'Liq phase=L');
    const H_in = thermo.getHdot_Jps(t.port(vlv,'out'));
    t.assertClose(Math.abs((thermo.getHdot_Jps(V)+thermo.getHdot_Jps(L)-H_in)/H_in)*100, 0, 0.5, 'H balance [%]');
  });

  test('LV-Sep: N2/O2 Multicomponent', t => {
    const sN2 = t.place('source', 0, 0, { species:'N2', nDot:0.79, T:-193.15, P:100000, phaseConstraint:'V' });
    const sO2 = t.place('source', 0, 3, { species:'O2', nDot:0.21, T:-193.15, P:100000, phaseConstraint:'L' });
    const mix = t.place('mixer', 4, 1); const sep = t.place('flash_drum', 8, 0);
    const skV = t.place('sink', 12, 0); const skL = t.place('sink', 12, 3);
    t.wire(sN2,'out', mix,'in1'); t.wire(sO2,'out', mix,'in2');
    t.wire(mix,'out', sep,'mat_in'); t.wire(sep,'vap_out', skV,'in'); t.wire(sep,'liq_out', skL,'in');
    t.solve();
    const V = t.port(sep,'vap_out'), L = t.port(sep,'liq_out');
    t.assertOK(t.last(sep)?.phase === 'VL', 'Inlet VL');
    t.assertClose((V.n?.N2||0)+(L.n?.N2||0), 0.79, 1e-4, 'N2 balance');
    t.assertClose((V.n?.O2||0)+(L.n?.O2||0), 0.21, 1e-4, 'O2 balance');
    // N2 enriched in vapor (lighter, lower Tb)
    const nVtot = (V.n?.N2||0)+(V.n?.O2||0);
    t.assertOK(nVtot > 0 && (V.n?.N2||0)/nVtot > 0.79, 'Vap enriched N2');
    // O2 enriched in liquid (heavier, higher Tb)
    const nLtot = (L.n?.N2||0)+(L.n?.O2||0);
    t.assertOK(nLtot > 0 && (L.n?.O2||0)/nLtot > 0.21, 'Liq enriched O2');
    t.assertOK(V.phase === 'V', 'Vap phase=V'); t.assertOK(L.phase === 'L', 'Liq phase=L');
  });

  test('LV-Sep: Edge Cases (All V / All L)', t => {
    // Case A: All vapor (N2 at 300K)
    const sA = t.place('source', 0, 0, { species:'N2', nDot:5, T:27, P:100000, phaseConstraint:'V' });
    const sepA = t.place('flash_drum', 4, 0);
    const skVa = t.place('sink', 8, 0); const skLa = t.place('sink', 8, 3);
    t.wire(sA,'out', sepA,'mat_in'); t.wire(sepA,'vap_out', skVa,'in'); t.wire(sepA,'liq_out', skLa,'in');
    t.solve();
    const VA = t.port(sepA,'vap_out'), LA = t.port(sepA,'liq_out');
    t.assertClose(Object.values(VA?.n||{}).reduce((a,b)=>a+b,0), 5, 1e-6, 'A: Vap flow');
    t.assertOK(Object.values(LA?.n||{}).reduce((a,b)=>a+b,0) < 1e-10, 'A: Liq empty');
    t.assertOK(t.last(sepA)?.phase === 'V', 'A: phase=V');
    // Case B: All liquid (H2O at 25Â°C)
    t.clearScene();
    const sB = t.place('source', 0, 0, { species:'H2O', nDot:3, T:25, P:101325, phaseConstraint:'L' });
    const sepB = t.place('flash_drum', 4, 0);
    const skVb = t.place('sink', 8, 0); const skLb = t.place('sink', 8, 3);
    t.wire(sB,'out', sepB,'mat_in'); t.wire(sepB,'vap_out', skVb,'in'); t.wire(sepB,'liq_out', skLb,'in');
    t.solve();
    const VB = t.port(sepB,'vap_out'), LB = t.port(sepB,'liq_out');
    t.assertClose(Object.values(LB?.n||{}).reduce((a,b)=>a+b,0), 3, 1e-6, 'B: Liq flow');
    t.assertOK(Object.values(VB?.n||{}).reduce((a,b)=>a+b,0) < 1e-10, 'B: Vap empty');
    t.assertOK(t.last(sepB)?.phase === 'L', 'B: phase=L');
  });

  test('Flash Drum: H2O/CO2 VLE', t => {
    const sH2O = t.place('source', 0, 0, { species:'H2O', nDot:5, T:25, P:500000, phaseConstraint:'L' });
    const sCO2 = t.place('source', 0, 3, { species:'CO2', nDot:5, T:25, P:500000, phaseConstraint:'V' });
    const mix = t.place('mixer', 4, 1); const sep = t.place('flash_drum', 8, 0);
    const skV = t.place('sink', 12, 0); const skL = t.place('sink', 12, 3);
    t.wire(sH2O,'out', mix,'in1'); t.wire(sCO2,'out', mix,'in2');
    t.wire(mix,'out', sep,'mat_in'); t.wire(sep,'vap_out', skV,'in'); t.wire(sep,'liq_out', skL,'in');
    t.solve();
    const V = t.port(sep,'vap_out'), L = t.port(sep,'liq_out');
    t.assertClose((V.n?.H2O||0)+(L.n?.H2O||0), 5, 1e-4, 'H2O balance');
    t.assertClose((V.n?.CO2||0)+(L.n?.CO2||0), 5, 1e-4, 'CO2 balance');
    const nVt = (V.n?.H2O||0)+(V.n?.CO2||0);
    t.assertOK(nVt > 0 && (V.n?.CO2||0)/nVt > 0.5, 'Vap enriched CO2');
    const nLt = (L.n?.H2O||0)+(L.n?.CO2||0);
    t.assertOK(nLt > 0 && (L.n?.H2O||0)/nLt > 0.5, 'Liq enriched H2O');
    t.assertOK(t.last(sep)?.phase === 'VL', 'Inlet VL');
    const feed = t.port(t.ud(sep) ? Object.keys(scene.units.entries().next ? '' : '')[0] : '', 'out');
    const H_feed = thermo.getHdot_Jps(t.ud(mix)?.ports?.out || {type:StreamType.MATERIAL, T:298, P:500000, n:{H2O:5,CO2:5}});
    const H_sum = thermo.getHdot_Jps(V) + thermo.getHdot_Jps(L);
    t.assertClose(H_feed !== 0 ? Math.abs((H_sum-H_feed)/H_feed)*100 : 0, 0, 2, 'H balance [%]');
    t.assertOK(nVt > 0.01 && nLt > 0.01, 'Both outlets flow');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION E2: Flash Drum Extended (Tests 35-39)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Flash Drum: Ternary Air (N2/O2/Ar)', t => {
    // Synthetic air at cryogenic T (85 K), 1 atm:
    //   Tb: N2=77.4K, Ar=87.3K, O2=90.2K
    //   At 85K: N2 above Tb (vapour-enriched), O2 below Tb (liquid-enriched),
    //   Ar near its Tb (distributes)
    const sN2 = t.place('source', 0, 0, { species:'N2', nDot:0.78, T:-188.15, P:101325, phaseConstraint:'V' });
    const sO2 = t.place('source', 0, 3, { species:'O2', nDot:0.21, T:-188.15, P:101325, phaseConstraint:'L' });
    const sAr = t.place('source', 0, 6, { species:'Ar', nDot:0.01, T:-188.15, P:101325, phaseConstraint:'V' });

    const mixA = t.place('mixer', 4, 1);
    const mixB = t.place('mixer', 4, 5);
    const mixC = t.place('mixer', 8, 3);
    const sep  = t.place('flash_drum', 12, 2);
    const skV  = t.place('sink', 16, 2);
    const skL  = t.place('sink', 16, 5);

    // Three-input merge via two mixers (each mixer has 2 inputs)
    t.wire(sN2, 'out', mixA, 'in1');
    t.wire(sO2, 'out', mixA, 'in2');
    t.wire(mixA, 'out', mixB, 'in1');
    t.wire(sAr, 'out', mixB, 'in2');
    // need a second merge
    t.wire(mixB, 'out', sep, 'mat_in');
    t.wire(sep, 'vap_out', skV, 'in');
    t.wire(sep, 'liq_out', skL, 'in');
    t.solve();

    const V = t.port(sep, 'vap_out'), L = t.port(sep, 'liq_out');

    // Per-component mass balance
    t.assertClose((V.n?.N2||0) + (L.n?.N2||0), 0.78, 1e-4, 'N2 balance');
    t.assertClose((V.n?.O2||0) + (L.n?.O2||0), 0.21, 1e-4, 'O2 balance');
    t.assertClose((V.n?.Ar||0) + (L.n?.Ar||0), 0.01, 1e-4, 'Ar balance');

    // Total mass balance
    const nV_total = Object.values(V.n || {}).reduce((a, b) => a + b, 0);
    const nL_total = Object.values(L.n || {}).reduce((a, b) => a + b, 0);
    t.assertClose(nV_total + nL_total, 1.0, 1e-4, 'Total balance');

    // Enrichment: N2 enriched in vapor (most volatile)
    t.assertOK(nV_total > 0, 'Vapor flows');
    t.assertOK((V.n?.N2 || 0) / nV_total > 0.78, 'Vap enriched N2');
    // Enrichment: O2 enriched in liquid (least volatile)
    t.assertOK(nL_total > 0, 'Liquid flows');
    t.assertOK((L.n?.O2 || 0) / nL_total > 0.21, 'Liq enriched O2');

    // Phase tags
    t.assertOK(V.phase === 'V', 'Vap phase=V');
    t.assertOK(L.phase === 'L', 'Liq phase=L');
  });

  test('Flash Drum: Extreme Separation (H2 + H2O)', t => {
    // H2 (Tb=20.4K) + H2O (Tb=373.15K) at 25Â°C, 1 atm.
    // H2 is far above its critical T (33.2K) â†’ supercritical, strongly in vapor.
    // H2O is far below its Tb â†’ entirely liquid.
    // Note: H2 is supercritical at 298K so Antoine-based K is approximate;
    //       we test for strong enrichment, not perfect separation.
    const sH2  = t.place('source', 0, 0, { species:'H2',  nDot:3, T:25, P:101325, phaseConstraint:'V' });
    const sH2O = t.place('source', 0, 3, { species:'H2O', nDot:7, T:25, P:101325, phaseConstraint:'L' });
    const mix  = t.place('mixer', 4, 1);
    const sep  = t.place('flash_drum', 8, 0);
    const skV  = t.place('sink', 12, 0);
    const skL  = t.place('sink', 12, 3);

    t.wire(sH2, 'out', mix, 'in1');
    t.wire(sH2O, 'out', mix, 'in2');
    t.wire(mix, 'out', sep, 'mat_in');
    t.wire(sep, 'vap_out', skV, 'in');
    t.wire(sep, 'liq_out', skL, 'in');
    t.solve();

    const V = t.port(sep, 'vap_out'), L = t.port(sep, 'liq_out');

    // Mass balance (strict)
    t.assertClose((V.n?.H2 || 0) + (L.n?.H2 || 0),  3, 1e-4, 'H2 balance');
    t.assertClose((V.n?.H2O || 0) + (L.n?.H2O || 0), 7, 1e-4, 'H2O balance');

    // H2 strongly enriched in vapor (>90% â€” limited by supercritical Antoine approx)
    t.assertOK((V.n?.H2 || 0) > 2.7, 'H2 > 90% in vap');
    // H2O overwhelmingly in liquid (>99% â€” subcritical, Antoine reliable)
    t.assertOK((L.n?.H2O || 0) > 6.93, 'H2O > 99% in liq');

    // Vapor enriched in H2, liquid enriched in H2O
    const nVt = Object.values(V.n || {}).reduce((a, b) => a + b, 0);
    const nLt = Object.values(L.n || {}).reduce((a, b) => a + b, 0);
    t.assertOK(nVt > 0 && (V.n?.H2 || 0) / nVt > 0.5, 'Vap majority H2');
    t.assertOK(nLt > 0 && (L.n?.H2O || 0) / nLt > 0.9, 'Liq majority H2O');

    // Phase identification
    t.assertOK(t.last(sep)?.phase === 'VL', 'Feed is VL');
  });

  test('Flash Drum: Pressure Effect on Î²', t => {
    // Same H2O feed (150Â°C, 5 bar, liquid) throttled to different pressures.
    // Lower pressure â†’ more flash â†’ higher Î².
    //
    // Case A: valve to 1.0 bar (Tsatâ‰ˆ100Â°C â†’ lots of flashing)
    const srcA = t.place('source', 0, 0, { species:'H2O', nDot:1, T:150, P:500000, phaseConstraint:'L' });
    const vlvA = t.place('valve', 3, 0, { Pout:100000 });
    const sepA = t.place('flash_drum', 6, 0);
    const skVa = t.place('sink', 10, 0);
    const skLa = t.place('sink', 10, 3);
    t.wire(srcA, 'out', vlvA, 'in');
    t.wire(vlvA, 'out', sepA, 'mat_in');
    t.wire(sepA, 'vap_out', skVa, 'in');
    t.wire(sepA, 'liq_out', skLa, 'in');

    // Case B: valve to 3.0 bar (Tsatâ‰ˆ134Â°C â†’ less flashing)
    const srcB = t.place('source', 0, 6, { species:'H2O', nDot:1, T:150, P:500000, phaseConstraint:'L' });
    const vlvB = t.place('valve', 3, 6, { Pout:300000 });
    const sepB = t.place('flash_drum', 6, 6);
    const skVb = t.place('sink', 10, 6);
    const skLb = t.place('sink', 10, 9);
    t.wire(srcB, 'out', vlvB, 'in');
    t.wire(vlvB, 'out', sepB, 'mat_in');
    t.wire(sepB, 'vap_out', skVb, 'in');
    t.wire(sepB, 'liq_out', skLb, 'in');

    t.solve();

    const betaA = t.last(sepA)?.beta;
    const betaB = t.last(sepB)?.beta;
    t.assertOK(betaA !== undefined && betaB !== undefined, 'Both betas defined');

    // Both should flash (VL)
    t.assertOK(t.last(sepA)?.phase === 'VL', 'A: inlet VL');
    t.assertOK(t.last(sepB)?.phase === 'VL', 'B: inlet VL');

    // Both betas in (0,1) â€” partial flash
    t.assertRange(betaA, 0.01, 0.99, 'A: beta partial');
    t.assertRange(betaB, 0.01, 0.99, 'B: beta partial');

    // Core assertion: lower outlet P â†’ higher beta (more evaporation)
    t.assertOK(betaA > betaB, 'Î²(1bar) > Î²(3bar)', `${betaA?.toFixed(4)} > ${betaB?.toFixed(4)}`);

    // Mass balance both cases
    const Va = t.port(sepA, 'vap_out'), La = t.port(sepA, 'liq_out');
    const Vb = t.port(sepB, 'vap_out'), Lb = t.port(sepB, 'liq_out');
    t.assertClose((Va.n?.H2O||0) + (La.n?.H2O||0), 1, 1e-6, 'A: mass balance');
    t.assertClose((Vb.n?.H2O||0) + (Lb.n?.H2O||0), 1, 1e-6, 'B: mass balance');
  });

  test('Flash Drum: Adiabatic Enthalpy Balance', t => {
    // The flash drum is adiabatic: H_vap_out + H_liq_out = H_feed.
    // Use CH4/CO2 at cryogenic conditions (interesting VLE) and check
    // strict enthalpy conservation via getHdot_Jps.
    const sCH4 = t.place('source', 0, 0, { species:'CH4', nDot:3, T:-120, P:200000, phaseConstraint:'V' });
    const sCO2 = t.place('source', 0, 3, { species:'CO2', nDot:2, T:-120, P:200000, phaseConstraint:'V' });
    const mix  = t.place('mixer', 4, 1);
    const sep  = t.place('flash_drum', 8, 0);
    const skV  = t.place('sink', 12, 0);
    const skL  = t.place('sink', 12, 3);

    t.wire(sCH4, 'out', mix, 'in1');
    t.wire(sCO2, 'out', mix, 'in2');
    t.wire(mix, 'out', sep, 'mat_in');
    t.wire(sep, 'vap_out', skV, 'in');
    t.wire(sep, 'liq_out', skL, 'in');
    t.solve();

    // Get inlet enthalpy from mixer output
    const mixOut = t.ud(mix)?.ports?.out;
    const H_feed = thermo.getHdot_Jps(mixOut);
    t.assertOK(H_feed !== 0 && isFinite(H_feed), 'H_feed valid', H_feed?.toFixed(1));

    // Get outlet enthalpies
    const V = t.port(sep, 'vap_out'), L = t.port(sep, 'liq_out');
    const H_vap = thermo.getHdot_Jps(V);
    const H_liq = thermo.getHdot_Jps(L);
    const H_sum = H_vap + H_liq;

    // Relative enthalpy error should be < 1%
    const relErr = Math.abs(H_feed) > 1 ? Math.abs((H_sum - H_feed) / H_feed) * 100 : 0;
    t.assertClose(relErr, 0, 1.0, 'Î”H relative [%]');

    // Mass balance
    t.assertClose((V.n?.CH4||0) + (L.n?.CH4||0), 3, 1e-4, 'CH4 balance');
    t.assertClose((V.n?.CO2||0) + (L.n?.CO2||0), 2, 1e-4, 'CO2 balance');
  });

  test('Flash Drum: K-value Consistency', t => {
    // For a VL flash, the flash drum reports K_comp = y_comp / x_comp.
    // Verify these are consistent with the outlet mole fractions computed
    // from nV and nL.
    const sN2 = t.place('source', 0, 0, { species:'N2', nDot:0.79, T:-188.15, P:101325, phaseConstraint:'V' });
    const sO2 = t.place('source', 0, 3, { species:'O2', nDot:0.21, T:-188.15, P:101325, phaseConstraint:'L' });
    const mix  = t.place('mixer', 4, 1);
    const sep  = t.place('flash_drum', 8, 0);
    const skV  = t.place('sink', 12, 0);
    const skL  = t.place('sink', 12, 3);

    t.wire(sN2, 'out', mix, 'in1');
    t.wire(sO2, 'out', mix, 'in2');
    t.wire(mix, 'out', sep, 'mat_in');
    t.wire(sep, 'vap_out', skV, 'in');
    t.wire(sep, 'liq_out', skL, 'in');
    t.solve();

    const V = t.port(sep, 'vap_out'), L = t.port(sep, 'liq_out');
    const last = t.last(sep);
    t.assertOK(last?.phase === 'VL', 'Feed is VL');

    // Compute mole fractions from outlet compositions
    const nV_total = Object.values(V.n || {}).reduce((a, b) => a + b, 0);
    const nL_total = Object.values(L.n || {}).reduce((a, b) => a + b, 0);
    t.assertOK(nV_total > 1e-6 && nL_total > 1e-6, 'Both phases present');

    const y_N2 = (V.n?.N2 || 0) / nV_total;
    const y_O2 = (V.n?.O2 || 0) / nV_total;
    const x_N2 = (L.n?.N2 || 0) / nL_total;
    const x_O2 = (L.n?.O2 || 0) / nL_total;

    // y + x should each sum to 1
    t.assertClose(y_N2 + y_O2, 1, 1e-6, 'Î£y = 1');
    t.assertClose(x_N2 + x_O2, 1, 1e-6, 'Î£x = 1');

    // K_i = y_i / x_i from our computed fractions
    const K_N2_calc = y_N2 / x_N2;
    const K_O2_calc = y_O2 / x_O2;

    // Flash drum reports K values in u.last
    const K_N2_rep = last?.K_N2;
    const K_O2_rep = last?.K_O2;
    t.assertOK(K_N2_rep !== undefined, 'K_N2 reported', K_N2_rep?.toFixed(4));
    t.assertOK(K_O2_rep !== undefined, 'K_O2 reported', K_O2_rep?.toFixed(4));

    // Cross-check: reported K â‰ˆ calculated K
    t.assertClose(K_N2_rep, K_N2_calc, 0.01, 'K_N2 consistent');
    t.assertClose(K_O2_rep, K_O2_calc, 0.01, 'K_O2 consistent');

    // Physical check: K_N2 > K_O2 (N2 more volatile)
    t.assertOK(K_N2_calc > K_O2_calc, 'K_N2 > K_O2');
    // K_N2 > 1 (enriched in vapor), K_O2 < 1 (enriched in liquid)
    t.assertOK(K_N2_calc > 1.0, 'K_N2 > 1');
    t.assertOK(K_O2_calc < 1.0, 'K_O2 < 1');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION F: Power Hub (Tests 40-45)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Hub: Input Aggregation', t => {
    const fA = t.place('source_electrical', 0, 0, { maxPower:50 });
    const fB = t.place('source_electrical', 0, 3, { maxPower:30 });
    const bat = t.place('battery', 0, 6, { maxPower:20 });
    const hub = t.place('power_hub', 4, 2); const hs = t.place('sink_heat', 4, 0);
    t.wire(fA,'out', hub,'elec_in'); t.wire(fB,'out', hub,'elec_in');
    t.wire(bat,'out', hub,'elec_in'); t.wire(hub,'heat_out', hs,'in');
    t.solve();
    const h = t.unit(hub);
    t.assertClose(h.last.fixedSupply_W, 80000, 1, 'Fixed supply');
    t.assertClose(h.last.batteryMax_W, 20000, 1, 'Battery max');
    t.assertClose(h.last.totalCapacity_W, 100000, 1, 'Total capacity');
    t.assertClose(h.last.surplus_W, 80000, 1, 'Surplus = fixed');
    // MultiConnect via scene.connect()
    const ts = new Scene();
    const tb1 = ts.placeUnit('source_electrical', 0, 0), tb2 = ts.placeUnit('battery', 0, 3), th = ts.placeUnit('power_hub', 4, 1);
    t.assertOK(ts.connect({unitId:tb1,portId:'out'},{unitId:th,portId:'elec_in'}) && ts.connect({unitId:tb2,portId:'out'},{unitId:th,portId:'elec_in'}), 'multiConnect OK');
    t.assertClose(t.unit(hs).last.absorbed_W || 0, 80000, 1, 'Heat sink absorbed');
  });

  test('Hub: Sufficient Supply', t => {
    const fix = t.place('source_electrical', 0, 0, { maxPower:50 });
    const bat = t.place('battery', 0, 6, { maxPower:30 });
    const hub = t.place('power_hub', 4, 1);
    const mot = t.place('motor', 8, 0, { eta:0.92 });
    const sN2 = t.place('source', 0, 10, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 12, 3, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 16, 3); const hs = t.place('sink_heat', 4, 7);
    t.wire(fix,'out', hub,'elec_in'); t.wire(bat,'out', hub,'elec_in');
    t.wire(hub,'elec_out', mot,'elec_in'); t.wire(mot,'mech_out', comp,'power_in');
    t.wire(hub,'heat_out', hs,'in');
    t.wire(sN2,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.solve();
    const h = t.unit(hub), dem = (h.last.totalDemand_W||0)/1000;
    t.assertRange(dem, 1, 20, 'Hub demand [kW]');
    t.assertClose(h.last.curtailmentFactor, 1, 0.001, 'Curtailment = 1');
    t.assertClose((h.last.batteryDraw_W||0)/1000, 0, 0.1, 'Battery draw = 0');
    t.assertClose((h.last.surplus_W||0)/1000, 50-dem, 0.5, 'Surplus [kW]');
    t.assertClose((t.unit(hs).last.absorbed_W||0)/1000, (h.last.surplus_W||0)/1000, 0.5, 'Heat sink = surplus');
  });

  test('Hub: Curtailment', t => {
    const b1 = t.place('battery', 0, 0, { maxPower:1 });
    const b2 = t.place('battery', 0, 6, { maxPower:1 });
    const hub = t.place('power_hub', 4, 1);
    const mot = t.place('motor', 8, 0, { eta:0.92 });
    const sN2 = t.place('source', 0, 10, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 12, 3, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 16, 3); const hs = t.place('sink_heat', 4, 7);
    t.wire(b1,'out', hub,'elec_in'); t.wire(b2,'out', hub,'elec_in');
    t.wire(hub,'elec_out', mot,'elec_in'); t.wire(mot,'mech_out', comp,'power_in');
    t.wire(hub,'heat_out', hs,'in');
    t.wire(sN2,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.solve();
    const h = t.unit(hub);
    t.assertRange(h.last.curtailmentFactor, 0.001, 0.999, 'Curtailment < 1');
    t.assertClose((h.last.batteryDraw_W||0)/1000, 2, 0.01, 'Battery draw [kW]');
    t.assertClose((h.last.totalSupply_W||0)/1000, 2, 0.01, 'Supply = 2kW');
    t.assertClose((h.last.surplus_W||0)/1000, 0, 0.01, 'Surplus = 0');
    t.assertClose(t.unit(hs).last.absorbed_W||0, 0, 10, 'Heat sink = 0');
  });

  test('Compressor: Curtailed Outlet', t => {
    const bat = t.place('battery', 0, 0, { maxPower:1 });
    const mot = t.place('motor', 3, 0, { eta:0.92 });
    const sN2 = t.place('source', 0, 4, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 2, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 11, 2);
    t.wire(bat,'out', mot,'elec_in'); t.wire(mot,'mech_out', comp,'power_in');
    t.wire(sN2,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.solve();
    const out = t.port(comp, 'mat_out');
    t.assertOK(out, 'Outlet exists');
    t.assertOK(out?.P > 101000, 'P_out > P_in', `${(out?.P/100000).toFixed(3)} bar`);
    t.assertOK(out?.P < 299000, 'P_out < setpoint', `${(out?.P/100000).toFixed(3)} bar`);
    t.assertOK(t.unit(comp).last.curtailed === true, 'Curtailed flag');
    if (out?.T) {
      const Hin = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:298.15, P:100000, n:{N2:1}});
      t.assertClose(Math.abs((thermo.getHdot_Jps(out)-Hin)-(t.unit(comp).last.W_shaft||0))/1000, 0, 0.05, 'H balance [kW]');
    }
    t.assertOK(out?.T > 299, 'T_out > T_in', `${out?.T?.toFixed(1)} K`);
  });

  test('Battery: Direct Shortage', t => {
    const bat = t.place('battery', 0, 0, { maxPower:2 });
    const mot = t.place('motor', 3, 0, { eta:0.92 });
    const sN2 = t.place('source', 0, 4, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 2, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 11, 2);
    t.wire(bat,'out', mot,'elec_in'); t.wire(mot,'mech_out', comp,'power_in');
    t.wire(sN2,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.solve();
    t.assertOK(t.ud(bat).last.shortage_W > 0, 'Battery shortage');
    t.assertOK(t.ud(bat).last.error?.severity, 'Battery error');
    t.assertOK(t.port(comp,'mat_out'), 'Comp outlet exists');
    t.assertOK(t.unit(comp).last.curtailed === true, 'Comp curtailed');
    t.assertClose(t.ud(mot).last.W_elec_W/1000, 2, 0.01, 'Motor capped [kW]');
  });

  test('Hub: Proportional Curtailment', t => {
    const fix = t.place('source_electrical', 0, 0, { maxPower:5 });
    const hub = t.place('power_hub', 3, 1); const hs = t.place('sink_heat', 3, -2);
    const mA = t.place('motor', 7, 0, { eta:0.92 });
    const sA = t.place('source', 7, 4, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const cA = t.place('compressor', 11, 1, { Pout:300000, eta:0.75 });
    const skA = t.place('sink', 15, 1);
    const mB = t.place('motor', 7, 6, { eta:0.92 });
    const sB = t.place('source', 7, 10, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const cB = t.place('compressor', 11, 7, { Pout:300000, eta:0.75 });
    const skB = t.place('sink', 15, 7);
    t.wire(fix,'out', hub,'elec_in'); t.wire(hub,'heat_out', hs,'in');
    t.wire(hub,'elec_out', mA,'elec_in'); t.wire(mA,'mech_out', cA,'power_in');
    t.wire(sA,'out', cA,'mat_in'); t.wire(cA,'mat_out', skA,'in');
    t.wire(hub,'elec_out', mB,'elec_in'); t.wire(mB,'mech_out', cB,'power_in');
    t.wire(sB,'out', cB,'mat_in'); t.wire(cB,'mat_out', skB,'in');
    t.solve();
    const h = t.unit(hub);
    const WA = t.ud(mA).last.W_elec_W, WB = t.ud(mB).last.W_elec_W;
    t.assertRange(h.last.curtailmentFactor, 0.001, 0.999, 'Curtailment < 1');
    t.assertClose(WA/WB, 1, 0.01, 'Equal power ratio');
    t.assertClose((WA+WB)/1000, 5, 0.05, 'Total = supply');
    t.assertOK(t.port(cA,'mat_out') && t.port(cB,'mat_out'), 'Both outputs');
    const Pa = t.port(cA,'mat_out')?.P, Pb = t.port(cB,'mat_out')?.P;
    if (Pa && Pb) t.assertClose(Pa/Pb, 1, 0.01, 'P ratio = 1');
    t.assertClose((h.last.surplus_W||0)/1000, 0, 0.01, 'Surplus = 0');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION G: Gas Turbine & Generator (Tests 46-49)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Gas Turbine: N2 Expansion', t => {
    const src = t.place('source', 0, 0, { species:'N2', nDot:1, T:200, P:300000, phaseConstraint:'V' });
    const turb = t.place('gas_turbine', 4, 0, { Pout:100000, eta:0.85 });
    const snk = t.place('sink', 8, 0);
    t.wire(src,'out', turb,'mat_in'); t.wire(turb,'mat_out', snk,'in');
    t.solve();
    const out = t.port(turb,'mat_out'), mech = t.port(turb,'mech_out');
    t.assertOK(out?.T, 'Outlet exists');
    t.assertOK(out.T < 473.15 - 10, 'T_out < T_in', `${out.T.toFixed(1)} K`);
    const W = t.unit(turb).last.W_shaft;
    t.assertOK(W > 100, 'W_shaft > 0', `${(W/1000).toFixed(3)} kW`);
    // Use .actual (canonical), fallback to .available for back-compat
    t.assertClose(mech?.actual ?? mech?.available ?? 0, W, 1, 'mech_out power');
    const Hin = thermo.getHdot_Jps({type:StreamType.MATERIAL, T:473.15, P:300000, n:{N2:1}});
    t.assertClose(Math.abs((Hin-thermo.getHdot_Jps(out))-W)/1000, 0, 0.05, 'Energy balance [kW]');
    t.assertClose(out.P, 100000, 1, 'P_out [Pa]');
    const Wi = t.unit(turb).last.W_isentropic;
    t.assertOK(Wi > W + 1, 'W_isen > W_shaft');
  });

  test('Turbine + Generator Chain', t => {
    const src = t.place('source', 0, 2, { species:'N2', nDot:1, T:300, P:500000, phaseConstraint:'V' });
    const turb = t.place('gas_turbine', 4, 2, { Pout:100000, eta:0.85 });
    const snk = t.place('sink', 8, 2);
    const gen = t.place('generator', 4, 5, { eta:0.95 });
    const eSnk = t.place('sink_electrical', 8, 5);
    t.wire(src,'out', turb,'mat_in'); t.wire(turb,'mat_out', snk,'in');
    t.wire(turb,'mech_out', gen,'mech_in'); t.wire(gen,'elec_out', eSnk,'in');
    t.solve();
    const W = t.unit(turb).last.W_shaft, We = t.ud(gen).last.W_elec_W;
    t.assertClose(t.ud(gen).last.W_mech_W, W, 1, 'Gen receives W_shaft');
    t.assertClose(We, W * 0.95, 1, 'W_elec = W Ã— Î·_gen');
    t.assertClose(t.ud(eSnk).last.absorbed_W, We, 1, 'Sink absorbs');
    t.assertClose(We / t.unit(turb).last.W_isentropic, 0.8075, 0.005, 'Overall Î·');
  });

  test('Turbine+Gen â†’ Hub Producer', t => {
    const sHot = t.place('source', 0, 2, { species:'N2', nDot:2, T:300, P:500000, phaseConstraint:'V' });
    const turb = t.place('gas_turbine', 4, 2, { Pout:100000, eta:0.85 });
    const skGas = t.place('sink', 8, 2);
    const gen = t.place('generator', 4, 5, { eta:0.95 });
    const hub = t.place('power_hub', 8, 5); const hs = t.place('sink_heat', 6, 3);
    const mot = t.place('motor', 12, 4, { eta:0.92 });
    const sCold = t.place('source', 12, 8, { species:'N2', nDot:0.5, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 16, 5, { Pout:200000, eta:0.75 });
    const skComp = t.place('sink', 20, 5);
    t.wire(sHot,'out', turb,'mat_in'); t.wire(turb,'mat_out', skGas,'in');
    t.wire(turb,'mech_out', gen,'mech_in'); t.wire(gen,'elec_out', hub,'elec_in');
    t.wire(hub,'heat_out', hs,'in'); t.wire(hub,'elec_out', mot,'elec_in');
    t.wire(mot,'mech_out', comp,'power_in');
    t.wire(sCold,'out', comp,'mat_in'); t.wire(comp,'mat_out', skComp,'in');
    t.solve();
    const h = t.unit(hub), genE = (t.ud(gen).last.W_elec_W||0)/1000;
    t.assertClose((h.last.fixedSupply_W||0)/1000, genE, 0.01, 'Hub fixed = gen output');
    t.assertOK(t.port(comp,'mat_out')?.T, 'Comp outlet exists');
    t.assertOK((h.last.surplus_W||0) > 0, 'Surplus > 0');
    const hubHeat = t.port(hub,'heat_out');
    // Use .actual (canonical), fallback to .available
    t.assertClose((hubHeat?.actual ?? hubHeat?.available ?? 0)/1000, (h.last.surplus_W||0)/1000, 0.01, 'Heat = surplus');
    t.assertClose(h.last.curtailmentFactor, 1, 0.001, 'No curtailment');
  });

  test('Turbine: Liquid Inlet Error', t => {
    const src = t.place('source', 0, 0, { species:'H2O', nDot:1, T:25, P:500000, phaseConstraint:'L' });
    const turb = t.place('gas_turbine', 4, 0, { Pout:100000, eta:0.85 });
    const snk = t.place('sink', 8, 0);
    t.wire(src,'out', turb,'mat_in'); t.wire(turb,'mat_out', snk,'in');
    t.solveRaw();
    t.assertOK(t.unit(turb).last?.error?.severity === ErrorSeverity.CATASTROPHIC, 'CATASTROPHIC error');
    const out = t.port(turb, 'mat_out');
    t.assertOK(!out || !out.T, 'No outlet');
    t.assertOK(t.unit(turb).last?.error?.message?.toLowerCase().includes('liquid'), 'Mentions liquid');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION H: Per-Consumer Allocation (Test 50)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Hub: Per-Consumer Allocation', t => {
    const fix = t.place('source_electrical', 0, 0, { maxPower:10 });
    const hub = t.place('power_hub', 3, 1); const hs = t.place('sink_heat', 3, -2);
    const mA = t.place('motor', 7, 0, { eta:0.92 });
    const sA = t.place('source', 7, 4, { species:'N2', nDot:2, T:25, P:100000, phaseConstraint:'V' });
    const cA = t.place('compressor', 11, 1, { Pout:500000, eta:0.75 });
    const skA = t.place('sink', 15, 1);
    const mB = t.place('motor', 7, 6, { eta:0.92 });
    const sB = t.place('source', 7, 10, { species:'N2', nDot:0.5, T:25, P:100000, phaseConstraint:'V' });
    const cB = t.place('compressor', 11, 7, { Pout:200000, eta:0.75 });
    const skB = t.place('sink', 15, 7);
    t.wire(fix,'out', hub,'elec_in'); t.wire(hub,'heat_out', hs,'in');
    t.wire(hub,'elec_out', mA,'elec_in'); t.wire(mA,'mech_out', cA,'power_in');
    t.wire(sA,'out', cA,'mat_in'); t.wire(cA,'mat_out', skA,'in');
    t.wire(hub,'elec_out', mB,'elec_in'); t.wire(mB,'mech_out', cB,'power_in');
    t.wire(sB,'out', cB,'mat_in'); t.wire(cB,'mat_out', skB,'in');
    t.solve();
    const h = t.unit(hub), alloc = h.last.consumerAllocation;
    t.assertOK(alloc, 'Allocation map exists');
    if (!alloc) return;
    const entries = Object.values(alloc);
    t.assertClose(entries.length, 2, 0, 'Two consumers');
    const cf = h.last.curtailmentFactor;
    t.assertOK(cf < 1, 'Curtailed');
    t.assertOK(entries.every(e => Math.abs(e.factor - cf) < 0.001), 'Same factor');
    t.assertClose(entries[0].factor, cf, 0.001, 'Factor = global CF');
    const [eA, eB] = entries;
    t.assertOK(eA.demand_W !== eB.demand_W, 'Unequal demands');
    const e0 = entries[0];
    t.assertClose(Math.abs(e0.allocated_W - e0.demand_W * e0.factor), 0, 1, 'alloc=demandÃ—factor');
    const WA = t.ud(mA).last.W_elec_W, WB = t.ud(mB).last.W_elec_W;
    t.assertOK(WA > WB, 'Motor A > Motor B');
    t.assertOK(t.unit(mA)._hubAllocFactor !== undefined && t.unit(mB)._hubAllocFactor !== undefined, '_hubAllocFactor set');
    t.assertClose(t.unit(mA)._hubAllocFactor, cf, 0.001, 'Factor matches CF');
    t.assertClose((WA+WB)/1000, 10, 0.1, 'Total = supply');
    t.assertOK(entries.every(e => e.priority === 1), 'Default priority = 1');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION I: New tests â€” Pump/Compressor without power_in (Tests 51-52)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Pump: No Power Input Error', t => {
    const src = t.place('source', 0, 0, { species:'H2O', nDot:5, T:25, P:100000, phaseConstraint:'L' });
    const pmp = t.place('pump', 3, 0, { Pout:500000, eta:0.70 });
    const snk = t.place('sink', 6, 0);
    t.wire(src,'out', pmp,'mat_in'); t.wire(pmp,'mat_out', snk,'in');
    t.solveRaw();
    const last = t.unit(pmp).last;
    t.assertOK(last?.error?.severity === ErrorSeverity.MAJOR, 'MAJOR error');
    t.assertOK(last?.error?.message?.toLowerCase().includes('power'), 'Mentions power');
    t.assertClose(t.unit(pmp).powerDemand || 0, 0, 1e-10, 'powerDemand = 0');
    // Outlet should be passthrough at inlet conditions
    const out = t.port(pmp, 'mat_out');
    t.assertOK(out, 'Passthrough outlet exists');
    if (out) t.assertClose(out.P, 100000, 1, 'P = inlet P (passthrough)');
  });

  test('Compressor: No Power Input Error', t => {
    const src = t.place('source', 0, 0, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 3, 0, { Pout:500000, eta:0.75 });
    const snk = t.place('sink', 6, 0);
    t.wire(src,'out', comp,'mat_in'); t.wire(comp,'mat_out', snk,'in');
    t.solveRaw();
    const last = t.unit(comp).last;
    t.assertOK(last?.error?.severity === ErrorSeverity.MAJOR, 'MAJOR error');
    t.assertOK(last?.error?.message?.toLowerCase().includes('power'), 'Mentions power');
    t.assertClose(t.unit(comp).powerDemand || 0, 0, 1e-10, 'powerDemand = 0');
    const out = t.port(comp, 'mat_out');
    t.assertOK(out, 'Passthrough outlet exists');
    if (out) t.assertClose(out.P, 100000, 1, 'P = inlet P (passthrough)');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION J: Power Cycle Prevention, Hub-to-Hub Guard & Recycle Loop (Tests 53-59)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Power Cycle: connect() Rejects Loop', t => {
    // Build: Hub â†’ Motor â†’ (mech) â†’ Generator â†’ (elec) â†’ Hub
    // The last connection (Generator.elec_out â†’ Hub.elec_in) should be rejected
    // by Scene.connect() because it closes a power cycle.
    const hub  = t.place('power_hub',         0, 0);
    const mot  = t.place('motor',             4, 0, { eta: 0.92 });
    const gen  = t.place('generator',         8, 0, { eta: 0.95 });
    const hs   = t.place('sink_heat',         0, 4);

    // These connections are fine â€” no cycle yet
    const c1 = scene.connect(
      { unitId: hub, portId: 'elec_out' },
      { unitId: mot, portId: 'elec_in'  }
    );
    t.assertOK(c1, 'Hubâ†’Motor accepted');

    const c2 = scene.connect(
      { unitId: mot, portId: 'mech_out' },
      { unitId: gen, portId: 'mech_in'  }
    );
    t.assertOK(c2, 'Motorâ†’Generator accepted');

    // Need a heat sink for the hub
    scene.connect(
      { unitId: hub, portId: 'heat_out' },
      { unitId: hs,  portId: 'in'       }
    );

    // This connection would close the power cycle â€” should be REJECTED
    const c3 = scene.connect(
      { unitId: gen, portId: 'elec_out' },
      { unitId: hub, portId: 'elec_in'  }
    );
    t.assertOK(c3 === null, 'Genâ†’Hub REJECTED', c3 || 'null');
    t.assertOK(
      scene._lastConnectError && scene._lastConnectError.toLowerCase().includes('cycle'),
      'Error mentions cycle',
      scene._lastConnectError
    );
  });

  test('Power Cycle: Solver Detects Imported Cycle', t => {
    // Bypass connect() by using wire() (simulating an import) to create
    // a power cycle.  The solver must detect it and return ok: false.
    const hub  = t.place('power_hub',   0, 0);
    const mot  = t.place('motor',       4, 0, { eta: 0.92 });
    const gen  = t.place('generator',   8, 0, { eta: 0.95 });
    const hs   = t.place('sink_heat',   0, 4);

    t.wire(hub, 'elec_out', mot, 'elec_in');
    t.wire(mot, 'mech_out', gen, 'mech_in');
    t.wire(gen, 'elec_out', hub, 'elec_in');   // closes the cycle!
    t.wire(hub, 'heat_out', hs,  'in');

    const r = t.solveRaw();
    t.assertOK(r.ok === false, 'solver.ok = false');
    t.assertOK(r.hasErrors,    'hasErrors = true');

    // The solver should have stored the cycle path
    t.assertOK(scene.runtime.powerCycle, 'powerCycle recorded');
    t.assertOK(scene.runtime.powerCycle?.length >= 2, 'cycle has â‰¥ 2 units');

    // At least one diagnostic should mention the power cycle
    const hasCycleDiag = r.diagnostics.some(d =>
      d.originalMessage?.toLowerCase().includes('power cycle') ||
      d.title?.toLowerCase().includes('power cycle')
    );
    t.assertOK(hasCycleDiag, 'Diagnostic mentions power cycle');
  });

  test('Hub-to-Hub: connect() Rejects', t => {
    // Two hubs connected directly should be rejected
    const hubA = t.place('power_hub', 0, 0);
    const hubB = t.place('power_hub', 4, 0);
    const hs   = t.place('sink_heat', 0, 4);

    // Attempt Hub A elec_out â†’ Hub B elec_in â€” should be rejected
    const c1 = scene.connect(
      { unitId: hubA, portId: 'elec_out' },
      { unitId: hubB, portId: 'elec_in'  }
    );
    t.assertOK(c1 === null, 'Hubâ†’Hub REJECTED', c1 || 'null');
    t.assertOK(
      scene._lastConnectError && scene._lastConnectError.toLowerCase().includes('hub'),
      'Error mentions hub',
      scene._lastConnectError
    );

    // Reverse direction should also be rejected
    const c2 = scene.connect(
      { unitId: hubB, portId: 'elec_out' },
      { unitId: hubA, portId: 'elec_in'  }
    );
    t.assertOK(c2 === null, 'Hubâ†Hub REJECTED', c2 || 'null');
  });

  test('Hub-to-Hub: Solver Detects Imported', t => {
    // Bypass connect() via wire() to simulate an imported file
    const src  = t.place('source_electrical', 0, 0, { maxPower: 10 });
    const hubA = t.place('power_hub', 3, 0);
    const hubB = t.place('power_hub', 7, 0);
    const hs   = t.place('sink_heat', 3, 4);

    t.wire(src, 'out', hubA, 'elec_in');
    t.wire(hubA, 'elec_out', hubB, 'elec_in');  // hub-to-hub!
    t.wire(hubA, 'heat_out', hs, 'in');

    const r = t.solveRaw();
    t.assertOK(r.ok === false, 'solver.ok = false');
    t.assertOK(r.hasErrors, 'hasErrors = true');

    // At least one diagnostic should mention hub-to-hub
    const hasH2HDiag = r.diagnostics.some(d =>
      d.originalMessage?.toLowerCase().includes('hub-to-hub') ||
      d.title?.toLowerCase().includes('hub-to-hub')
    );
    t.assertOK(hasH2HDiag, 'Diagnostic mentions hub-to-hub');
  });

  test('Hub-to-Hub: Blocked in Realistic Topology', t => {
    // Full topology: SourceElec â†’ HubA â†’ [HubB blocked] â†’ Motor â†’ Compressor
    // All connections except the hub-to-hub link should succeed.
    const src  = t.place('source_electrical', 0, 0, { maxPower: 50 });
    const hubA = t.place('power_hub',         3, 0);
    const hubB = t.place('power_hub',         7, 0);
    const mot  = t.place('motor',            11, 0, { eta: 0.92 });
    const sN2  = t.place('source',           11, 4, { species:'N2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor',       15, 1, { Pout:300000, eta:0.75 });
    const snk  = t.place('sink',             19, 1);
    const hsA  = t.place('sink_heat',         3, -3);
    const hsB  = t.place('sink_heat',         7, -3);

    // Valid connections â€” all should succeed
    const c1 = scene.connect({ unitId: src,  portId: 'out' },      { unitId: hubA, portId: 'elec_in' });
    const c2 = scene.connect({ unitId: hubA, portId: 'heat_out' }, { unitId: hsA,  portId: 'in' });
    const c3 = scene.connect({ unitId: hubB, portId: 'elec_out' }, { unitId: mot,  portId: 'elec_in' });
    const c4 = scene.connect({ unitId: hubB, portId: 'heat_out' }, { unitId: hsB,  portId: 'in' });
    t.assertOK(c1, 'Srcâ†’HubA OK');
    t.assertOK(c2, 'HubA heat OK');
    t.assertOK(c3, 'HubBâ†’Motor OK');
    t.assertOK(c4, 'HubB heat OK');

    // The hub-to-hub link â€” must be rejected
    const cBad = scene.connect({ unitId: hubA, portId: 'elec_out' }, { unitId: hubB, portId: 'elec_in' });
    t.assertOK(cBad === null, 'HubAâ†’HubB REJECTED');
    t.assertOK(
      scene._lastConnectError?.toLowerCase().includes('hub'),
      'Error mentions hub',
      scene._lastConnectError
    );
  });

  test('Hub-to-Hub: Motor Between Hubs Allowed', t => {
    // The recommended workaround: Hub â†’ Motor â†’ second Hub
    // This must NOT be blocked â€” the motor acts as demand relay.
    const src  = t.place('source_electrical', 0, 0, { maxPower: 50 });
    const hubA = t.place('power_hub',         3, 0);
    const mot  = t.place('motor',             7, 0, { eta: 0.92 });
    const gen  = t.place('generator',        11, 0, { eta: 0.95 });
    const hubB = t.place('power_hub',        15, 0);
    const eSk  = t.place('sink_electrical',  19, 0);
    const hsA  = t.place('sink_heat',         3, -3);
    const hsB  = t.place('sink_heat',        15, -3);

    // Build the full chain via connect()
    const c1 = scene.connect({ unitId: src,  portId: 'out' },       { unitId: hubA, portId: 'elec_in'  });
    const c2 = scene.connect({ unitId: hubA, portId: 'elec_out' },  { unitId: mot,  portId: 'elec_in'  });
    const c3 = scene.connect({ unitId: mot,  portId: 'mech_out' },  { unitId: gen,  portId: 'mech_in'  });
    const c4 = scene.connect({ unitId: gen,  portId: 'elec_out' },  { unitId: hubB, portId: 'elec_in'  });
    const c5 = scene.connect({ unitId: hubB, portId: 'elec_out' },  { unitId: eSk,  portId: 'in'       });
    const c6 = scene.connect({ unitId: hubA, portId: 'heat_out' },  { unitId: hsA,  portId: 'in'       });
    const c7 = scene.connect({ unitId: hubB, portId: 'heat_out' },  { unitId: hsB,  portId: 'in'       });

    t.assertOK(c1, 'Srcâ†’HubA');
    t.assertOK(c2, 'HubAâ†’Motor');
    t.assertOK(c3, 'Motorâ†’Gen');
    t.assertOK(c4, 'Genâ†’HubB');
    t.assertOK(c5, 'HubBâ†’Sink');
    t.assertOK(c6, 'HubA heat');
    t.assertOK(c7, 'HubB heat');

    // Solve â€” should converge with no hub-to-hub error
    const r = t.solveRaw();
    t.assertOK(r.ok === true, 'solver.ok = true', `ok=${r.ok}`);

    // No hub-to-hub diagnostic
    const hasH2H = r.diagnostics.some(d =>
      d.originalMessage?.toLowerCase().includes('hub-to-hub')
    );
    t.assertOK(!hasH2H, 'No hub-to-hub diagnostic');
  });

  test('Recycle Loop â€” Tolerant Convergence', t => {
    // Material (not power) recycle loop must still converge fine.
    // Topology:  Source â†’ Mixer.in1 â†’ Splitter â†’ Sink (out1, 70%)
    //                     Mixer.in2 â† Splitter.out2   (recycle, 30%)
    const src  = t.place('source',   0, 0, { species:'N2', nDot:2, T:26.85, P:500000, phaseConstraint:'V' });
    const mix  = t.place('mixer',    4, 0);
    const spl  = t.place('splitter', 8, 0, { splitPct:70 });
    const snk  = t.place('sink',    12, 0);

    t.wire(src, 'out',  mix, 'in1');
    t.wire(mix, 'out',  spl, 'in');
    t.wire(spl, 'out1', snk, 'in');
    t.wire(spl, 'out2', mix, 'in2');  // recycle

    const r  = t.solveRaw();
    const ls = scene.runtime.lastSolve;

    t.assertOK(r.ok === true,    'solver.ok',        `ok=${r.ok}`);
    t.assertOK(ls.iterations < 50, 'iterations < 50', `iters=${ls.iterations}`);

    // Steady-state mass balance:  product = feed = 2 mol/s
    // Read product from splitter out1 (sink has no OUT ports â†’ ud.ports is empty)
    const prodS = t.port(spl, 'out1');
    t.assertClose(prodS?.n?.N2 ?? 0,  2.0,         0.01, 'Product N2 [mol/s]');
    t.assertClose(t.port(mix,'out')?.n?.N2 ?? 0, 2/0.7, 0.02, 'Mixer out [mol/s]');
    t.assertClose(t.port(spl,'out2')?.n?.N2 ?? 0, 0.3*(2/0.7), 0.02, 'Recycle [mol/s]');
    t.assertClose(prodS?.T ?? 0,       300.0,       1.0,  'Product T [K]');
    t.assertClose(prodS?.P ?? 0,       500000,      100,  'Product P [Pa]');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION K: Heat Sink MultiConnect (Test 60)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Heat Sink: MultiConnect Summation', t => {
    // Three heat sources connected to a single heat sink:
    //   Battery A (30 kW) â†’ Electric Heater A â†’ heat_out â”€â”
    //   Battery B (20 kW) â†’ Electric Heater B â†’ heat_out â”€â”¤â†’ Heat Sink
    //   Battery C (10 kW) â†’ Electric Heater C â†’ heat_out â”€â”˜
    //
    // EH eta=1.00 (hardcoded), so heat = electrical input exactly.
    // Expected: Heat Sink absorbs 30 + 20 + 10 = 60 kW, sourceCount = 3

    // â”€â”€ Chain A: Battery 30 kW â†’ E.Heater A â”€â”€
    const batA = t.place('battery',         0, 0, { maxPower: 30 });
    const ehA  = t.place('electric_heater', 3, 0);
    t.wire(batA, 'out', ehA, 'elec_in');

    // â”€â”€ Chain B: Battery 20 kW â†’ E.Heater B â”€â”€
    const batB = t.place('battery',         0, 3, { maxPower: 20 });
    const ehB  = t.place('electric_heater', 3, 3);
    t.wire(batB, 'out', ehB, 'elec_in');

    // â”€â”€ Chain C: Battery 10 kW â†’ E.Heater C â”€â”€
    const batC = t.place('battery',         0, 6, { maxPower: 10 });
    const ehC  = t.place('electric_heater', 3, 6);
    t.wire(batC, 'out', ehC, 'elec_in');

    // â”€â”€ Single heat sink receives all three heat_out ports â”€â”€
    const hs = t.place('sink_heat', 7, 3);
    t.wire(ehA, 'heat_out', hs, 'in');
    t.wire(ehB, 'heat_out', hs, 'in');
    t.wire(ehC, 'heat_out', hs, 'in');

    const r = t.solveRaw();
    t.assertOK(r.ok === true, 'solver.ok', `ok=${r.ok}`);

    const hsUD = t.ud(hs);
    const absorbed_kW = (hsUD?.last?.absorbed_W || 0) / 1000;

    // Total: 30 + 20 + 10 = 60 kW (EH Î· = 1.00 exact)
    t.assertClose(absorbed_kW, 60, 0.1, 'Total absorbed [kW]');

    // Source count: 3 connections into the heat sink
    t.assertClose(hsUD?.last?.sourceCount ?? 0, 3, 0, 'Source count');

    // Verify individual contributions
    const ehA_heat = (t.ud(ehA)?.ports?.heat_out?.actual || 0) / 1000;
    const ehB_heat = (t.ud(ehB)?.ports?.heat_out?.actual || 0) / 1000;
    const ehC_heat = (t.ud(ehC)?.ports?.heat_out?.actual || 0) / 1000;
    t.assertClose(ehA_heat, 30, 0.1, 'EH-A heat [kW]');
    t.assertClose(ehB_heat, 20, 0.1, 'EH-B heat [kW]');
    t.assertClose(ehC_heat, 10, 0.1, 'EH-C heat [kW]');

    // Energy balance: sum of parts = total absorbed
    t.assertClose(ehA_heat + ehB_heat + ehC_heat, absorbed_kW, 0.01, 'Energy balance');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION L: Power Converter Heat Loss (Tests 61-65)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Motor: Energy Balance (W_in = W_mech + Q_loss)', t => {
    // Battery(50kW) â†’ Motor(Î·=0.90) â†’ Compressor(N2)
    // Motor consumes W_elec and produces W_mech + Q_loss.
    // 1st law: W_elec = W_mech + Q_loss exactly.
    const bat = t.place('battery', 0, 0, { maxPower:50 });
    const mot = t.place('motor', 3, 0, { eta:0.90 });
    const src = t.place('source', 7, 3, { species:'N2', nDot:2, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 0, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 11, 0);
    t.wire(bat,'out', mot,'elec_in');
    t.wire(mot,'mech_out', comp,'power_in');
    t.wire(src,'out', comp,'mat_in');
    t.wire(comp,'mat_out', snk,'in');
    t.solve();

    const W_elec = t.ud(mot).last.W_elec_W;
    const W_mech = t.ud(mot).last.W_mech_W;
    const Q_loss = t.ud(mot).last.Q_loss_W;
    t.assertOK(W_elec > 100, 'Motor draws power', `${(W_elec/1000).toFixed(2)} kW`);
    t.assertOK(Q_loss > 0, 'Q_loss > 0 (Î· < 1)');

    // Strict 1st law: P_in = P_out + Q_loss
    t.assertClose(W_elec, W_mech + Q_loss, 0.01, '1st law: W_in = W_out + Q_loss');

    // Î· consistency: W_mech / W_elec = Î·
    t.assertClose(W_mech / W_elec, 0.90, 1e-6, 'Î· = W_mech/W_elec');

    // Q_loss = (1-Î·) Ã— W_elec
    t.assertClose(Q_loss, W_elec * 0.10, 0.01, 'Q_loss = (1-Î·)Â·W_in');

    // heat_out port carries the correct value
    const heatPort = t.ud(mot).ports.heat_out;
    t.assertOK(heatPort, 'heat_out port exists');
    t.assertClose(heatPort.actual, Q_loss, 0.01, 'heat_out.actual = Q_loss');
  });

  test('Generator: Energy Balance (W_mech = W_elec + Q_loss)', t => {
    // MechSource(100kW) â†’ GasTurbine(N2) â†’ Generator(Î·=0.95) â†’ Sink_elec
    // Generator converts mechanical â†’ electrical with heat loss.
    const src = t.place('source', 0, 3, { species:'N2', nDot:5, T:527, P:500000, phaseConstraint:'V' });
    const turb = t.place('gas_turbine', 4, 2, { Pout:100000, eta:0.85 });
    const exhaust = t.place('sink', 8, 3);
    const gen = t.place('generator', 4, 6, { eta:0.95 });
    const eSink = t.place('sink_electrical', 8, 6);
    t.wire(src,'out', turb,'mat_in');
    t.wire(turb,'mat_out', exhaust,'in');
    t.wire(turb,'mech_out', gen,'mech_in');
    t.wire(gen,'elec_out', eSink,'in');
    t.solve();

    const W_mech = t.ud(gen).last.W_mech_W;
    const W_elec = t.ud(gen).last.W_elec_W;
    const Q_loss = t.ud(gen).last.Q_loss_W;
    t.assertOK(W_mech > 100, 'Generator receives power', `${(W_mech/1000).toFixed(2)} kW`);
    t.assertOK(Q_loss > 0, 'Q_loss > 0 (Î· < 1)');

    // Strict 1st law: P_in = P_out + Q_loss
    t.assertClose(W_mech, W_elec + Q_loss, 0.01, '1st law: W_in = W_out + Q_loss');

    // Î· consistency
    t.assertClose(W_elec / W_mech, 0.95, 1e-6, 'Î· = W_elec/W_mech');
    t.assertClose(Q_loss, W_mech * 0.05, 0.01, 'Q_loss = (1-Î·)Â·W_in');

    // heat_out port
    const heatPort = t.ud(gen).ports.heat_out;
    t.assertOK(heatPort, 'heat_out port exists');
    t.assertClose(heatPort.actual, Q_loss, 0.01, 'heat_out.actual = Q_loss');
  });

  test('Motor: Heat Sink Connected â€” Closed Balance, No Warning', t => {
    // Battery â†’ Motor â†’ Compressor, heat_out â†’ HeatSink
    // Full energy closure: battery output = mech work + absorbed heat
    const bat = t.place('battery', 0, 0, { maxPower:50 });
    const mot = t.place('motor', 3, 0, { eta:0.90 });
    const hs = t.place('sink_heat', 3, -3);
    const src = t.place('source', 7, 3, { species:'N2', nDot:2, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 0, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 11, 0);
    t.wire(bat,'out', mot,'elec_in');
    t.wire(mot,'mech_out', comp,'power_in');
    t.wire(mot,'heat_out', hs,'in');
    t.wire(src,'out', comp,'mat_in');
    t.wire(comp,'mat_out', snk,'in');
    t.solve();

    const W_elec = t.ud(mot).last.W_elec_W;
    const W_mech = t.ud(mot).last.W_mech_W;
    const Q_loss = t.ud(mot).last.Q_loss_W;
    const absorbed = t.ud(hs)?.last?.absorbed_W || 0;

    // Heat sink absorbs exactly the motor's loss
    t.assertClose(absorbed, Q_loss, 0.1, 'Sink absorbed = Q_loss');

    // Full closure: W_elec_in = W_mech_out + Q_absorbed
    t.assertClose(W_elec, W_mech + absorbed, 0.1, 'Closed balance: W_in = W_out + Q_sink');

    // No warning when connected
    t.assertOK(!t.ud(mot).last.heatOutWarning, 'No unconnected warning');
  });

  test('Motor+Generator: Unconnected Heat â†’ Warning + System Solves', t => {
    // Motor and generator without heat sinks connected.
    // System must still solve OK, but both units get warnings.
    const bat = t.place('battery', 0, 0, { maxPower:50 });
    const mot = t.place('motor', 3, 0, { eta:0.90 });
    const src = t.place('source', 7, 3, { species:'N2', nDot:2, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 0, { Pout:300000, eta:0.75 });
    const snk = t.place('sink', 11, 0);
    t.wire(bat,'out', mot,'elec_in');
    t.wire(mot,'mech_out', comp,'power_in');
    t.wire(src,'out', comp,'mat_in');
    t.wire(comp,'mat_out', snk,'in');
    t.solve();

    // System solves without error
    t.assertOK(true, 'Solver OK with unconnected heat_out');

    // Motor has a warning about unconnected heat port
    const motWarn = t.ud(mot).last.heatOutWarning;
    t.assertOK(motWarn, 'Motor: heatOutWarning present');
    t.assertOK(motWarn?.severity === ErrorSeverity.MINOR, 'Motor: severity = MINOR');

    // Values are still computed correctly despite no sink
    const Q_loss = t.ud(mot).last.Q_loss_W;
    t.assertOK(Q_loss > 0, 'Q_loss computed', `${(Q_loss/1000).toFixed(2)} kW`);
    t.assertClose(t.ud(mot).ports.heat_out.actual, Q_loss, 0.01, 'heat_out port = Q_loss');
  });

  test('Electric Heater: Q_loss = 0 (Î·=1.00 hardcoded)', t => {
    // EH has Î·=1.00 â†’ zero loss by 1st law. Q_loss should be exactly 0.
    const bat = t.place('battery', 0, 0, { maxPower:50 });
    const eh = t.place('electric_heater', 3, 0);
    const src = t.place('source', 0, 3, { species:'N2', nDot:5, T:25, P:200000, phaseConstraint:'V' });
    const htr = t.place('heater', 6, 1, { T_out:200 });
    const snk = t.place('sink', 10, 1);
    t.wire(bat,'out', eh,'elec_in');
    t.wire(eh,'heat_out', htr,'heat_in');
    t.wire(src,'out', htr,'mat_in');
    t.wire(htr,'mat_out', snk,'in');
    t.solve();

    const Q_loss = t.ud(eh).last.Q_loss_W;
    t.assertOK(Q_loss !== undefined, 'Q_loss_W field present');
    t.assertClose(Q_loss, 0, 1e-10, 'Q_loss = 0 (Î·=1.00)');

    // Full EH energy balance: W_elec = Q_heat + Q_loss
    const W_elec = t.ud(eh).last.W_elec_actual_W || 0;
    const Q_heat = t.ud(eh).last.Q_available_W || 0;
    t.assertClose(W_elec, Q_heat + Q_loss, 0.01, '1st law: W_elec = Q_heat + Q_loss');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION M: Master Balance Tests (Tests 66-68)
  // Core principle: every atom and every joule that enters the system
  // boundary must leave it.  These tests build multi-unit topologies that
  // exercise all stream types and verify global closure via
  // computeSystemBalance().
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('MASTER: System Mass Balance', t => {
    // â”€â”€ Topology â”€â”€
    // Source A (N2, 5 mol/s) â”€â”€â”
    //                          â”œâ”€â”€ Mixer â”€â”€ Splitter(60/40) â”€â”€â”¬â”€â”€ Sink A
    // Source B (O2, 2 mol/s) â”€â”€â”˜                              â””â”€â”€ Sink B
    //
    // Source C (H2O, 3 mol/s) â”€â”€ Valve(1bar) â”€â”€ Flash Drum â”€â”€â”¬â”€â”€ Sink V (vapor)
    //                                                         â””â”€â”€ Sink L (liquid)
    //
    // Global mass balance (kg/s): total mass in must equal total mass out.
    // Reactor-compatible â€” no per-species check (species can change in reactors).

    // Branch 1: N2 + O2 â†’ mix â†’ split â†’ two sinks
    const sN2  = t.place('source', 0, 0, { species:'N2', nDot:5, T:25, P:200000, phaseConstraint:'V' });
    const sO2  = t.place('source', 0, 3, { species:'O2', nDot:2, T:25, P:200000, phaseConstraint:'V' });
    const mix  = t.place('mixer', 4, 1);
    const spl  = t.place('splitter', 8, 1, { splitPct:60 });
    const skA  = t.place('sink', 12, 0);
    const skB  = t.place('sink', 12, 3);
    t.wire(sN2, 'out', mix, 'in1');
    t.wire(sO2, 'out', mix, 'in2');
    t.wire(mix, 'out', spl, 'in');
    t.wire(spl, 'out1', skA, 'in');
    t.wire(spl, 'out2', skB, 'in');

    // Branch 2: H2O â†’ valve â†’ flash drum â†’ vap/liq sinks
    const sH2O = t.place('source', 0, 7, { species:'H2O', nDot:3, T:150, P:500000, phaseConstraint:'L' });
    const vlv  = t.place('valve', 4, 7, { Pout:100000 });
    const sep  = t.place('flash_drum', 8, 6);
    const skV  = t.place('sink', 12, 6);
    const skL  = t.place('sink', 12, 9);
    t.wire(sH2O, 'out', vlv, 'in');
    t.wire(vlv, 'out', sep, 'mat_in');
    t.wire(sep, 'vap_out', skV, 'in');
    t.wire(sep, 'liq_out', skL, 'in');

    t.solve();

    const bal = computeSystemBalance(scene);
    t.assertOK(bal, 'Balance computed');

    // â”€â”€ Reference mass flows (kg/s) â”€â”€
    // N2:  5 mol/s Ã— 28.014 g/mol / 1000 = 0.14007 kg/s
    // O2:  2 mol/s Ã— 31.998 g/mol / 1000 = 0.063996 kg/s
    // H2O: 3 mol/s Ã— 18.015 g/mol / 1000 = 0.054045 kg/s
    // Total: 0.258111 kg/s
    const expectedTotal_kgps = (5 * 28.014 + 2 * 31.998 + 3 * 18.015) / 1000;

    // Verify inputs: 3 source streams
    t.assertClose(bal.mass.inItems.length, 3, 0, '3 mass inputs');
    t.assertClose(bal.mass.totalIn, expectedTotal_kgps, 1e-4, `Mass in = ${(expectedTotal_kgps*1000).toFixed(1)} g/s`);

    // Verify outputs: 4 sink streams (Sink A, Sink B, Sink V, Sink L)
    t.assertClose(bal.mass.outItems.length, 4, 0, '4 mass outputs');
    t.assertClose(bal.mass.totalOut, expectedTotal_kgps, 1e-4, `Mass out = ${(expectedTotal_kgps*1000).toFixed(1)} g/s`);

    // â”€â”€ Global closure â”€â”€
    t.assertClose(bal.mass.balance, 0, 1e-6, 'Mass residual â‰ˆ 0 kg/s');
    t.assertOK(bal.mass.closed, 'mass.closed = true');
  });

  test('MASTER: System Energy Balance', t => {
    // â”€â”€ Topology â”€â”€
    // Battery(30kW) â†’ Motor(Î·=0.90) â†’ Compressor(Î·=0.75)
    //                     â”‚heat_out
    //                     â””â†’ HeatSink
    //
    // Source(N2, 3mol/s, 25Â°C, 1bar) â†’ Compressor(3bar) â†’ Sink(material)
    //
    // Energy boundary:
    //   IN:  Battery(electrical) + Source(enthalpy)
    //   OUT: Sink(enthalpy) + HeatSink(motor loss)
    //   Residual must be â‰ˆ 0.
    //
    // This exercises: electrical â†’ mechanical conversion with heat loss,
    // material enthalpy increase through compression, and verifies that
    // every watt is accounted for across all stream types.

    const bat  = t.place('battery', 0, 0, { maxPower:30 });
    const mot  = t.place('motor', 3, 0, { eta:0.90 });
    const hs   = t.place('sink_heat', 3, -3);
    const src  = t.place('source', 7, 3, { species:'N2', nDot:3, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 0, { Pout:300000, eta:0.75 });
    const snk  = t.place('sink', 11, 0);

    t.wire(bat, 'out', mot, 'elec_in');
    t.wire(mot, 'mech_out', comp, 'power_in');
    t.wire(mot, 'heat_out', hs, 'in');
    t.wire(src, 'out', comp, 'mat_in');
    t.wire(comp, 'mat_out', snk, 'in');
    t.solve();

    const bal = computeSystemBalance(scene);
    t.assertOK(bal, 'Balance computed');

    // â”€â”€ Verify boundary streams are classified correctly â”€â”€

    // Inputs: 1 electrical (battery), 1 material (source)
    const elecInItems = bal.energy.in.items.filter(i => i.type === 'electrical');
    const matInItems  = bal.energy.in.items.filter(i => i.type === 'material');
    t.assertClose(elecInItems.length, 1, 0, 'One elec input');
    t.assertClose(matInItems.length, 1, 0, 'One mat input');

    // Outputs: 1 material (sink), 1 heat (heat sink), 0 dissipated (heat is connected)
    const matOutItems  = bal.energy.out.items.filter(i => i.type === 'material');
    const heatOutItems = bal.energy.out.items.filter(i => i.type === 'heat');
    const dissItems    = bal.energy.out.items.filter(i => i.type === 'dissipated');
    t.assertClose(matOutItems.length, 1, 0, 'One mat output');
    t.assertClose(heatOutItems.length, 1, 0, 'One heat output');
    t.assertClose(dissItems.length, 0, 0, 'Zero dissipated (heat connected)');

    // â”€â”€ Verify numerical energy balance â”€â”€
    // Battery actual output
    const W_bat = bat ? t.ud(bat).ports.out.actual : 0;
    t.assertClose(bal.energy.in.electrical, W_bat, 1, 'Elec in = battery actual');
    t.assertOK(W_bat > 100, 'Battery outputs power', `${(W_bat/1000).toFixed(2)} kW`);

    // Motor heat loss collected at sink
    const Q_motor = t.ud(mot).last.Q_loss_W;
    const Q_sink  = t.ud(hs)?.last?.absorbed_W ?? 0;
    t.assertClose(Q_sink, Q_motor, 1, 'Heat sink = motor loss');

    // Enthalpy increase of material = shaft work delivered to compressor
    const H_src = thermo.getHdot_Jps(t.ud(src).ports.out);
    const H_snk = thermo.getHdot_Jps(t.ud(snk).ports.in);
    const W_shaft = t.ud(mot).last.W_mech_W;
    t.assertClose(H_snk - H_src, W_shaft, 100, 'Î”H_mat â‰ˆ W_shaft');

    // â”€â”€ Grand closure â”€â”€
    // Total in  = H_src + W_bat
    // Total out = H_snk + Q_sink
    // Residual  = (H_src + W_bat) - (H_snk + Q_sink) â‰ˆ 0
    t.assertClose(bal.energy.totalIn, bal.energy.totalOut, 100, 'Total in â‰ˆ Total out');
    const relErr = bal.energy.relError * 100;
    t.assertClose(relErr, 0, 1.0, 'Relative error < 1%');
    t.assertOK(bal.energy.closed, 'energy.closed = true');

    // â”€â”€ Verify decomposition identity â”€â”€
    // W_bat = (H_snk - H_src) + Q_motor_loss
    // i.e., all battery power goes to either compressing gas or heating the motor
    t.assertClose(W_bat, (H_snk - H_src) + Q_motor, 100, 'W_bat = Î”H_material + Q_loss');
  });

  test('MASTER: Energy Balance â€” Unconnected Heat (Dissipated)', t => {
    // â”€â”€ Topology â”€â”€
    // Same as test 67, but motor's heat_out is NOT connected.
    // The dissipated heat must appear as "dissipated" in the energy balance
    // and still close the overall balance.
    //
    // Battery(30kW) â†’ Motor(Î·=0.90) â†’ Compressor(Î·=0.75)
    //                     â”‚heat_out â† UNCONNECTED (dissipated)
    //
    // Source(N2, 3mol/s, 25Â°C, 1bar) â†’ Compressor(3bar) â†’ Sink(material)

    const bat  = t.place('battery', 0, 0, { maxPower:30 });
    const mot  = t.place('motor', 3, 0, { eta:0.90 });
    // Intentionally no heat sink connected to motor's heat_out
    const src  = t.place('source', 7, 3, { species:'N2', nDot:3, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 0, { Pout:300000, eta:0.75 });
    const snk  = t.place('sink', 11, 0);

    t.wire(bat, 'out', mot, 'elec_in');
    t.wire(mot, 'mech_out', comp, 'power_in');
    t.wire(src, 'out', comp, 'mat_in');
    t.wire(comp, 'mat_out', snk, 'in');
    t.solve();

    const bal = computeSystemBalance(scene);
    t.assertOK(bal, 'Balance computed');

    // â”€â”€ Dissipated category should capture the unconnected heat â”€â”€
    const dissItems = bal.energy.out.items.filter(i => i.type === 'dissipated');
    t.assertClose(dissItems.length, 1, 0, 'One dissipated item (motor heat_out)');

    const Q_motor = t.ud(mot).last.Q_loss_W;
    t.assertOK(Q_motor > 0, 'Motor Q_loss > 0', `${(Q_motor/1000).toFixed(2)} kW`);
    t.assertClose(bal.energy.out.dissipated, Q_motor, 1, 'Dissipated = motor Q_loss');

    // â”€â”€ No heat sink output (nothing connected) â”€â”€
    const heatItems = bal.energy.out.items.filter(i => i.type === 'heat');
    t.assertClose(heatItems.length, 0, 0, 'Zero heat sink outputs');

    // â”€â”€ Grand closure still holds (dissipated counts as OUT) â”€â”€
    t.assertClose(bal.energy.totalIn, bal.energy.totalOut, 100, 'Total in â‰ˆ Total out');
    const relErr = bal.energy.relError * 100;
    t.assertClose(relErr, 0, 1.0, 'Relative error < 1%');
    t.assertOK(bal.energy.closed, 'energy.closed = true');

    // â”€â”€ Verify warning still fires â”€â”€
    const motWarn = t.ud(mot).last.heatOutWarning;
    t.assertOK(motWarn, 'Motor: heatOutWarning present');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION N: HEX Post-Flash Validation (Tests 69-71)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('HEX Validation: No Cross â€” Normal Counter-Current', t => {
    // Hot N2 (200Â°C, 2bar) vs Cold H2O (25Â°C, 2bar), approach=10K.
    // Well within feasible range â†’ hxCross=false, dTmin>0.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:2, T:200, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'H2O', nDot:5, T:25, P:200000, phaseConstraint:'L' });
    const hx   = t.place('hex', 4, 1, { T_approach:10, T_hot_out:undefined, T_cold_out:undefined });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.Q > 0, 'Duty > 0', `${last.Q.toFixed(2)} kW`);

    // Post-flash validation results
    t.assertOK(last.hxPinch_K !== undefined, 'hxPinch_K computed');
    t.assertOK(last.hxPinch_K > 0, 'Î”Tmin > 0 (no cross)', `${(last.hxPinch_K ?? 0).toFixed(2)} K`);
    t.assertOK(last.hxCross === false, 'hxCross = false');

    // Actual resolved temperatures make physical sense
    const Tho = last.T_hot_out_actual;
    const Tco = last.T_cold_out_actual;
    t.assertOK(Tho !== undefined, 'T_hot_out_actual resolved');
    t.assertOK(Tco !== undefined, 'T_cold_out_actual resolved');
    t.assertOK(Tho < last.T_hot_in, 'Hot stream cools down');
    t.assertOK(Tco > last.T_cold_in, 'Cold stream heats up');

    // No errors
    t.assertOK(!last.errors || last.errors.length === 0, 'No validation errors');
  });

  test('HEX Validation: Forced Temperature Cross', t => {
    // Force a cross by specifying T_cold_out > T_hot_in.
    // Hot N2 at 100Â°C, Cold H2O at 25Â°C, user sets T_cold_out = 120Â°C.
    // This requires more energy than the hot stream has â†’ cross.
    //
    // The tick's Cp-based feasibility check may catch this and bail out with
    // an error before writing outlets. The postFlashCheck only runs if
    // outlets exist. So we test that EITHER:
    //   (a) tick error fires (existing check), OR
    //   (b) postFlashCheck catches the cross
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:1, T:100, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'H2O', nDot:5, T:25, P:200000, phaseConstraint:'L' });
    const hx   = t.place('hex', 4, 1, { T_cold_out:120, T_approach:0, T_hot_out:undefined });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');

    // Either tick error OR post-flash cross detection
    const hasTickError = last.error && last.error.severity;
    const hasPostFlashCross = last.hxCross === true;
    const hasPostFlashErrors = last.errors && last.errors.length > 0;
    t.assertOK(hasTickError || hasPostFlashCross || hasPostFlashErrors,
      'Cross detected (tick error OR postFlash)',
      hasTickError ? 'tick error' : hasPostFlashCross ? 'hxCross=true' : 'postFlash errors');
  });

  test('HEX Validation: Approach Violation Flagging', t => {
    // Set approach mode with 20K target, but use streams that produce a
    // much tighter actual pinch (~2-5K) by specifying hot outlet very close
    // to cold inlet via T_hot_out mode.
    //
    // Hot N2 at 200Â°C, Cold H2O at 25Â°C.
    // Set T_hot_out = 28Â°C â†’ approach at hot end = 28-25 = 3K, well below 20K target.
    // But we set T_approach=20 in params to trigger violation detection.
    //
    // The tick will use T_hot_out mode (overrides approach), but we store
    // T_approach_par for the postFlashCheck to compare against.

    // First: use approach mode where limiting stream produces tight pinch
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:0.5, T:200, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'H2O', nDot:10, T:25, P:200000, phaseConstraint:'L' });
    // Small hot Cp (N2 gas, 0.5 mol/s) vs large cold Cp (H2O liquid, 10 mol/s)
    // In approach mode with T_approach=20, the hot stream is limiting.
    // Hot outlet â†’ T_cold_in + 20 = 45Â°C = 318.15K.
    // Cold outlet barely rises (huge Cp) â†’ stays near 25Â°C.
    // dT_end1 = T_hot_in - T_cold_out â‰ˆ 200 - ~26 = 174K
    // dT_end2 = T_hot_out - T_cold_in = 45 - 25 = 20K â†’ this is the pinch
    const hx = t.place('hex', 4, 1, { T_approach:20, T_hot_out:undefined, T_cold_out:undefined });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.mode === 'approach', 'Mode = approach');
    t.assertOK(last.Q > 0, 'Duty > 0', `${last.Q.toFixed(2)} kW`);

    // Post-flash pinch should be close to target (within Cp estimation error)
    const pinch = last.hxPinch_K;
    t.assertOK(pinch !== undefined, 'hxPinch_K computed');
    t.assertOK(last.hxCross === false, 'No cross');

    // The approach mode should achieve roughly the target approach.
    // If actual pinch is within tolerance of target â†’ no violation.
    // If actual pinch is below target - tolerance â†’ violation.
    // This depends on Cp heuristic accuracy. We just verify the fields exist
    // and the logic runs without crashing.
    t.assertOK(last.hxApproachViolation !== undefined, 'hxApproachViolation field set');

    // Regardless of whether violation fires, the pinch should be positive
    t.assertOK(pinch > 0, 'Pinch > 0', `${(pinch ?? 0).toFixed(2)} K`);
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION O: Per-Unit Balance Validation (Tests 72-73)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('Per-Unit Mass Balance (kg/s)', t => {
    // Topology:
    // Source A (N2, 3 mol/s) â”€â”€â”
    //                          â”œâ”€â”€ Mixer â”€â”€ Compressor(3bar) â”€â”€ Sink
    // Source B (O2, 1 mol/s) â”€â”€â”˜
    //
    // Mixer: mass in must equal mass out (no reaction).
    // Compressor: mass in must equal mass out (pressure change only).
    // Source/Sink: boundary â€” must be SKIPPED (no errors).

    const srcA = t.place('source', 0, 0, { species:'N2', nDot:3, T:25, P:100000, phaseConstraint:'V' });
    const srcB = t.place('source', 0, 3, { species:'O2', nDot:1, T:25, P:100000, phaseConstraint:'V' });
    const mix  = t.place('mixer', 4, 1);
    const comp = t.place('compressor', 8, 1, { Pout:300000, eta:0.80 });
    const snk  = t.place('sink', 12, 1);

    // Provide shaft power so compressor runs
    const bat  = t.place('battery', 8, 5, { maxPower:50 });
    const mot  = t.place('motor', 8, 3, { eta:0.95 });
    t.wire(bat, 'out', mot, 'elec_in');
    t.wire(mot, 'mech_out', comp, 'power_in');

    t.wire(srcA, 'out', mix, 'in1');
    t.wire(srcB, 'out', mix, 'in2');
    t.wire(mix, 'out', comp, 'mat_in');
    t.wire(comp, 'mat_out', snk, 'in');
    t.solve();

    // â”€â”€ Boundary units: must have NO mass balance errors â”€â”€
    // (They may have flash warnings, which are unrelated â€” we check specifically for balance errors)
    const hasMassErr = (ud) => ud.errors.some(e => typeof e === 'string' && e.includes('Mass imbalance'));
    t.assertOK(!hasMassErr(t.ud(srcA)), 'Source A: no mass errors');
    t.assertOK(!hasMassErr(t.ud(srcB)), 'Source B: no mass errors');
    t.assertOK(!hasMassErr(t.ud(snk)),  'Sink: no mass errors');
    t.assertOK(!hasMassErr(t.ud(bat)),  'Battery: no mass errors');

    // â”€â”€ Mixer: mass closes (N2 + O2 in = mixture out) â”€â”€
    const mixErrs = t.ud(mix).errors.filter(e => typeof e === 'string' && e.includes('Mass imbalance'));
    t.assertClose(mixErrs.length, 0, 0, 'Mixer: 0 mass errors');

    // Verify actual mass values via ports
    const m_mix_in1 = streamMass_kgps(t.ud(mix).ports.in1);
    const m_mix_in2 = streamMass_kgps(t.ud(mix).ports.in2);
    const m_mix_out = streamMass_kgps(t.ud(mix).ports.out);
    t.assertClose(m_mix_in1 + m_mix_in2, m_mix_out, 1e-9, 'Mixer: á¹_in = á¹_out');

    // â”€â”€ Compressor: mass closes (same gas, higher P) â”€â”€
    const compErrs = t.ud(comp).errors.filter(e => typeof e === 'string' && e.includes('Mass imbalance'));
    t.assertClose(compErrs.length, 0, 0, 'Compressor: 0 mass errors');

    // Reference: 3 mol/s N2 (28.014 g/mol) + 1 mol/s O2 (31.998 g/mol)
    const expectedMass = (3 * 28.014 + 1 * 31.998) / 1000;  // kg/s
    t.assertClose(m_mix_out, expectedMass, 1e-4, `Total mass = ${(expectedMass*1000).toFixed(1)} g/s`);
  });

  test('Per-Unit Energy Balance (W)', t => {
    // Topology:
    // Battery(30kW) â†’ Motor(Î·=0.90) â†’ Compressor(Î·=0.75)
    //                     â”‚heat_out â†’ HeatSink
    // Source(N2, 3mol/s) â†’ Compressor â†’ Sink
    //
    // Motor:      E_in = W_elec, E_out = W_mech + Q_loss â†’ should close exactly
    // Compressor: E_in = Hdot_in + W_shaft, E_out = Hdot_out â†’ should close

    const bat  = t.place('battery', 0, 0, { maxPower:30 });
    const mot  = t.place('motor', 3, 0, { eta:0.90 });
    const hs   = t.place('sink_heat', 3, -3);
    const src  = t.place('source', 7, 3, { species:'N2', nDot:3, T:25, P:100000, phaseConstraint:'V' });
    const comp = t.place('compressor', 7, 0, { Pout:300000, eta:0.75 });
    const snk  = t.place('sink', 11, 0);

    t.wire(bat, 'out', mot, 'elec_in');
    t.wire(mot, 'mech_out', comp, 'power_in');
    t.wire(mot, 'heat_out', hs, 'in');
    t.wire(src, 'out', comp, 'mat_in');
    t.wire(comp, 'mat_out', snk, 'in');
    t.solve();

    // â”€â”€ Motor energy balance â”€â”€
    // W_elec_in = W_mech_out + Q_heat_out (by construction)
    const motEB = t.ud(mot).last.energyBalance;
    // Motor should close so tightly that energyBalance isn't even stored
    // (residual < 100W threshold). If it IS stored, residual must be tiny.
    if (motEB) {
      t.assertClose(motEB.residual_kW, 0, 0.1, 'Motor: E residual < 0.1 kW');
    } else {
      t.assertOK(true, 'Motor: E balance within threshold (not stored)');
    }

    // Verify motor 1st law directly
    const W_elec = t.ud(mot).ports.elec_in?.actual ?? 0;
    const W_mech = t.ud(mot).ports.mech_out?.actual ?? 0;
    const Q_loss = t.ud(mot).ports.heat_out?.actual ?? 0;
    t.assertClose(W_elec, W_mech + Q_loss, 1, 'Motor: W_elec = W_mech + Q_loss');

    // â”€â”€ Compressor energy balance â”€â”€
    // Hdot_in + W_shaft = Hdot_out
    const compEB = t.ud(comp).last.energyBalance;
    if (compEB) {
      t.assertClose(compEB.residual_kW, 0, 0.5, 'Compressor: E residual < 0.5 kW');
    } else {
      t.assertOK(true, 'Compressor: E balance within threshold (not stored)');
    }

    // Verify compressor 1st law directly from ports
    const H_in  = t.ud(comp).ports.mat_in?.Hdot_J_s ?? 0;
    const H_out = t.ud(comp).ports.mat_out?.Hdot_J_s ?? 0;
    const W_shaft = t.ud(comp).ports.power_in?.actual ?? 0;
    t.assertClose(H_in + W_shaft, H_out, 100, 'Compressor: Hdot_in + W = Hdot_out');

    // â”€â”€ Boundary units: no mass/energy balance errors â”€â”€
    const hasMassErr = (ud) => ud.errors.some(e => typeof e === 'string' && e.includes('Mass imbalance'));
    t.assertOK(!hasMassErr(t.ud(src)), 'Source: no mass errors');
    t.assertOK(!hasMassErr(t.ud(snk)), 'Sink: no mass errors');
    t.assertOK(!hasMassErr(t.ud(bat)), 'Battery: no mass errors');
    t.assertOK(!hasMassErr(t.ud(hs)),  'HeatSink: no mass errors');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION P: H_at_T Phase Stability (Tests 74-75)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('H_at_T: Stability Near Saturation', t => {
    // H2O at 2 bar: Tsat â‰ˆ 393K (120Â°C).
    // Call getHdot_Jps on a proxy at T=392K (just below Tsat) with phaseConstraint='L'
    // and at T=394K (just above Tsat) with phaseConstraint='V'.
    // Both calls must return finite, non-zero values.
    // Two calls at the same T must return identical results (stability).

    const n = { H2O: 1 };
    const P = 200000;

    // Just below saturation â€” liquid
    const proxyL = { type: StreamType.MATERIAL, T: 392, P, n: { ...n }, phaseConstraint: 'L' };
    const H_L1 = thermo.getHdot_Jps(proxyL);
    // Reset cached enthalpy to force recomputation
    delete proxyL.Hdot_J_s; delete proxyL.phase; delete proxyL.nV; delete proxyL.nL;
    const H_L2 = thermo.getHdot_Jps(proxyL);

    t.assertOK(isFinite(H_L1) && H_L1 !== 0, 'H(392K,L) finite & nonzero', H_L1.toFixed(1));
    t.assertClose(H_L1, H_L2, 1e-6, 'H(392K,L) stable across calls');

    // Just above saturation â€” vapor
    const proxyV = { type: StreamType.MATERIAL, T: 394, P, n: { ...n }, phaseConstraint: 'V' };
    const H_V1 = thermo.getHdot_Jps(proxyV);
    delete proxyV.Hdot_J_s; delete proxyV.phase; delete proxyV.nV; delete proxyV.nL;
    const H_V2 = thermo.getHdot_Jps(proxyV);

    t.assertOK(isFinite(H_V1) && H_V1 !== 0, 'H(394K,V) finite & nonzero', H_V1.toFixed(1));
    t.assertClose(H_V1, H_V2, 1e-6, 'H(394K,V) stable across calls');

    // Vapor enthalpy must exceed liquid enthalpy (latent heat)
    t.assertOK(H_V1 > H_L1, 'H(V) > H(L) by latent heat', `Î”H=${((H_V1-H_L1)/1000).toFixed(1)} kW`);

    // Without phaseConstraint (default 'VL'), both calls near Tsat must still be stable
    const proxyVL = { type: StreamType.MATERIAL, T: 393, P, n: { ...n } };
    const H_VL1 = thermo.getHdot_Jps(proxyVL);
    delete proxyVL.Hdot_J_s; delete proxyVL.phase; delete proxyVL.nV; delete proxyVL.nL;
    const H_VL2 = thermo.getHdot_Jps(proxyVL);
    t.assertOK(isFinite(H_VL1), 'H(393K,VL) finite', H_VL1.toFixed(1));
    t.assertClose(H_VL1, H_VL2, 1e-6, 'H(393K,VL) stable across calls');
  });

  test('HEX Near-Saturation Energy Balance (regression)', t => {
    // Hot: N2 gas at 200Â°C, 2 bar
    // Cold: H2O liquid at 90Â°C, 2 bar (near saturation at ~120Â°C)
    // HEX with approach=10K.
    // The cold stream should heat up toward saturation but stay liquid
    // (phaseConstraint='L' propagated by H_at_T).
    // Energy balance must close: Q_hot_released = Q_cold_absorbed.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:2, T:200, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'H2O', nDot:5, T:90, P:200000, phaseConstraint:'L' });
    const hx   = t.place('hex', 4, 1, { T_approach:10 });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.Q > 0, 'Duty > 0', `${last.Q?.toFixed(2)} kW`);

    // Energy balance: hot released = cold absorbed (via port enthalpies)
    const H_hi = t.ud(hx).ports.hot_in?.Hdot_J_s ?? 0;
    const H_ho = t.ud(hx).ports.hot_out?.Hdot_J_s ?? 0;
    const H_ci = t.ud(hx).ports.cold_in?.Hdot_J_s ?? 0;
    const H_co = t.ud(hx).ports.cold_out?.Hdot_J_s ?? 0;
    const Q_hot  = H_hi - H_ho;  // Released by hot side
    const Q_cold = H_co - H_ci;  // Absorbed by cold side

    t.assertOK(Q_hot > 0, 'Hot side releases energy', `${(Q_hot/1000).toFixed(2)} kW`);
    t.assertOK(Q_cold > 0, 'Cold side absorbs energy', `${(Q_cold/1000).toFixed(2)} kW`);
    t.assertClose(Q_hot, Q_cold, Math.max(Math.abs(Q_hot) * 0.01, 10),
      'Energy balance: Q_hot â‰ˆ Q_cold');

    // Post-flash validation should not flag a cross
    t.assertOK(last.hxCross === false, 'No temperature cross');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION Q: HEX Approach Mode Solver (Tests 76-78)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('HEX Approach: Pinch Match (Ideal Gas)', t => {
    // N2(200Â°C, 2bar, 2mol/s) vs N2(25Â°C, 2bar, 3mol/s), approach=15K.
    // Both ideal-gas streams â€” no phase change, clean Cp.
    // The bisection solver must converge to dTmin â‰ˆ 15K.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:2, T:200, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'N2', nDot:3, T:25, P:200000, phaseConstraint:'V' });
    const hx   = t.place('hex', 4, 1, { T_approach:15 });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.mode === 'approach', 'Mode = approach');
    t.assertOK(last.Q > 0, 'Duty > 0', `${last.Q?.toFixed(2)} kW`);

    // Post-flash resolved pinch must match target within tolerance
    const pinch = last.hxPinch_K;
    t.assertOK(pinch !== undefined, 'hxPinch_K resolved');
    t.assertClose(pinch, 15, 1.0, 'Pinch â‰ˆ 15K (Â±1K)');

    // No cross
    t.assertOK(last.hxCross === false, 'No temperature cross');

    // Hot cools, cold heats
    const Tho = last.T_hot_out_actual ?? last.T_hot_out;
    const Tco = last.T_cold_out_actual ?? last.T_cold_out;
    t.assertOK(Tho < last.T_hot_in, 'Hot stream cools');
    t.assertOK(Tco > last.T_cold_in, 'Cold stream heats');

    // Energy balance via ports
    const Hhi = t.ud(hx).ports.hot_in?.Hdot_J_s ?? 0;
    const Hho = t.ud(hx).ports.hot_out?.Hdot_J_s ?? 0;
    const Hci = t.ud(hx).ports.cold_in?.Hdot_J_s ?? 0;
    const Hco = t.ud(hx).ports.cold_out?.Hdot_J_s ?? 0;
    t.assertClose(Hhi - Hho, Hco - Hci, Math.max(Math.abs(Hhi - Hho) * 0.02, 10),
      'Q_hot â‰ˆ Q_cold (1st law)');

    // Solver diagnostics
    t.assertOK(last.hxApproachIter > 0, 'Bisection ran', `${last.hxApproachIter} iters`);
  });

  test('HEX Approach: Impossible (approach > Î”T_inlet)', t => {
    // N2(100Â°C) vs N2(80Â°C), approach=30K.
    // Î”T_inlet = 20K < 30K approach â†’ infeasible.
    // Solver must report error with Q=0, not crash.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:1, T:100, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'N2', nDot:1, T:80, P:200000, phaseConstraint:'V' });
    const hx   = t.place('hex', 4, 1, { T_approach:30 });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.error, 'Error flagged');
    t.assertOK(last.error?.severity === ErrorSeverity.MAJOR, 'MAJOR severity');
    t.assertOK(last.mode === 'approach', 'Mode = approach');
  });

  test('HEX Approach: Phase-Change Convergence (H2O)', t => {
    // Hot: N2 gas (300Â°C, 5bar, 5mol/s) â€” always gas, large CpÂ·n
    // Cold: H2O liquid (50Â°C, 5bar, 1mol/s) â€” could approach saturation (~152Â°C at 5bar)
    // Approach=20K.
    // Tests convergence of bisection when cold stream approaches phase boundary.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:5, T:300, P:500000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'H2O', nDot:1, T:50, P:500000, phaseConstraint:'L' });
    const hx   = t.place('hex', 4, 1, { T_approach:20 });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(!last.error, 'No error', last.error?.message);
    t.assertOK(last.Q > 0, 'Duty > 0', `${last.Q?.toFixed(2)} kW`);
    t.assertOK(last.hxCross === false, 'No temperature cross');

    // Pinch should be near target
    const pinch = last.hxPinch_K;
    t.assertOK(pinch !== undefined, 'hxPinch_K resolved');
    t.assertClose(pinch, 20, 2.0, 'Pinch â‰ˆ 20K (Â±2K)');

    // Cold stream heats but stays below hot inlet
    const Tco = last.T_cold_out_actual ?? last.T_cold_out;
    t.assertOK(Tco > (50 + 273.15), 'Cold heats above 50Â°C');
    t.assertOK(Tco < (300 + 273.15), 'Cold below hot inlet');
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION R: HEX UA/NTU Mode (Tests 79-82)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  test('HEX UA/NTU: UA=0 â†’ Q=0', t => {
    // With UA=0, effectiveness=0, no heat transfer occurs.
    // Both outlet temperatures should equal their inlets.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:2, T:200, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'N2', nDot:3, T:25, P:200000, phaseConstraint:'V' });
    const hx   = t.place('hex', 4, 1, { UA_W_per_K:0, T_approach:undefined, T_hot_out:undefined, T_cold_out:undefined });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.mode === 'ua_ntu', 'Mode = ua_ntu');
    t.assertClose(last.Q, 0, 0.001, 'Q = 0 kW');
    t.assertClose(last.epsilon, 0, 1e-12, 'Îµ = 0');
    t.assertClose(last.NTU, 0, 1e-12, 'NTU = 0');
  });

  test('HEX UA/NTU: High UA â†’ Îµâ†’1, Qâ†’Qmax', t => {
    // Very large UA (1e6 W/K) â†’ NTU huge â†’ Îµâ‰ˆ1 â†’ Qâ‰ˆQmax.
    // N2(200Â°C,2mol/s) vs N2(25Â°C,3mol/s): Cmin = C_hot (smaller flow).
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:2, T:200, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'N2', nDot:3, T:25, P:200000, phaseConstraint:'V' });
    const hx   = t.place('hex', 4, 1, { UA_W_per_K:1e6, T_approach:undefined, T_hot_out:undefined, T_cold_out:undefined });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(last.mode === 'ua_ntu', 'Mode = ua_ntu');
    t.assertClose(last.epsilon, 1.0, 0.01, 'Îµ â‰ˆ 1.0');
    t.assertOK(last.Q > 0, 'Q > 0', `${last.Q?.toFixed(2)} kW`);

    // Q should equal Qmax within tolerance
    const Qmax_kW = last.Qmax_W / 1000;
    t.assertClose(last.Q, Qmax_kW, Qmax_kW * 0.01, 'Q â‰ˆ Qmax');

    // Hot outlet should approach cold inlet temperature (Cmin side exhausted)
    const Tho = last.T_hot_out_actual ?? last.T_hot_out;
    t.assertClose(Tho, (25 + 273.15), 5, 'T_hot_out â†’ T_cold_in');

    // At Îµâ†’1 limit, Cp-based NTU drives T_hot_out to exactly T_cold_in,
    // but PH flash can overshoot by ~1K due to Cp nonlinearity.
    // Check that any "cross" is within this expected tolerance.
    const pinch80 = last.hxPinch_K ?? last.approach ?? 0;
    t.assertOK(pinch80 > -2.0, 'No significant cross', `pinch=${pinch80.toFixed(2)}K`);
  });

  test('HEX UA/NTU: Monotonicity (Q increases with UA)', t => {
    // Three UA values: 50, 500, 5000 W/K â†’ Q must strictly increase.
    const UAs = [50, 500, 5000];
    const duties = [];

    for (const UA of UAs) {
      t.clearScene();
      const srcH = t.place('source', 0, 0, { species:'N2', nDot:2, T:200, P:200000, phaseConstraint:'V' });
      const srcC = t.place('source', 0, 4, { species:'N2', nDot:3, T:25, P:200000, phaseConstraint:'V' });
      const hx   = t.place('hex', 4, 1, { UA_W_per_K:UA, T_approach:undefined, T_hot_out:undefined, T_cold_out:undefined });
      const snkH = t.place('sink', 8, 0);
      const snkC = t.place('sink', 8, 4);
      t.wire(srcH, 'out', hx, 'hot_in');
      t.wire(hx, 'hot_out', snkH, 'in');
      t.wire(srcC, 'out', hx, 'cold_in');
      t.wire(hx, 'cold_out', snkC, 'in');
      t.solveRaw();
      const last = t.ud(hx)?.last;
      duties.push(last?.Q ?? 0);
    }

    t.assertOK(duties[0] > 0, `Q(UA=50) > 0`, `${duties[0].toFixed(3)} kW`);
    t.assertOK(duties[1] > duties[0], 'Q(UA=500) > Q(UA=50)', `${duties[1].toFixed(3)} > ${duties[0].toFixed(3)}`);
    t.assertOK(duties[2] > duties[1], 'Q(UA=5000) > Q(UA=500)', `${duties[2].toFixed(3)} > ${duties[1].toFixed(3)}`);
  });

  test('HEX UA/NTU: No Temperature Cross', t => {
    // Moderate UA with unbalanced streams â€” verify no cross in results.
    const srcH = t.place('source', 0, 0, { species:'N2', nDot:1, T:150, P:200000, phaseConstraint:'V' });
    const srcC = t.place('source', 0, 4, { species:'N2', nDot:5, T:25, P:200000, phaseConstraint:'V' });
    const hx   = t.place('hex', 4, 1, { UA_W_per_K:200, T_approach:undefined, T_hot_out:undefined, T_cold_out:undefined });
    const snkH = t.place('sink', 8, 0);
    const snkC = t.place('sink', 8, 4);
    t.wire(srcH, 'out', hx, 'hot_in');
    t.wire(hx, 'hot_out', snkH, 'in');
    t.wire(srcC, 'out', hx, 'cold_in');
    t.wire(hx, 'cold_out', snkC, 'in');
    t.solve();

    const last = t.ud(hx).last;
    t.assertOK(last, 'HEX has results');
    t.assertOK(!last.error, 'No error');
    t.assertOK(last.Q > 0, 'Q > 0', `${last.Q?.toFixed(2)} kW`);

    // Verify physical consistency: hot cools, cold heats, no cross
    const Tho = last.T_hot_out_actual ?? last.T_hot_out;
    const Tco = last.T_cold_out_actual ?? last.T_cold_out;
    t.assertOK(Tho < last.T_hot_in, 'Hot stream cools');
    t.assertOK(Tco > last.T_cold_in, 'Cold stream heats');
    t.assertOK(Tho >= last.T_cold_in - 0.1, 'No cross: Th_out â‰¥ Tc_in', `${(Tho-273.15).toFixed(1)}Â°C`);

    // Verify Cr in (0,1] and NTU > 0
    t.assertOK(last.Cr > 0 && last.Cr <= 1, 'Cr âˆˆ (0,1]', last.Cr?.toFixed(4));
    t.assertOK(last.NTU > 0, 'NTU > 0', last.NTU?.toFixed(2));
    t.assertOK(last.epsilon > 0 && last.epsilon < 1, 'Îµ âˆˆ (0,1)', last.epsilon?.toFixed(4));
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RUNNER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let totalPass = 0, totalFail = 0;
  let testsPassed = 0, testsFailed = 0;
  const failedTests = [];

  // [v4.9.0] Suppress thermo warnings during test execution â€” they are
  // expected (extrapolation, range limits) and not actionable.
  const _origWarn = console.warn;
  console.warn = () => {};

  for (let i = 0; i < tests.length; i++) {
    const { name, fn } = tests[i];
    const ctx = new TestCtx(name, i + 1);
    try {
      ctx.clearScene();
      fn(ctx);
    } catch (err) {
      ctx.failed++;
      ctx.results.push({ name: 'UNCAUGHT', calc: err.message, ref: '-', delta: '-', tol: '-', status: 'âœ—' });
    }
    totalPass += ctx.passed; totalFail += ctx.failed;
    if (ctx.failed > 0) {
      testsFailed++;
      failedTests.push({ idx: i + 1, name, ctx });
    } else {
      testsPassed++;
    }
  }

  // Restore console.warn
  console.warn = _origWarn;

  // â”€â”€ Condensed summary (always shown) â”€â”€
  const totalChecks = totalPass + totalFail;
  const allGreen = totalFail === 0 && totalPass > 0;
  console.log(
    `${allGreen ? 'âœ“' : 'âœ—'} ${testsPassed}/${tests.length} tests passed  ` +
    `${totalPass}/${totalChecks} checks passed` +
    (totalFail > 0 ? `  (${totalFail} failed)` : '')
  );

  // â”€â”€ Detail only for failures â”€â”€
  if (failedTests.length > 0) {
    console.log('');
    for (const f of failedTests) {
      console.log(`  âœ— Test ${f.idx}: ${f.name}`);
      f.ctx._printTable();
    }
  }

  // Restore original scene
  try {
    scene.importJSON(savedJSON);
    document.getElementById('processNameInput').value = scene.processName;
    solveScene(scene);
    updatePropertiesPanel();
    render();
  } catch (e) { console.warn('Scene restore failed:', e.message); }

  return { tests: tests.length, passed: totalPass, failed: totalFail, success: allGreen };
}

window.runTests = runTests;

// [v4.9.0] Auto-run tests on page load. Menu option still available for re-runs.
setTimeout(() => {
  try { runTests(); } catch (e) { console.error('Test execution error:', e); }
}, 500);

</script>
</body>
</html>
