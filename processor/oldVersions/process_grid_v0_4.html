<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Process Grid â€” v0.4</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
      background: #0f1115; 
      color: #e7e7e7; 
      overflow: hidden; 
    }

    /* ===== LAYOUT ===== */
    .app { 
      height: 100vh; 
      display: grid; 
      grid-template-columns: 1fr 360px; 
    }
    
    .canvasWrap { 
      position: relative; 
    }
    
    #svg { 
      width: 100%; 
      height: 100%; 
      display: block;
      background: radial-gradient(1200px 700px at 40% 30%, #141a26 0%, #0f1115 55%, #0b0d12 100%);
      touch-action: none;
    }
    
    .rightPanel {
      border-left: 1px solid #2a2f3a;
      background: #0b0e14cc;
      backdrop-filter: blur(10px);
      overflow: auto;
      padding: 14px;
      display: flex;
      flex-direction: column;
    }
    
    .rightPanel h2 { 
      margin: 0 0 10px; 
      font-size: 14px; 
      letter-spacing: 0.3px; 
    }
    
    .card { 
      border: 1px solid #2a2f3a; 
      border-radius: 14px; 
      padding: 12px; 
      background: #0b0e14aa; 
    }
    
    .card + .card { 
      margin-top: 10px; 
    }

    /* ===== TOP BAR ===== */
    .topbar {
      position: absolute; 
      left: 10px; 
      top: 10px; 
      z-index: 5;
      display: flex; 
      gap: 10px; 
      align-items: center;
      background: #0b0e14cc; 
      border: 1px solid #2a2f3a; 
      border-radius: 14px; 
      padding: 8px 10px;
      backdrop-filter: blur(10px);
    }
    
    .btn {
      display: inline-flex; 
      align-items: center; 
      gap: 8px;
      background: #1c222e; 
      color: #e7e7e7; 
      border: 1px solid #2a2f3a;
      border-radius: 12px; 
      padding: 9px 12px; 
      cursor: pointer; 
      font-weight: 700;
      user-select: none;
    }
    
    .btn:hover { 
      border-color: #475068; 
    }
    
    .btn.primary { 
      background: #2563eb; 
      border-color: #2563eb; 
    }
    
    .btn.primary:hover { 
      filter: brightness(1.05); 
    }
    
    .pill { 
      padding: 2px 8px; 
      border-radius: 999px; 
      border: 1px solid #2a2f3a; 
      opacity: .9; 
      font-size: 12px; 
    }

    /* ===== MENUS ===== */
    .menuWrap { 
      position: relative; 
    }
    
    .menu {
      position: absolute; 
      top: 46px; 
      left: 0;
      min-width: 230px;
      background: #0b0e14f2;
      border: 1px solid #2a2f3a; 
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      padding: 8px;
      display: none;
      z-index: 10;
    }
    
    .menu.open { 
      display: block; 
    }
    
    .menu .item {
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    
    .menu .item:hover { 
      background: #1b2230; 
    }
    
    .menu .item .hint { 
      opacity: 0.75; 
      font-size: 12px; 
    }
    
    .menu .sep { 
      height: 1px; 
      background: #2a2f3a; 
      margin: 6px 4px; 
    }

    /* ===== MODELS DRAWER ===== */
    .drawer {
      position: absolute; 
      left: 10px; 
      top: 64px; 
      z-index: 6;
      width: 260px; 
      max-height: calc(100vh - 84px);
      border: 1px solid #2a2f3a; 
      border-radius: 16px;
      background: #0b0e14cc;
      backdrop-filter: blur(10px);
      overflow: auto;
      padding: 10px;
      display: none;
    }
    
    .drawer.open { 
      display: block; 
    }
    
    .drawer h3 { 
      margin: 6px 6px 8px; 
      font-size: 13px; 
      opacity: 0.9; 
    }

    /* ===== FORM CONTROLS ===== */
    .row { 
      display: grid; 
      grid-template-columns: 1fr 140px; 
      gap: 10px; 
      align-items: center; 
      margin: 10px 0; 
    }
    
    .row label { 
      font-size: 12px; 
      opacity: .9; 
    }
    
    input, select, textarea {
      width: 100%; 
      background: #0b0e14; 
      color: #e7e7e7; 
      border: 1px solid #2a2f3a; 
      border-radius: 12px;
      padding: 8px 10px; 
      font-size: 12px;
    }
    
    .small { 
      font-size: 12px; 
      opacity: 0.85; 
      line-height: 1.35; 
    }
    
    .status { 
      white-space: pre-wrap; 
      font-size: 12px; 
      opacity: 0.9; 
    }

    /* ===== VISUALIZATIONS ===== */
    .bar { 
      height: 10px; 
      border: 1px solid #2a2f3a; 
      border-radius: 999px; 
      overflow: hidden; 
      background: #0b0e14; 
    }
    
    .bar > div { 
      height: 100%; 
      width: 0%; 
      background: #60a5fa; 
    }
    
    .kv { 
      display: flex; 
      justify-content: space-between; 
      font-size: 12px; 
      margin: 6px 0; 
      gap: 10px; 
    }
    
    .mono { 
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace; 
    }
    
    .swatch { 
      width: 10px; 
      height: 10px; 
      border-radius: 999px; 
      display: inline-block; 
      margin-right: 6px; 
      vertical-align: middle; 
    }

    /* ===== PROPERTIES PANEL ===== */
    .unitHeader {
      margin-bottom: 16px;
    }
    
    .unitTitle {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .unitTitle input {
      flex: 1;
      background: transparent;
      border: 1px solid transparent;
      padding: 4px 8px;
      font-size: 16px;
      font-weight: 700;
      color: #e7e7e7;
      border-radius: 6px;
    }
    
    .unitTitle input:hover {
      background: #1c222e;
      border-color: #2a2f3a;
    }
    
    .unitTitle input:focus {
      background: #1c222e;
      border-color: #60a5fa;
      outline: none;
    }
    
    .unitSubtitle {
      font-size: 12px;
      opacity: 0.6;
    }
    
    /* Bordered sections (Parameters, Properties) */
    .borderedSection {
      border: 1px solid #2a2f3a;
      border-radius: 12px;
      padding: 12px;
      background: transparent;
      margin-bottom: 10px;
    }
    
    .sectionHeader {
      font-size: 11px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
      margin-bottom: 12px;
      padding: 0;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .sectionHeader:hover {
      opacity: 1;
    }
    
    .sectionToggle {
      font-size: 10px;
      opacity: 0.5;
      transition: transform 0.2s;
    }
    
    .sectionToggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .sectionContent {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .sectionContent.collapsed {
      max-height: 0;
    }
    
    /* Subsections (Details inside Properties) */
    .subSection {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #2a2f3a;
    }
    
    .subSectionHeader {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.6;
      margin-bottom: 8px;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .subSectionHeader:hover {
      opacity: 0.8;
    }
    
    .subSectionToggle {
      font-size: 9px;
      opacity: 0.5;
      transition: transform 0.2s;
    }
    
    .subSectionToggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .subSectionContent {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .subSectionContent.collapsed {
      max-height: 0;
    }
    
    .propGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .propItem {
      background: #0f1420;
      border: 1px solid #2a2f3a;
      border-radius: 10px;
      padding: 8px 10px;
    }
    
    .propLabel {
      font-size: 10px;
      opacity: 0.7;
      margin-bottom: 2px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .propValue {
      font-size: 14px;
      font-weight: 700;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    
    .propUnit {
      font-size: 11px;
      opacity: 0.6;
      margin-left: 3px;
    }
    
    .compBadge {
      display: inline-block;
      background: #1c222e;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 11px;
      margin: 4px 4px 4px 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    
    .compBadge .spec { 
      font-weight: 700; 
    }
    
    .compBadge .pct { 
      opacity: 0.7; 
      margin-left: 4px; 
    }

    /* ===== CONTROLS SECTION ===== */
    .controlsSection {
      margin-top: auto;
      padding-top: 14px;
      border-top: 1px solid #2a2f3a;
    }
    
    .controlsGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 12px;
      font-size: 11px;
      line-height: 1.5;
    }
    
    .controlsGrid b {
      font-weight: 600;
      opacity: 0.9;
    }

    /* ===== UNIT LIBRARY IN RIGHT PANEL ===== */
    .unitLibraryGrid { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 10px; 
    }
    
    .unitLibraryCard {
      border: 1px solid #2a2f3a;
      border-radius: 12px;
      background: #0f1420;
      padding: 12px;
      cursor: grab;
      transition: all 0.2s;
      user-select: none;
    }
    
    .unitLibraryCard:active {
      cursor: grabbing;
    }
    
    .unitLibraryCard:hover {
      border-color: #475068;
      background: #1c222e;
    }
    
    .unitLibraryCard .name { 
      font-size: 12px; 
      font-weight: 800; 
      margin-bottom: 4px; 
    }
    
    .unitLibraryCard .desc { 
      font-size: 11px; 
      opacity: 0.75; 
      line-height: 1.2; 
    }
  </style>
</head>
<body>
<div class="app">
  <div class="canvasWrap">
    <!-- Top toolbar -->
    <div class="topbar">
      <button class="btn primary" id="btnRun">â–¶ Run</button>
      <button class="btn" id="btnAdd" style="background:#dc2626; border-color:#dc2626; color:#fff;">+ Add Unit</button>

      <div class="menuWrap">
        <button class="btn" id="btnMenu">â˜° Menu</button>
        <div class="menu" id="menuMain">
          <div class="item" id="mToggleModels">Models <span class="hint">physics</span></div>
          <div class="sep"></div>
          <div class="item" id="mRotate">Rotate <span class="hint">R</span></div>
          <div class="item" id="mDelete">Delete <span class="hint">Del</span></div>
          <div class="item" id="mClear">Clear scene</div>
        </div>
      </div>

      <div class="menuWrap">
        <button class="btn" id="btnFile">ðŸ’¾ File</button>
        <div class="menu" id="menuFile">
          <div class="item" id="mExport">Export JSON</div>
          <div class="item" id="mImport">Import JSON</div>
        </div>
      </div>
    </div>

    <!-- Models drawer (physics kernels) -->
    <div class="drawer" id="drawerModels">
      <h3>Models</h3>
      <div class="small">Choose physics kernels for calculations.</div>
      <div class="card" id="modelsPanel"></div>
    </div>

    <!-- Main SVG canvas -->
    <svg id="svg" xmlns="http://www.w3.org/2000/svg" aria-label="process grid">
      <defs>
        <symbol id="ico-source" viewBox="0 0 64 64">
          <circle cx="20" cy="32" r="10" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M32 32h22" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M46 24l8 8-8 8" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
        </symbol>
        <symbol id="ico-sink" viewBox="0 0 64 64">
          <path d="M12 18h40" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M18 18v26c0 8 6 14 14 14s14-6 14-14V18" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M26 30h12" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
        </symbol>
        <symbol id="ico-hx" viewBox="0 0 64 64">
          <path d="M10 20h44" stroke="currentColor" stroke-width="4"/>
          <path d="M10 44h44" stroke="currentColor" stroke-width="4"/>
          <path d="M16 20c8 8 8 16 0 24" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M48 20c-8 8-8 16 0 24" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M32 6v12" stroke="currentColor" stroke-width="4"/>
          <path d="M26 14h12" stroke="currentColor" stroke-width="4"/>
        </symbol>
        <symbol id="ico-power" viewBox="0 0 64 64">
          <path d="M36 6 16 36h16l-4 22 20-30H32z" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
        </symbol>
        <symbol id="ico-pipe" viewBox="0 0 64 64">
          <path d="M10 32h44" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <path d="M42 24l12 8-12 8" fill="none" stroke="currentColor" stroke-width="6" stroke-linejoin="round"/>
        </symbol>
      </defs>
    </svg>
  </div>

  <!-- Right panel for properties and unit library -->
  <aside class="rightPanel">
    <div class="card" id="propEditor"></div>

    <!-- Controls section at bottom -->
    <div class="controlsSection">
      <div class="controlsGrid">
        <div><b>Pan:</b> Shift + drag</div>
        <div><b>Zoom:</b> Mouse wheel</div>
        <div><b>Rotate:</b> R key</div>
        <div><b>Delete:</b> Del/Backspace</div>
      </div>
    </div>
  </aside>

  <!-- Hidden textarea for import/export operations -->
  <textarea id="io" style="display:none;"></textarea>
</div>

<script>
"use strict";

/* =========================
   CONSTANTS & ENUMS
   ========================= */
const PortDir = { IN: 0, OUT: 1 };
const StreamType = { 
  MATERIAL: 0,  // Grey
  HEAT: 1,      // Yellow/orange
  MECHANICAL: 2, // Purple
  ELECTRICAL: 3  // Green
};

// Stream visual properties
const StreamVisuals = {
  [StreamType.MATERIAL]: { 
    color: '#94a3b8', 
    portColor: '#94a3b8' 
  },
  [StreamType.HEAT]: { 
    color: '#fbbf24', 
    portColor: '#fbbf24' 
  },
  [StreamType.MECHANICAL]: { 
    color: '#a855f7', 
    portColor: '#a855f7' 
  },
  [StreamType.ELECTRICAL]: { 
    color: '#22c55e', 
    portColor: '#22c55e' 
  }
};

/* =========================
   UTILITY FUNCTIONS
   ========================= */
function clamp(v, min, max) { 
  return Math.max(min, Math.min(max, v)); 
}

function compToString(comp) {
  if (!comp) return '';
  const arr = Object.entries(comp)
    .filter(([, f]) => f > 1e-6)
    .map(([s, f]) => `${s}:${(f * 100).toFixed(1)}%`);
  return arr.join(' ');
}

function formatStream(s) {
  if (!s) return 'â€”';
  if (s.type === StreamType.ELECTRICAL) 
    return `âš¡ Q=${s.QkW.toFixed(1)} kW`;
  if (s.type === StreamType.HEAT) 
    return `Heat Q=${s.QkW.toFixed(1)} kW`;
  if (s.type === StreamType.MECHANICAL) 
    return `Work W=${s.WkW.toFixed(1)} kW`;
  if (s.type === StreamType.MATERIAL) {
    if (s.phase === 'gas')
      return `Gas n=${s.nDot.toFixed(3)} mol/s T=${s.T.toFixed(1)}Â°C P=${(s.P / 100000).toFixed(2)} bar`;
    if (s.phase === 'liquid')
      return `Liq m=${s.mDot.toFixed(4)} kg/s T=${s.T.toFixed(1)}Â°C P=${(s.P / 100000).toFixed(2)} bar`;
  }
  return JSON.stringify(s);
}

// Validation: Ensure stream type matches port type
function validateStreamType(stream, portType) {
  if (!stream) return false;
  if (stream.type !== portType) {
    console.error(`Stream type mismatch: stream.type=${stream.type}, portType=${portType}`);
    return false;
  }
  return true;
}

/* =========================
   MODEL REGISTRY
   Physics kernels for thermodynamics, PVT, etc.
   ========================= */
class ModelRegistry {
  constructor() {
    this.catalog = {
      pvt_gas: new Map(),
      thermo: new Map(),
      water_psat: new Map(),
      humidity: new Map(),
      reaction: new Map(),
      hx: new Map(),
      pressure_drop: new Map(),
    };
    this.active = {
      pvt_gas: null,
      thermo: null,
      water_psat: null,
      humidity: null,
      reaction: null,
      hx: null,
      pressure_drop: null,
    };
  }

  register(kind, model) {
    if (!this.catalog[kind]) throw new Error(`Unknown model kind: ${kind}`);
    if (!model?.id) throw new Error("Model must have id");
    this.catalog[kind].set(model.id, model);
    if (!this.active[kind]) this.active[kind] = model.id;
  }

  get(kind, id) {
    const m = this.catalog[kind];
    if (!m) return null;
    return m.get(id) || null;
  }

  list(kind) {
    const m = this.catalog[kind];
    if (!m) return [];
    return Array.from(m.values());
  }

  setActive(kind, id) {
    this.active[kind] = id;
  }

  getActive(kind) {
    return this.get(kind, this.active[kind]);
  }
}

const models = new ModelRegistry();

/* =========================
   MODEL IMPLEMENTATIONS
   ========================= */

// PVT Models (Pressure-Volume-Temperature)
models.register('pvt_gas', {
  id: 'ideal',
  name: 'Ideal gas',
  desc: 'PV = nRT (constant cp/cv)',
  cpMolar(species, T, P) { return 29.1; },
  density(species, T, P) { 
    const R = 8.314; 
    return P / (R * (T + 273.15)); 
  },
  enthalpy(species, T, P) { 
    return this.cpMolar(species, T, P) * T; 
  },
});

// Thermodynamics Models
models.register('thermo', {
  id: 'constant_cp',
  name: 'Constant Cp',
  desc: 'Simplified constant heat capacity',
  cpMolar(species, T) { return 29.1; },
  enthalpyMolar(species, T) { return this.cpMolar(species, T) * T; }
});

// Water Saturation Pressure
models.register('water_psat', {
  id: 'antoine',
  name: 'Antoine eq.',
  desc: 'log10(Psat)=A-B/(C+T) (water)',
  Psat(T) {
    const A = 8.07131, B = 1730.63, C = 233.426;
    return Math.pow(10, A - B / (C + T)) * 133.322;
  }
});

// Humidity & Condensation
models.register('humidity', {
  id: 'simple',
  name: 'Simple phi',
  desc: 'Relative humidity (ideal)',
  relativeHumidity(PH2O, T) {
    const Psat = models.getActive('water_psat').Psat(T);
    return PH2O / Psat;
  },
  condensate(comp, nDot, T, P) {
    const xH2O = comp.H2O || 0;
    const PH2O = xH2O * P;
    const Psat = models.getActive('water_psat').Psat(T);
    if (PH2O <= Psat) return { nCondensed: 0, compOut: comp };
    
    const excess = PH2O - Psat;
    const nCondensed = (excess / P) * nDot;
    const newTotal = nDot - nCondensed;
    const compOut = {};
    for (const sp in comp) {
      if (sp === 'H2O') {
        compOut[sp] = ((comp[sp] * nDot) - nCondensed) / newTotal;
      } else {
        compOut[sp] = comp[sp] * nDot / newTotal;
      }
    }
    return { nCondensed, compOut };
  }
});

// Heat Exchanger
models.register('hx', {
  id: 'cop_cooling',
  name: 'COP cooling',
  desc: 'COP = Q_cooling / W_electric',
  coolingPower(QkW_electric, COP) { 
    return QkW_electric * COP; 
  }
});

// Pressure Drop
models.register('pressure_drop', {
  id: 'none',
  name: 'No Î”P',
  desc: 'P_out = P_in',
  deltaPFraction() { return 0; }
});

/* =========================
   UNIT CATEGORIES
   Categories for organizing units with color coding
   ========================= */
const UnitCategories = {
  SOURCE: { name: 'Sources', color: '#10b981' },      // Green
  SINK: { name: 'Sinks', color: '#6366f1' },          // Indigo
  SEPARATOR: { name: 'Separators', color: '#8b5cf6' }, // Purple
  REACTOR: { name: 'Reactors', color: '#ef4444' },    // Red
  HEAT_EXCHANGER: { name: 'Heat Exchangers', color: '#3b82f6' }, // Blue
  UTILITY: { name: 'Utilities', color: '#eab308' },   // Yellow
  TEST: { name: 'Test Units', color: '#ec4899' }      // Pink
};

/* =========================
   UNIT REGISTRY
   Defines available unit operations
   
   STREAM TYPE SYSTEM:
   -------------------
   Each port MUST have a 'type' field that matches one of:
   - StreamType.MATERIAL  (for gas/liquid material streams)
   - StreamType.HEAT      (for heat transfer)
   - StreamType.MECHANICAL (for mechanical work)
   - StreamType.ELECTRICAL (for electrical power)
   
   Port definition format:
   { portId: 'unique_id', dir: PortDir.IN/OUT, type: StreamType.XXX, x: pos_x, y: pos_y }
   
   Stream object MUST have matching 'type' field:
   - MATERIAL: { type: StreamType.MATERIAL, phase: 'gas'/'liquid', T, P, nDot/mDot, comp }
   - HEAT: { type: StreamType.HEAT, QkW }
   - MECHANICAL: { type: StreamType.MECHANICAL, WkW }
   - ELECTRICAL: { type: StreamType.ELECTRICAL, QkW }
   
   Connections are only allowed between ports of the SAME type.
   The solver validates that streams produced match their port types.
   
   CATEGORY SYSTEM:
   ---------------
   Each unit belongs to a category from UnitCategories.
   Units in the same category share the same color.
   Category is displayed in the properties panel.
   ========================= */
class UnitRegistry {
  static _defs = new Map();

  static register(defId, spec) {
    const category = spec.category || UnitCategories.UTILITY;
    const def = {
      defId,
      name: spec.name,
      category: category.name,
      w: spec.w || 1,
      h: spec.h || 1,
      color: category.color, // Color comes from category
      ports: spec.ports || [],
      tick: spec.tick || null
    };
    this._defs.set(defId, def);
  }

  static get(id) { 
    return this._defs.get(id); 
  }

  static list() { 
    return Array.from(this._defs.values()); 
  }
  
  static listByCategory() {
    const byCategory = {};
    for (const def of this._defs.values()) {
      const cat = def.category;
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push(def);
    }
    return byCategory;
  }
}

// Gas Source
UnitRegistry.register('source_gas', {
  name: 'Gas source',
  category: UnitCategories.SOURCE,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    ports.out = {
      type: StreamType.MATERIAL,
      phase: 'gas',
      nDot: par.nDot,
      T: par.T,
      P: par.P,
      comp: { [par.species]: 1.0 }
    };
  }
});

// Power Source
UnitRegistry.register('source_power', {
  name: 'Power',
  category: UnitCategories.UTILITY,
  w: 1,
  h: 1,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 1, y: 0.5 }],
  tick(u, ports, par) {
    ports.out = { type: StreamType.ELECTRICAL, QkW: par.QkW };
  }
});

// Heat Exchanger (COP-based cooling)
UnitRegistry.register('hx_cop', {
  name: 'HX (COP)',
  category: UnitCategories.HEAT_EXCHANGER,
  w: 3,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'power', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 1.5, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 3, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    const sP = ports.power;
    if (!sIn || !sP) return;

    const hx = models.getActive('hx');
    const Qcool = hx.coolingPower(sP.QkW, par.COP);
    
    const thermo = models.getActive('thermo');
    const cp = thermo.cpMolar('H2', sIn.T);
    const dT = Qcool * 1000 / (sIn.nDot * cp);
    
    let Tout = sIn.T - dT;
    if (Tout < par.TminClamp) Tout = par.TminClamp;

    const hum = models.getActive('humidity');
    const res = hum.condensate(sIn.comp, sIn.nDot, Tout, sIn.P);
    const nOut = sIn.nDot - res.nCondensed;

    u.last = { Qcool, dT, Tout, nCondensed: res.nCondensed };
    ports.mat_out = {
      type: StreamType.MATERIAL,
      phase: 'gas',
      nDot: nOut,
      T: Tout,
      P: sIn.P,
      comp: res.compOut
    };
  }
});

// Sink
UnitRegistry.register('sink', {
  name: 'Sink',
  category: UnitCategories.SINK,
  w: 2,
  h: 2,
  ports: [{ portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 }],
  tick(u, ports, par) { 
    // Sink does nothing - just terminates streams
  }
});

// Test Unit - All ports on all sides for testing
UnitRegistry.register('test_allports', {
  name: 'Test All Ports',
  category: UnitCategories.TEST,
  w: 3,
  h: 3,
  ports: [
    // Left side
    { portId: 'left_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'left_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 0, y: 2 },
    // Right side
    { portId: 'right_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 3, y: 1 },
    { portId: 'right_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 3, y: 2 },
    // Top side
    { portId: 'top_in', dir: PortDir.IN, type: StreamType.HEAT, x: 1, y: 0 },
    { portId: 'top_out', dir: PortDir.OUT, type: StreamType.HEAT, x: 2, y: 0 },
    // Bottom side
    { portId: 'bottom_in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 1, y: 3 },
    { portId: 'bottom_out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 3 }
  ],
  tick(u, ports, par) {
    // Pass through for testing
    if (ports.left_in) ports.left_out = { ...ports.left_in };
    if (ports.right_in) ports.right_out = { ...ports.right_in };
    if (ports.top_in) ports.top_out = { ...ports.top_in };
    if (ports.bottom_in) ports.bottom_out = { ...ports.bottom_in };
  }
});

/* =========================
   SCENE CLASS
   Manages the process flowsheet state
   ========================= */
class Scene {
  constructor() {
    // Grid properties (kept for backwards compatibility in export/import)
    this.gridW = 22;
    this.gridH = 14;
    this.tile = 48; // Size of one grid cell in world units
    
    // Scene data
    this.units = new Map();
    this.connections = [];
    this._idCounter = 0;
    
    // Runtime calculation results
    this.runtime = {
      unitData: new Map(),
      lastSolve: { ok: true, iterations: 0, warnings: [] }
    };
  }

  placeUnit(defId, x, y) {
    const def = UnitRegistry.get(defId);
    if (!def) return null;
    
    // Check collision with existing units
    if (this._collision(x, y, def.w, def.h, null)) return null;
    
    // Create new unit with default parameters
    const id = `${defId}-${++this._idCounter}`;
    const unit = { 
      id, 
      defId, 
      name: `${def.name} ${this._idCounter}`, // Default name
      x, 
      y, 
      rot: 0, 
      params: {} 
    };
    
    // Set default parameters based on unit type
    switch (defId) {
      case 'source_gas':
        unit.params = { species: 'H2', T: 25, P: 101325, nDot: 1.0 };
        break;
      case 'source_power':
        unit.params = { QkW: 10 };
        break;
      case 'hx_cop':
        unit.params = { COP: 2.5, TminClamp: -50 };
        break;
    }
    
    this.units.set(id, unit);
    return id;
  }

  deleteUnit(id) {
    this.units.delete(id);
    // Remove all connections involving this unit
    this.connections = this.connections.filter(
      c => c.from.unitId !== id && c.to.unitId !== id
    );
  }

  moveUnit(id, nx, ny) {
    const u = this.units.get(id);
    if (!u) return;
    
    const def = UnitRegistry.get(u.defId);
    
    // Check collision at new position
    if (this._collision(nx, ny, def.w, def.h, id)) return;
    
    u.x = nx;
    u.y = ny;
  }

  rotateUnit(id) {
    const u = this.units.get(id);
    if (!u) return;
    u.rot = (u.rot + 1) % 4;
  }

  unitAt(x, y) {
    for (const [id, u] of this.units) {
      const def = UnitRegistry.get(u.defId);
      if (x >= u.x && x < u.x + def.w && y >= u.y && y < u.y + def.h) {
        return u;
      }
    }
    return null;
  }

  _collision(x, y, w, h, skipId) {
    for (const [id, u] of this.units) {
      if (id === skipId) continue;
      
      const def = UnitRegistry.get(u.defId);
      const ox = u.x, oy = u.y, ow = def.w, oh = def.h;
      
      // AABB collision detection
      if (!(x + w <= ox || ox + ow <= x || y + h <= oy || oy + oh <= y)) {
        return true;
      }
    }
    return false;
  }

  connect(from, to) {
    // Check if target IN port already has a connection
    const existingToPort = this.connections.find(
      c => c.to.unitId === to.unitId && c.to.portId === to.portId
    );
    if (existingToPort) return null;

    // Check if source OUT port already has a connection (1-to-1 relationship)
    const existingFromPort = this.connections.find(
      c => c.from.unitId === from.unitId && c.from.portId === from.portId
    );
    if (existingFromPort) return null;

    // Validate units exist
    const uFrom = this.units.get(from.unitId);
    const uTo = this.units.get(to.unitId);
    if (!uFrom || !uTo) return null;

    // Validate ports exist and are compatible
    const defFrom = UnitRegistry.get(uFrom.defId);
    const defTo = UnitRegistry.get(uTo.defId);
    const pFrom = defFrom.ports.find(p => p.portId === from.portId);
    const pTo = defTo.ports.find(p => p.portId === to.portId);
    if (!pFrom || !pTo) return null;
    if (pFrom.type !== pTo.type) return null; // Check stream type compatibility

    // Create connection
    const id = `conn-${++this._idCounter}`;
    this.connections.push({ id, from, to });
    return id;
  }

  exportJSON() {
    const data = {
      version: 7,
      grid: { w: this.gridW, h: this.gridH, tile: this.tile },
      units: [],
      connections: [],
      modelsActive: models.active
    };
    
    for (const u of this.units.values()) {
      data.units.push({
        id: u.id,
        defId: u.defId,
        name: u.name,
        x: u.x,
        y: u.y,
        rot: u.rot,
        params: u.params
      });
    }
    
    data.connections = [...this.connections];
    return JSON.stringify(data, null, 2);
  }

  importJSON(str) {
    const data = JSON.parse(str);
    this.gridW = data.grid.w;
    this.gridH = data.grid.h;
    this.tile = data.grid.tile;
    
    this.units.clear();
    this.connections = [];
    
    for (const u of data.units) {
      this.units.set(u.id, u);
    }
    
    this.connections = data.connections || [];
    
    if (data.modelsActive) {
      for (const k in data.modelsActive) {
        models.setActive(k, data.modelsActive[k]);
      }
    }
  }
}

const scene = new Scene();

/* =========================
   SOLVER
   Successive substitution for flowsheet calculations
   ========================= */
function solveScene(scene) {
  const MAX_ITER = 20;
  let iter = 0;
  let changed = true;

  // Initialize runtime data for all units
  scene.runtime.unitData.clear();
  for (const [id, u] of scene.units) {
    scene.runtime.unitData.set(id, {
      ports: {},
      last: {},
      errors: []
    });
  }

  // Iterative successive substitution
  while (changed && iter < MAX_ITER) {
    changed = false;
    iter++;

    for (const [id, u] of scene.units) {
      const def = UnitRegistry.get(u.defId);
      if (!def.tick) continue;

      const ud = scene.runtime.unitData.get(id);
      const inPorts = {};

      // Gather input streams from connections
      for (const p of def.ports) {
        if (p.dir === PortDir.IN) {
          const conn = scene.connections.find(
            c => c.to.unitId === id && c.to.portId === p.portId
          );
          if (conn) {
            const fromUD = scene.runtime.unitData.get(conn.from.unitId);
            inPorts[p.portId] = fromUD?.ports?.[conn.from.portId] || null;
          } else {
            inPorts[p.portId] = null;
          }
        }
      }

      // Store old state to detect changes
      const oldJSON = JSON.stringify(ud.ports);

      // Execute unit calculation
      def.tick(u, inPorts, u.params);

      // Store output streams and validate types
      for (const p of def.ports) {
        if (p.dir === PortDir.OUT) {
          const stream = inPorts[p.portId];
          ud.ports[p.portId] = stream;
          
          // Validate stream type matches port type
          if (stream && !validateStreamType(stream, p.type)) {
            ud.errors.push(`Port ${p.portId}: stream type mismatch`);
          }
        }
      }

      // Check if anything changed
      const newJSON = JSON.stringify(ud.ports);
      if (oldJSON !== newJSON) changed = true;

      // Store unit-specific calculation results
      ud.last = u.last || {};
    }
  }

  // Store solve results
  const ok = !changed || iter < MAX_ITER;
  const warnings = [];
  if (!ok) warnings.push('Max iterations reached - loop may not have converged');
  
  scene.runtime.lastSolve = { ok, iterations: iter, warnings };
}

/* =========================
   UI STATE
   ========================= */
const ui = {
  view: { x: 0, y: 0, w: 1056, h: 672 }, // Updated dynamically by setViewBox
  selectedUnitId: null,
  selectedConnId: null,
  pendingFrom: null, // Connection mode: {unitId, portId}
  isPanning: false,
  panStart: null,
  isDraggingUnit: false,
  dragUnitId: null,
  dragOffset: null, // {cellX, cellY} offset in grid units
  dragDefId: null,
  isHTML5Dragging: false, // Track HTML5 drag from library
  _mouseWorld: { x: 0, y: 0 }
};

/* =========================
   DOM REFERENCES
   ========================= */
const svg = document.getElementById('svg');
const ioEl = document.getElementById('io');
const propEditor = document.getElementById('propEditor');
const btnRun = document.getElementById('btnRun');
const btnAdd = document.getElementById('btnAdd');
const btnMenu = document.getElementById('btnMenu');
const btnFile = document.getElementById('btnFile');
const menuMain = document.getElementById('menuMain');
const menuFile = document.getElementById('menuFile');
const drawerModels = document.getElementById('drawerModels');
const modelsPanelEl = document.getElementById('modelsPanel');

// Status is now managed within propEditor
let statusSection = null;
let statusContent = null;

/* =========================
   UI HELPER FUNCTIONS
   ========================= */
function setStatus(s) {
  // Create status section if it doesn't exist
  if (!statusSection) {
    const result = createCollapsibleSection('STATUS', false);
    statusSection = result.section;
    statusContent = result.content;
    
    // Append after propEditor card in the right panel
    const rightPanel = propEditor.parentNode;
    const controlsEl = rightPanel.querySelector('.controlsSection');
    if (controlsEl) {
      rightPanel.insertBefore(statusSection, controlsEl);
    } else {
      rightPanel.appendChild(statusSection);
    }
  }
  
  // Update status text
  statusContent.innerHTML = `<div class="status" style="padding:8px 0; white-space:pre-wrap; font-size:12px; opacity:0.9;">${s}</div>`;
  
  // Auto-expand on update
  const toggle = statusSection.querySelector('.sectionToggle');
  if (toggle && toggle.classList.contains('collapsed')) {
    toggle.classList.remove('collapsed');
    statusContent.classList.remove('collapsed');
  }
}

function closeMenus() {
  menuMain.classList.remove('open');
  menuFile.classList.remove('open');
}

function toggle(el) {
  el.classList.toggle('open');
}

/* =========================
   SVG HELPERS
   ========================= */
function svgEl(tag, attrs) {
  const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k, v] of Object.entries(attrs)) {
    e.setAttribute(k, String(v));
  }
  return e;
}

function clearSVG() {
  // Remove all children except <defs>
  while (svg.childNodes.length > 1) {
    svg.removeChild(svg.lastChild);
  }
}

function screenToWorld(sx, sy) {
  const r = svg.getBoundingClientRect();
  const nx = (sx - r.left) / r.width;
  const ny = (sy - r.top) / r.height;
  return {
    x: ui.view.x + nx * ui.view.w,
    y: ui.view.y + ny * ui.view.h
  };
}

function worldToCell(wx, wy) {
  return {
    x: Math.floor(wx / scene.tile),
    y: Math.floor(wy / scene.tile)
  };
}

function setViewBox() {
  const rect = svg.getBoundingClientRect();
  const aspectRatio = rect.width / rect.height;
  
  // Initialize view dimensions if needed
  if (!ui.view.w || !ui.view.h) {
    const baseHeight = 672;
    ui.view.w = baseHeight * aspectRatio;
    ui.view.h = baseHeight;
  }
  
  svg.setAttribute('viewBox', `${ui.view.x} ${ui.view.y} ${ui.view.w} ${ui.view.h}`);
}

/* =========================
   PORT EDGE DETECTION
   Determines which edge of a unit a port is on
   ========================= */
function getPortEdge(port, unitDef) {
  const tolerance = 0.1; // Small tolerance for edge detection
  
  // Check if port is on left edge
  if (port.x <= tolerance) return 'left';
  
  // Check if port is on right edge
  if (port.x >= unitDef.w - tolerance) return 'right';
  
  // Check if port is on top edge
  if (port.y <= tolerance) return 'top';
  
  // Check if port is on bottom edge
  if (port.y >= unitDef.h - tolerance) return 'bottom';
  
  // Fallback: determine by which edge is closest
  const distToLeft = port.x;
  const distToRight = unitDef.w - port.x;
  const distToTop = port.y;
  const distToBottom = unitDef.h - port.y;
  
  const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
  
  if (minDist === distToLeft) return 'left';
  if (minDist === distToRight) return 'right';
  if (minDist === distToTop) return 'top';
  return 'bottom';
}

/* =========================
   RENDERING
   ========================= */
function drawGrid() {
  const g = svgEl('g', { id: 'grid' });
  const x1 = ui.view.x, y1 = ui.view.y;
  const x2 = ui.view.x + ui.view.w, y2 = ui.view.y + ui.view.h;
  const t = scene.tile;
  
  // Calculate visible grid range
  const startX = Math.floor(x1 / t) * t;
  const endX = Math.ceil(x2 / t) * t;
  const startY = Math.floor(y1 / t) * t;
  const endY = Math.ceil(y2 / t) * t;
  
  // Draw vertical lines
  for (let wx = startX; wx <= endX; wx += t) {
    g.appendChild(svgEl('line', {
      x1: wx, y1: startY,
      x2: wx, y2: endY,
      stroke: '#1e293b',
      opacity: 0.4,
      'stroke-width': 1
    }));
  }
  
  // Draw horizontal lines
  for (let wy = startY; wy <= endY; wy += t) {
    g.appendChild(svgEl('line', {
      x1: startX, y1: wy,
      x2: endX, y2: wy,
      stroke: '#1e293b',
      opacity: 0.4,
      'stroke-width': 1
    }));
  }
  
  svg.appendChild(g);
}

function drawConnections() {
  const g = svgEl('g', { id: 'connections' });
  
  // Draw existing connections
  for (const c of scene.connections) {
    const fromU = scene.units.get(c.from.unitId);
    const toU = scene.units.get(c.to.unitId);
    if (!fromU || !toU) continue;

    const fromDef = UnitRegistry.get(fromU.defId);
    const toDef = UnitRegistry.get(toU.defId);
    const fromPort = fromDef.ports.find(p => p.portId === c.from.portId);
    const toPort = toDef.ports.find(p => p.portId === c.to.portId);
    if (!fromPort || !toPort) continue;

    const fx = (fromU.x + fromPort.x) * scene.tile;
    const fy = (fromU.y + fromPort.y) * scene.tile;
    const tx = (toU.x + toPort.x) * scene.tile;
    const ty = (toU.y + toPort.y) * scene.tile;
    
    // Determine port edges for proper curve orientation
    const fromEdge = getPortEdge(fromPort, fromDef);
    const toEdge = getPortEdge(toPort, toDef);
    
    // Calculate control points perpendicular to each port's edge
    const controlOffset = 60; // Distance for control points
    
    let c1x, c1y, c2x, c2y;
    
    // From port control point (perpendicular to its edge)
    if (fromEdge === 'left') {
      c1x = fx - controlOffset;
      c1y = fy;
    } else if (fromEdge === 'right') {
      c1x = fx + controlOffset;
      c1y = fy;
    } else if (fromEdge === 'top') {
      c1x = fx;
      c1y = fy - controlOffset;
    } else { // bottom
      c1x = fx;
      c1y = fy + controlOffset;
    }
    
    // To port control point (perpendicular to its edge)
    if (toEdge === 'left') {
      c2x = tx - controlOffset;
      c2y = ty;
    } else if (toEdge === 'right') {
      c2x = tx + controlOffset;
      c2y = ty;
    } else if (toEdge === 'top') {
      c2x = tx;
      c2y = ty - controlOffset;
    } else { // bottom
      c2x = tx;
      c2y = ty + controlOffset;
    }
    
    const pathD = `M${fx},${fy} C${c1x},${c1y} ${c2x},${c2y} ${tx},${ty}`;

    // Get visual properties for this stream type
    const visuals = StreamVisuals[fromPort.type];
    const isSelected = ui.selectedConnId === c.id;

    const path = svgEl('path', {
      d: pathD,
      fill: 'none',
      stroke: isSelected ? '#60a5fa' : visuals.color,
      'stroke-width': isSelected ? 4 : 3,
      cursor: 'pointer'
    });

    path.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      ui.selectedConnId = c.id;
      ui.selectedUnitId = null;
      updatePropertiesPanel();
      render();
    });

    g.appendChild(path);
  }

  // Draw pending connection (during connection mode)
  if (ui.pendingFrom) {
    const u = scene.units.get(ui.pendingFrom.unitId);
    if (u) {
      const def = UnitRegistry.get(u.defId);
      const port = def.ports.find(p => p.portId === ui.pendingFrom.portId);
      if (port) {
        const fx = (u.x + port.x) * scene.tile;
        const fy = (u.y + port.y) * scene.tile;
        const mx = ui._mouseWorld.x;
        const my = ui._mouseWorld.y;
        
        const portEdge = getPortEdge(port, def);
        const controlOffset = 60;
        
        let c1x, c1y;
        if (portEdge === 'left') {
          c1x = fx - controlOffset;
          c1y = fy;
        } else if (portEdge === 'right') {
          c1x = fx + controlOffset;
          c1y = fy;
        } else if (portEdge === 'top') {
          c1x = fx;
          c1y = fy - controlOffset;
        } else { // bottom
          c1x = fx;
          c1y = fy + controlOffset;
        }
        
        const pathD = `M${fx},${fy} C${c1x},${c1y} ${mx},${my} ${mx},${my}`;
        
        const visuals = StreamVisuals[port.type];
        
        g.appendChild(svgEl('path', {
          d: pathD,
          fill: 'none',
          stroke: visuals.color,
          'stroke-width': 3,
          opacity: 0.7
        }));
      }
    }
  }

  svg.appendChild(g);
}

function drawUnits() {
  const g = svgEl('g', { id: 'units' });
  
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const wx = u.x * scene.tile;
    const wy = u.y * scene.tile;
    const ww = def.w * scene.tile;
    const wh = def.h * scene.tile;
    
    const group = svgEl('g', {});
    
    // Unit rectangle
    const rect = svgEl('rect', {
      x: wx, y: wy,
      width: ww, height: wh,
      rx: 8,
      fill: def.color,
      stroke: ui.selectedUnitId === id ? '#60a5fa' : '#1e293b',
      'stroke-width': 3,
      cursor: 'grab'
    });

    rect.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      if (ui.pendingFrom) return;
      
      // Don't start dragging existing units during HTML5 drag from library
      if (ui.isHTML5Dragging) return;
      
      ui.selectedUnitId = id;
      ui.selectedConnId = null;
      ui.isDraggingUnit = true;
      ui.dragUnitId = id;
      
      const m = screenToWorld(ev.clientX, ev.clientY);
      // Store offset in grid cell units
      ui.dragOffset = {
        cellX: (m.x / scene.tile) - u.x,
        cellY: (m.y / scene.tile) - u.y
      };
      
      
      updatePropertiesPanel();
      render();
    });

    group.appendChild(rect);

    // Unit icon
    const ico = svgEl('use', {
      href: `#ico-${def.defId.split('_')[0]}`,
      x: wx + ww / 2 - 16,
      y: wy + wh / 2 - 16,
      width: 32,
      height: 32,
      fill: '#fff',
      opacity: 0.75,
      'pointer-events': 'none'
    });
    group.appendChild(ico);

    // Unit label (using actual unit name)
    const label = svgEl('text', {
      x: wx + ww / 2,
      y: wy + wh + 14,
      'text-anchor': 'middle',
      'font-size': 10,
      'font-weight': 700,
      fill: '#e7e7e7',
      opacity: 0.9,
      'pointer-events': 'none',
      'data-unit-id': id  // Add data attribute for updates
    });
    label.textContent = u.name || def.name;
    group.appendChild(label);

    // Ports
    for (const p of def.ports) {
      const wp = {
        x: (u.x + p.x) * scene.tile,
        y: (u.y + p.y) * scene.tile
      };
      const portId = p.portId;
      const unitId = u.id;
      
      // Get color for this stream type
      const portVisuals = StreamVisuals[p.type];

      // Port circle with color coding
      const circle = svgEl('circle', {
        cx: wp.x,
        cy: wp.y,
        r: 10,
        fill: p.dir === PortDir.OUT ? portVisuals.portColor : '#1e293b',
        stroke: portVisuals.portColor,
        'stroke-width': 2.5,
        cursor: 'pointer'
      });

      circle.addEventListener('pointerdown', (ev) => {
        ev.stopPropagation();
        const port = p;
        
        if (port.dir === PortDir.OUT && !ui.pendingFrom) {
          // Start connection mode
          ui.selectedUnitId = null;
          ui.pendingFrom = { unitId, portId };
          ui.selectedConnId = null;
          setStatus('Connect: click a compatible IN port.');
          render();
          return;
        }
        
        if (port.dir === PortDir.IN && ui.pendingFrom) {
          // Complete connection
          const id = scene.connect(ui.pendingFrom, { unitId, portId });
          setStatus(id 
            ? 'Connection added.' 
            : 'Connection refused: port already connected or incompatible type.');
          ui.pendingFrom = null;
          updatePropertiesPanel();
          render();
        }
      });

      group.appendChild(circle);

      // Directional arrow - orient based on which edge the port is on
      const portEdge = getPortEdge(p, def);
      
      if (p.dir === PortDir.OUT) {
        // OUT port: arrow points OUTWARD from unit (away from center)
        let arrowPath;
        if (portEdge === 'top') {
          // Points UP (away from unit)
          arrowPath = `M${wp.x - 3},${wp.y + 2} L${wp.x + 3},${wp.y + 2} L${wp.x},${wp.y - 4} Z`;
        } else if (portEdge === 'bottom') {
          // Points DOWN (away from unit)
          arrowPath = `M${wp.x - 3},${wp.y - 2} L${wp.x + 3},${wp.y - 2} L${wp.x},${wp.y + 4} Z`;
        } else if (portEdge === 'right') {
          // Points RIGHT (away from unit) - REVERSED
          arrowPath = `M${wp.x - 2},${wp.y - 3} L${wp.x - 2},${wp.y + 3} L${wp.x + 4},${wp.y} Z`;
        } else { // left
          // Points LEFT (away from unit) - REVERSED
          arrowPath = `M${wp.x + 2},${wp.y - 3} L${wp.x + 2},${wp.y + 3} L${wp.x - 4},${wp.y} Z`;
        }
        const arrow = svgEl('path', {
          d: arrowPath,
          fill: '#0b0e14',
          'pointer-events': 'none'
        });
        group.appendChild(arrow);
      } else {
        // IN port: arrow points INWARD to unit (toward center)
        let arrowPath;
        if (portEdge === 'top') {
          // Points DOWN (into unit)
          arrowPath = `M${wp.x - 3},${wp.y - 2} L${wp.x + 3},${wp.y - 2} L${wp.x},${wp.y + 4} Z`;
        } else if (portEdge === 'bottom') {
          // Points UP (into unit)
          arrowPath = `M${wp.x - 3},${wp.y + 2} L${wp.x + 3},${wp.y + 2} L${wp.x},${wp.y - 4} Z`;
        } else if (portEdge === 'right') {
          // Points LEFT (into unit)
          arrowPath = `M${wp.x - 4},${wp.y} L${wp.x + 2},${wp.y - 3} L${wp.x + 2},${wp.y + 3} Z`;
        } else { // left
          // Points RIGHT (into unit)
          arrowPath = `M${wp.x + 4},${wp.y} L${wp.x - 2},${wp.y - 3} L${wp.x - 2},${wp.y + 3} Z`;
        }
        const arrow = svgEl('path', {
          d: arrowPath,
          fill: portVisuals.portColor,
          'pointer-events': 'none'
        });
        group.appendChild(arrow);
      }
    }

    g.appendChild(group);
  }
  
  svg.appendChild(g);
}

function render() {
  clearSVG();
  setViewBox();
  drawGrid();
  drawConnections();
  drawUnits();
}

/* =========================
   UNIT LIBRARY
   Displayed in right panel when "Add Unit" is clicked
   ========================= */
function showUnitLibrary() {
  propEditor.innerHTML = '';
  
  // Title
  const titleDiv = el('div', { 
    class: 'unitTitle', 
    style: 'cursor:default;',
    html: 'Add Unit' 
  });
  propEditor.appendChild(titleDiv);
  
  // Subtitle
  const subtitleDiv = el('div', { 
    class: 'unitSubtitle', 
    html: 'Drag a unit onto the canvas' 
  });
  propEditor.appendChild(subtitleDiv);
  
  // Organize units by category
  const byCategory = UnitRegistry.listByCategory();
  
  for (const [categoryName, units] of Object.entries(byCategory)) {
    // Category header
    const catHeader = el('div', {
      style: 'margin-top:16px; margin-bottom:8px; font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px; opacity:0.7;'
    });
    catHeader.textContent = categoryName;
    propEditor.appendChild(catHeader);
    
    // Units grid for this category
    const grid = el('div', { 
      class: 'unitLibraryGrid'
    });
    
    for (const def of units) {
      const card = document.createElement('div');
      card.className = 'unitLibraryCard';
      card.draggable = true;
      card.innerHTML = `
        <div class="name">
          <span class="swatch" style="background:${def.color}"></span>${def.name}
        </div>
        <div class="desc">${def.defId}</div>
      `;
      
      card.addEventListener('dragstart', (ev) => {
        ui.dragDefId = def.defId;
        ui.isHTML5Dragging = true;
        ev.dataTransfer.setData('text/plain', def.defId);
        ev.dataTransfer.effectAllowed = 'copy';
      });
      
      grid.appendChild(card);
    }
    
    propEditor.appendChild(grid);
  }
}

/* =========================
   MODELS PANEL
   ========================= */
function buildModelsPanel() {
  modelsPanelEl.innerHTML = '';
  
  function addDropdown(kind, label) {
    const row = document.createElement('div');
    row.className = 'row';
    
    const lab = document.createElement('label');
    lab.textContent = label;
    
    const sel = document.createElement('select');
    for (const m of models.list(kind)) {
      const opt = document.createElement('option');
      opt.value = m.id;
      opt.textContent = m.name;
      opt.title = m.desc || '';
      sel.appendChild(opt);
    }
    sel.value = models.active[kind];
    
    sel.addEventListener('change', () => {
      models.setActive(kind, sel.value);
      setStatus(`Model changed: ${label} â†’ ${sel.options[sel.selectedIndex].text}`);
      solveScene(scene);
      updatePropertiesPanel();
      render();
    });
    
    row.appendChild(lab);
    row.appendChild(sel);
    modelsPanelEl.appendChild(row);
  }
  
  addDropdown('pvt_gas', 'PVT gas');
  addDropdown('thermo', 'Thermo');
  addDropdown('water_psat', 'Psat(H2O)');
  addDropdown('humidity', 'Humidity/cond.');
  addDropdown('hx', 'Heat exchanger');
  addDropdown('pressure_drop', 'Î”P');
}

/* =========================
   PROPERTIES PANEL
   ========================= */
function el(tag, attrs = {}, children = []) {
  const e = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs)) {
    if (k === 'class') e.className = v;
    else if (k === 'html') e.innerHTML = v;
    else e.setAttribute(k, v);
  }
  for (const c of children) e.appendChild(c);
  return e;
}

function addNumberEditor(container, label, get, set, step = 0.1) {
  const row = el('div', { class: 'row' });
  row.appendChild(el('label', { html: label }));
  
  const inp = el('input', { type: 'number', step: String(step) });
  inp.value = String(get() ?? '');
  inp.addEventListener('input', () => { set(Number(inp.value)); });
  
  row.appendChild(inp);
  container.appendChild(row);
}

function addSelectEditor(container, label, get, set, options) {
  const row = el('div', { class: 'row' });
  row.appendChild(el('label', { html: label }));
  
  const sel = el('select', {});
  for (const [val, txt] of options) {
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = txt;
    sel.appendChild(opt);
  }
  sel.value = get();
  sel.addEventListener('change', () => {
    set(sel.value);
    updatePropertiesPanel();
  });
  
  row.appendChild(sel);
  container.appendChild(row);
}

function createCollapsibleSection(title, isOpen = true) {
  const section = el('div', { class: 'borderedSection' });
  
  const header = el('div', { class: 'sectionHeader' });
  header.innerHTML = `
    <span>${title}</span>
    <span class="sectionToggle ${isOpen ? '' : 'collapsed'}">â–¼</span>
  `;
  
  const content = el('div', { 
    class: `sectionContent ${isOpen ? '' : 'collapsed'}` 
  });
  
  header.addEventListener('click', () => {
    const toggle = header.querySelector('.sectionToggle');
    toggle.classList.toggle('collapsed');
    content.classList.toggle('collapsed');
  });
  
  section.appendChild(header);
  section.appendChild(content);
  
  return { section, content };
}

function createCollapsibleSubSection(title, isOpen = true) {
  const section = el('div', { class: 'subSection' });
  
  const header = el('div', { class: 'subSectionHeader' });
  header.innerHTML = `
    <span>${title}</span>
    <span class="subSectionToggle ${isOpen ? '' : 'collapsed'}">â–¼</span>
  `;
  
  const content = el('div', { 
    class: `subSectionContent ${isOpen ? '' : 'collapsed'}` 
  });
  
  header.addEventListener('click', () => {
    const toggle = header.querySelector('.subSectionToggle');
    toggle.classList.toggle('collapsed');
    content.classList.toggle('collapsed');
  });
  
  section.appendChild(header);
  section.appendChild(content);
  
  return { section, content };
}

function renderStreamProperties(container, s) {
  if (!s) {
    container.appendChild(el('div', { 
      class: 'small', 
      html: 'No data available' 
    }));
    return;
  }

  const propGrid = el('div', { class: 'propGrid' });
  
  if (s.type === StreamType.MATERIAL) {
    // Temperature
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Temperature' }),
      el('div', { 
        class: 'propValue', 
        html: `${s.T.toFixed(1)}<span class="propUnit">Â°C</span>` 
      })
    ]));
    
    // Pressure
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Pressure' }),
      el('div', { 
        class: 'propValue', 
        html: `${(s.P / 100000).toFixed(2)}<span class="propUnit">bar</span>` 
      })
    ]));
    
    // Flow rate
    if (s.phase === 'gas') {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Molar Flow' }),
        el('div', { 
          class: 'propValue', 
          html: `${s.nDot.toFixed(3)}<span class="propUnit">mol/s</span>` 
        })
      ]));
    } else if (s.phase === 'liquid') {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Mass Flow' }),
        el('div', { 
          class: 'propValue', 
          html: `${s.mDot.toFixed(4)}<span class="propUnit">kg/s</span>` 
        })
      ]));
    }
    
    // Composition
    const comp = s.comp || {};
    const keys = Object.keys(comp)
      .filter(k => comp[k] > 1e-6)
      .sort((a, b) => comp[b] - comp[a]);
      
    if (keys.length) {
      const compSection = el('div', { style: 'margin-top:12px;' });
      compSection.appendChild(el('div', { 
        class: 'propLabel', 
        html: 'Composition', 
        style: 'margin-bottom:6px;' 
      }));
      
      const compWrap = el('div', { style: 'display:flex; flex-wrap:wrap;' });
      for (const k of keys) {
        const frac = comp[k] || 0;
        const badge = el('div', { class: 'compBadge' });
        badge.innerHTML = `<span class="spec">${k}</span><span class="pct">${(100 * frac).toFixed(1)}%</span>`;
        compWrap.appendChild(badge);
      }
      compSection.appendChild(compWrap);
      propGrid.appendChild(compSection);
    }
  } else if (s.type === StreamType.ELECTRICAL || s.type === StreamType.HEAT) {
    // Power
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Power' }),
      el('div', { 
        class: 'propValue', 
        html: `${s.QkW.toFixed(1)}<span class="propUnit">kW</span>` 
      })
    ]));
    
    // Visual bar
    const bar = el('div', { class: 'bar', style: 'margin-top:8px;' });
    const fill = el('div', {});
    fill.style.width = `${clamp((s.QkW || 0) / 100, 0, 1) * 100}%`;
    bar.appendChild(fill);
    propGrid.appendChild(bar);
    propGrid.appendChild(el('div', { 
      class: 'kv', 
      style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
      html: `<span>0</span><span>100+ kW</span>` 
    }));
  } else if (s.type === StreamType.MECHANICAL) {
    // Work/Power
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Power' }),
      el('div', { 
        class: 'propValue', 
        html: `${(s.WkW || 0).toFixed(1)}<span class="propUnit">kW</span>` 
      })
    ]));
  }
  
  container.appendChild(propGrid);
}

function updatePropertiesPanel() {
  propEditor.innerHTML = '';
  
  // UNIT SELECTED
  if (ui.selectedUnitId) {
    const u = scene.units.get(ui.selectedUnitId);
    if (!u) {
      ui.selectedUnitId = null;
      return updatePropertiesPanel();
    }
    
    const def = UnitRegistry.get(u.defId);
    
    // Header (no border): Unit name + type + category
    const headerDiv = el('div', { class: 'unitHeader' });
    
    const titleDiv = el('div', { class: 'unitTitle' });
    const nameInput = el('input', { 
      type: 'text', 
      value: u.name || `${def.name} ${u.id.slice(-2)}` 
    });
    nameInput.addEventListener('input', () => {
      u.name = nameInput.value;
      // Update label on canvas immediately
      const label = svg.querySelector(`[data-unit-id="${u.id}"]`);
      if (label) label.textContent = u.name;
    });
    nameInput.addEventListener('blur', () => {
      if (!nameInput.value.trim()) {
        u.name = `${def.name} ${u.id.slice(-2)}`;
        nameInput.value = u.name;
      }
    });
    titleDiv.appendChild(nameInput);
    headerDiv.appendChild(titleDiv);
    
    const subtitleDiv = el('div', { 
      class: 'unitSubtitle', 
      html: `${def.defId} Â· <span style="color:${def.color}">${def.category}</span>` 
    });
    headerDiv.appendChild(subtitleDiv);
    
    propEditor.appendChild(headerDiv);

    // Bordered Section 1: Parameters
    const paramsSection = createCollapsibleSection('Parameters', true);
    
    if (u.defId === 'source_gas') {
      addSelectEditor(paramsSection.content, 'Species', 
        () => u.params.species, 
        v => u.params.species = v, 
        [['H2', 'Hâ‚‚'], ['O2', 'Oâ‚‚'], ['H2O', 'Hâ‚‚O(v)'], 
         ['N2', 'Nâ‚‚'], ['CO2', 'COâ‚‚'], ['Ar', 'Ar'], 
         ['CO', 'CO'], ['CH4', 'CHâ‚„']]
      );
      addNumberEditor(paramsSection.content, 'P (Pa)', 
        () => u.params.P, v => u.params.P = v, 1000);
      addNumberEditor(paramsSection.content, 'T (Â°C)', 
        () => u.params.T, v => u.params.T = v, 1);
      addNumberEditor(paramsSection.content, 'á¹… (mol/s)', 
        () => u.params.nDot, v => u.params.nDot = v, 0.1);
    }
    
    if (u.defId === 'source_power') {
      addNumberEditor(paramsSection.content, 'Power (kW)', 
        () => u.params.QkW, v => u.params.QkW = v, 1);
    }
    
    if (u.defId === 'hx_cop') {
      addNumberEditor(paramsSection.content, 'COP (-)', 
        () => u.params.COP, v => u.params.COP = v, 0.1);
      addNumberEditor(paramsSection.content, 'Tmin clamp (Â°C)', 
        () => u.params.TminClamp, v => u.params.TminClamp = v, 1);
    }
    
    propEditor.appendChild(paramsSection.section);

    // Bordered Section 2: Properties
    const ud = scene.runtime.unitData.get(u.id);
    const propsSection = createCollapsibleSection('Properties', true);

    if (!ud) {
      propsSection.content.appendChild(el('div', { 
        class: 'small', 
        style: 'padding: 8px 0; opacity:0.6;',
        html: 'Not computed yet â€” press Run' 
      }));
    } else {
      // Output ports
      for (const p of def.ports) {
        if (p.dir !== PortDir.OUT) continue;
        const s = ud.ports[p.portId];
        const portBox = el('div', { style: 'margin-bottom:12px;' });
        portBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:6px; opacity:0.8;', 
          html: `${p.portId}` 
        }));
        renderStreamProperties(portBox, s);
        propsSection.content.appendChild(portBox);
      }
      
      if (ud.errors?.length) {
        propsSection.content.appendChild(el('div', { 
          class: 'small', 
          style: 'color:#ef4444; margin-top:8px; padding:8px; background:#7f1d1d22; border-radius:8px;', 
          html: `âš  ${ud.errors.join('; ')}` 
        }));
      }
      
      // Subsection: Details (inside Properties, closed by default)
      if (ud.last && Object.keys(ud.last).length) {
        const detailsSubSection = createCollapsibleSubSection('Details', false);
        
        const dataGrid = el('div', { class: 'propGrid' });
        for (const [key, value] of Object.entries(ud.last)) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: key }),
            el('div', { 
              class: 'propValue', 
              style: 'font-size:12px;', 
              html: typeof value === 'number' ? value.toFixed(3) : String(value) 
            })
          ]));
        }
        detailsSubSection.content.appendChild(dataGrid);
        propsSection.content.appendChild(detailsSubSection.section);
      }
    }

    propEditor.appendChild(propsSection.section);
    return;
  }

  // STREAM SELECTED
  if (ui.selectedConnId) {
    const c = scene.connections.find(x => x.id === ui.selectedConnId);
    if (!c) {
      ui.selectedConnId = null;
      return updatePropertiesPanel();
    }
    
    const fromU = scene.units.get(c.from.unitId);
    const toU = scene.units.get(c.to.unitId);
    
    // Header (no border): Stream title
    const headerDiv = el('div', { class: 'unitHeader' });
    
    const titleDiv = el('div', { 
      class: 'unitTitle', 
      style: 'cursor:default;',
      html: 'Stream' 
    });
    headerDiv.appendChild(titleDiv);
    
    const subtitleDiv = el('div', { 
      class: 'unitSubtitle', 
      html: `${fromU?.name || '?'} â†’ ${toU?.name || '?'}` 
    });
    headerDiv.appendChild(subtitleDiv);
    
    propEditor.appendChild(headerDiv);
    
    // Bordered Section: Properties
    const propsSection = createCollapsibleSection('Properties', true);
    
    const fromUD = scene.runtime.unitData.get(c.from.unitId);
    const s = fromUD?.ports?.[c.from.portId] || null;
    renderStreamProperties(propsSection.content, s);
    
    propEditor.appendChild(propsSection.section);
    return;
  }

  // NOTHING SELECTED
  const emptyDiv = el('div', { 
    class: 'small', 
    style: 'padding:40px 20px; text-align:center; opacity:0.5;',
    html: 'Click a unit or stream to inspect' 
  });
  propEditor.appendChild(emptyDiv);
}

function describeSolve() {
  const ls = scene.runtime.lastSolve;
  if (!scene.units.size) return 'Empty scene.';
  
  let txt = ls.ok 
    ? `âœ… Converged in ${ls.iterations} iteration(s)\n` 
    : `âš  ${ls.warnings.join(' | ')}\n`;
  txt += `Units: ${scene.units.size} Â· Connections: ${scene.connections.length}\n`;
  txt += `Models: ` + Object.entries(models.active)
    .map(([k, v]) => `${k}:${v}`)
    .join(' Â· ');
  return txt;
}

/* =========================
   EVENT HANDLERS
   ========================= */
function deselectAll() {
  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  updatePropertiesPanel();
  render();
}

function rotateSelected() {
  if (!ui.selectedUnitId) return;
  scene.rotateUnit(ui.selectedUnitId);
  render();
  updatePropertiesPanel();
}

function deleteSelected() {
  if (ui.selectedUnitId) {
    scene.deleteUnit(ui.selectedUnitId);
    ui.selectedUnitId = null;
    updatePropertiesPanel();
    render();
  } else if (ui.selectedConnId) {
    // Delete stream
    scene.connections = scene.connections.filter(c => c.id !== ui.selectedConnId);
    ui.selectedConnId = null;
    updatePropertiesPanel();
    render();
  }
}

// SVG Events
svg.addEventListener('pointerdown', (ev) => {
  closeMenus();
  
  if (ev.shiftKey) {
    // Pan mode
    ui.isPanning = true;
    ui.panStart = { 
      x: ev.clientX, 
      y: ev.clientY, 
      view: { ...ui.view } 
    };
    svg.setPointerCapture(ev.pointerId);
    return;
  }

  const w = screenToWorld(ev.clientX, ev.clientY);
  const cell = worldToCell(w.x, w.y);
  const existing = scene.unitAt(cell.x, cell.y);
  
  if (!existing) {
    if (ui.pendingFrom) {
      ui.pendingFrom = null;
      setStatus('Connect cancelled.');
      
      render();
      return;
    }
    ui.selectedUnitId = null;
    ui.selectedConnId = null;
    
    updatePropertiesPanel();
    render();
  }
});

svg.addEventListener('pointermove', (ev) => {
  ui._mouseWorld = screenToWorld(ev.clientX, ev.clientY);

  // Panning
  if (ui.isPanning && ui.panStart) {
    const dx = ev.clientX - ui.panStart.x;
    const dy = ev.clientY - ui.panStart.y;
    const rect = svg.getBoundingClientRect();
    const wx = dx / rect.width * ui.panStart.view.w;
    const wy = dy / rect.height * ui.panStart.view.h;
    ui.view.x = ui.panStart.view.x - wx;
    ui.view.y = ui.panStart.view.y - wy;
    render();
    return;
  }

  // Unit dragging
  if (ui.isDraggingUnit && ui.dragUnitId && ui.dragOffset) {
    const u = scene.units.get(ui.dragUnitId);
    if (u) {
      const wpos = ui._mouseWorld;
      const cellX = (wpos.x / scene.tile) - ui.dragOffset.cellX;
      const cellY = (wpos.y / scene.tile) - ui.dragOffset.cellY;
      const nx = Math.round(cellX);
      const ny = Math.round(cellY);
      scene.moveUnit(u.id, nx, ny);
      render();
    }
    return;
  }

  // Redraw pending connection
  if (ui.pendingFrom) render();
});

svg.addEventListener('pointerup', () => {
  ui.isPanning = false;
  ui.panStart = null;

  if (ui.isDraggingUnit) {
    ui.isDraggingUnit = false;
    ui.dragUnitId = null;
    ui.dragOffset = null;
    
    updatePropertiesPanel();
    render();
  }
});

svg.addEventListener('wheel', (ev) => {
  ev.preventDefault();
  const z = (ev.deltaY < 0) ? 0.9 : 1.1;
  const m = screenToWorld(ev.clientX, ev.clientY);
  const v = ui.view;
  const newW = v.w * z;
  const newH = v.h * z;
  const rx = (m.x - v.x) / v.w;
  const ry = (m.y - v.y) / v.h;
  v.x = m.x - rx * newW;
  v.y = m.y - ry * newH;
  v.w = newW;
  v.h = newH;
  render();
}, { passive: false });

// Drag & drop from unit library
svg.addEventListener('dragover', (ev) => {
  ev.preventDefault();
  ev.dataTransfer.dropEffect = 'copy';
});

svg.addEventListener('dragleave', (ev) => {
  // Clear flag if drag leaves the canvas without dropping
  if (ev.target === svg) {
    ui.isHTML5Dragging = false;
  }
});

svg.addEventListener('drop', (ev) => {
  ev.preventDefault();
  const defId = ev.dataTransfer.getData('text/plain') || ui.dragDefId;
  if (!defId) return;
  
  const w = screenToWorld(ev.clientX, ev.clientY);
  const cell = worldToCell(w.x, w.y);
  const id = scene.placeUnit(defId, cell.x, cell.y);
  
  if (!id) {
    setStatus('Cannot place here (collision).');
    ui.dragDefId = null;
    ui.isHTML5Dragging = false;
    return;
  }
  
  ui.selectedUnitId = id;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  ui.dragDefId = null;
  ui.isHTML5Dragging = false;
  setStatus(`Placed: ${UnitRegistry.get(defId).name}`);
  
  updatePropertiesPanel();
  render();
});

// Keyboard shortcuts
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'Escape') {
    ui.pendingFrom = null;
    closeMenus();
    setStatus('Cancelled.');
    
    render();
  }
  if (ev.key.toLowerCase() === 'r') rotateSelected();
  if (ev.key === 'Delete' || ev.key === 'Backspace') deleteSelected();
});

/* =========================
   BUTTONS & MENUS
   ========================= */
btnRun.addEventListener('click', () => {
  solveScene(scene);
  setStatus(describeSolve());
  updatePropertiesPanel();
  render();
});

btnAdd.addEventListener('click', () => {
  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  showUnitLibrary();
  
  render();
});

// Status card toggle
btnMenu.addEventListener('click', (ev) => {
  ev.stopPropagation();
  menuFile.classList.remove('open');
  toggle(menuMain);
});

btnFile.addEventListener('click', (ev) => {
  ev.stopPropagation();
  menuMain.classList.remove('open');
  toggle(menuFile);
});

document.addEventListener('pointerdown', (ev) => {
  const t = ev.target;
  if (!(t.closest && (t.closest('.menuWrap') || t.closest('.menu')))) {
    closeMenus();
  }
});

document.getElementById('mToggleModels').addEventListener('click', () => {
  drawerModels.classList.toggle('open');
  closeMenus();
});

document.getElementById('mRotate').addEventListener('click', () => {
  rotateSelected();
  closeMenus();
});

document.getElementById('mDelete').addEventListener('click', () => {
  deleteSelected();
  closeMenus();
});

document.getElementById('mClear').addEventListener('click', () => {
  scene.importJSON(JSON.stringify({
    version: 7,
    grid: { w: 22, h: 14, tile: 48 },
    units: [],
    connections: [],
    modelsActive: models.active
  }));
  deselectAll();
  setStatus('Scene cleared.');
  closeMenus();
});

document.getElementById('mExport').addEventListener('click', () => {
  ioEl.value = scene.exportJSON();
  navigator.clipboard.writeText(ioEl.value)
    .then(() => {
      setStatus('Export copied to clipboard!');
    })
    .catch(() => {
      setStatus('Export: ' + ioEl.value);
    });
  closeMenus();
});

document.getElementById('mImport').addEventListener('click', () => {
  const jsonStr = prompt('Paste JSON data:');
  if (!jsonStr) return;
  
  try {
    scene.importJSON(jsonStr);
    buildModelsPanel();
    deselectAll();
    setStatus('Import OK.');
  } catch (e) {
    setStatus('Import failed: ' + e.message);
  }
  closeMenus();
});

/* =========================
   DEMO
   ========================= */
function loadDemo() {
  scene.importJSON(JSON.stringify({
    version: 7,
    grid: { w: 22, h: 14, tile: 48 },
    units: [
      { id: 'src-g-1', defId: 'source_gas', name: 'H2 Feed', x: 2, y: 4, rot: 0, 
        params: { species: 'H2', P: 200000, T: 80, nDot: 2.0 } },
      { id: 'src-p-1', defId: 'source_power', name: 'Compressor Power', x: 2, y: 2, rot: 0, 
        params: { QkW: 10 } },
      { id: 'hx-1', defId: 'hx_cop', name: 'Cooler', x: 6, y: 4, rot: 0, 
        params: { COP: 2.5, TminClamp: -50 } },
      { id: 'sink-1', defId: 'sink', name: 'Product', x: 11, y: 4, rot: 0, 
        params: {} },
    ],
    connections: [
      { id: 'c1', from: { unitId: 'src-g-1', portId: 'out' }, 
        to: { unitId: 'hx-1', portId: 'mat_in' } },
      { id: 'c2', from: { unitId: 'src-p-1', portId: 'out' }, 
        to: { unitId: 'hx-1', portId: 'power' } },
      { id: 'c3', from: { unitId: 'hx-1', portId: 'mat_out' }, 
        to: { unitId: 'sink-1', portId: 'mat_in' } },
    ],
    modelsActive: models.active
  }));

  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  solveScene(scene);
  setStatus(describeSolve() + "\nDemo loaded.");
  
  updatePropertiesPanel();
  render();
}

/* =========================
   INITIALIZATION
   ========================= */
buildModelsPanel();

// Initialize viewport and handle window resize
window.addEventListener('resize', () => {
  setViewBox();
  render();
});

setViewBox();

updatePropertiesPanel();
render();
loadDemo();
</script>
</body>
</html>
