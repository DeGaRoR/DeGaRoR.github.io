<!doctype html>
<!--
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  PROCESS GRID v3.1.0
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  A web-based process simulation and flowsheet design tool.
  
  ARCHITECTURE OVERVIEW:
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  1. COMPONENT SYSTEM
     - ComponentRegistry: Stores chemical components with physical properties
     - Properties: MW, Tc, Pc, Tb, Ï‰, Antoine coefficients
     - Components: H2O, O2, H2, N2, Ar, CH4
  
  2. MODEL REGISTRY
     - Extensible physics kernel system
     - Model types: pvt_gas, pvt_liquid, thermo, vle, flash, units
     - Active model selection persisted with scene
     - Unit systems: SI, SI (bar), Imperial
  
  3. STREAM TYPES
     - MATERIAL: T, P, n (molar flows), phase, vaporFraction
     - HEAT: QkW
     - MECHANICAL: WkW
     - ELECTRICAL: QkW
  
  4. UNIT OPERATIONS
     - Category-based organization with color coding
     - Extensible registry pattern
     - Current units: Source, Sink
     - Parameters automatically converted between unit systems
  
  5. THERMODYNAMICS
     - Flash calculations: TP flash with Rachford-Rice algorithm
     - VLE: Raoult's Law (ideal) with K-values
     - Antoine equation for vapor pressure
     - Phase constraints: V (vapor), L (liquid), VL (flash)
  
  6. SOLVER
     - Successive substitution with topological ordering
     - Automatic flash calculation on material streams
     - Stream type validation
     - Convergence checking
  
  7. UI ARCHITECTURE
     - Modal dialogs for Components, Models, Units
     - Grouped property display with unit conversions
     - Collapsible sections for organization
     - Real-time parameter updates with unit conversion
  
  8. DATA PERSISTENCE
     - JSON import/export
     - Active model settings saved with scene
     - Unit system preferences included
  
  INTERNAL UNITS (SI):
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - Temperature: K
  - Pressure: Pa
  - Molar flow: mol/s
  - Mass flow: kg/s
  - Volume flow: mÂ³/s
  
  All conversions handled transparently via unit system models.
  
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Process Grid â€” v3.1.0</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
      background: #0f1115; 
      color: #e7e7e7; 
      overflow: hidden; 
    }

    /* ===== LAYOUT ===== */
    .app { 
      height: 100vh; 
      display: grid; 
      grid-template-columns: 1fr 360px; 
    }
    
    .canvasWrap { 
      position: relative; 
    }
    
    #svg { 
      width: 100%; 
      height: 100%; 
      display: block;
      background: radial-gradient(1200px 700px at 40% 30%, #141a26 0%, #0f1115 55%, #0b0d12 100%);
      touch-action: none;
    }
    
    .rightPanel {
      border-left: 1px solid #2a2f3a;
      background: #0b0e14cc;
      backdrop-filter: blur(10px);
      overflow: auto;
      padding: 14px;
      display: flex;
      flex-direction: column;
    }
    
    .rightPanel h2 { 
      margin: 0 0 10px; 
      font-size: 14px; 
      letter-spacing: 0.3px; 
    }
    
    .card { 
      border: 1px solid #2a2f3a; 
      border-radius: 14px; 
      padding: 12px; 
      background: #0b0e14aa; 
    }
    
    .card + .card { 
      margin-top: 10px; 
    }

    /* ===== TOP BAR ===== */
    .topbar {
      position: absolute; 
      left: 10px; 
      top: 10px; 
      z-index: 5;
      display: flex; 
      gap: 10px; 
      align-items: center;
      background: #0b0e14cc; 
      border: 1px solid #2a2f3a; 
      border-radius: 14px; 
      padding: 8px 10px;
      backdrop-filter: blur(10px);
    }
    
    .btn {
      display: inline-flex; 
      align-items: center; 
      gap: 8px;
      background: #1c222e; 
      color: #e7e7e7; 
      border: 1px solid #2a2f3a;
      border-radius: 12px; 
      padding: 9px 12px; 
      cursor: pointer; 
      font-weight: 700;
      user-select: none;
    }
    
    .btn:hover { 
      border-color: #475068; 
    }
    
    .btn.primary { 
      background: #2563eb; 
      border-color: #2563eb; 
    }
    
    .btn.primary:hover { 
      filter: brightness(1.05); 
    }
    
    /* ===== STATUS INDICATOR ===== */
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      border: 2px solid;
      transition: all 0.3s ease;
    }
    
    .status-indicator.idle {
      background: #1e293b22;
      border-color: #475569;
      color: #94a3b8;
    }
    
    .status-indicator.running {
      background: #3b82f622;
      border-color: #3b82f6;
      color: #60a5fa;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .status-indicator.success {
      background: #22c55e22;
      border-color: #22c55e;
      color: #4ade80;
    }
    
    .status-indicator.warning {
      background: #fbbf2422;
      border-color: #fbbf24;
      color: #fbbf24;
    }
    
    .status-indicator.error {
      background: #f9731622;
      border-color: #f97316;
      color: #f97316;
    }
    
    .status-indicator.critical {
      background: #ef444422;
      border-color: #ef4444;
      color: #ef4444;
      animation: shake 0.5s ease-in-out;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    
    .status-icon {
      font-size: 16px;
      line-height: 1;
    }
    
    .status-text {
      white-space: nowrap;
    }
    
    .status-help {
      background: transparent;
      border: 1px solid currentColor;
      color: inherit;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      margin-left: 4px;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .status-help:hover {
      opacity: 1;
      background: currentColor;
      color: #0b0e14;
    }
    
    .pill { 
      padding: 2px 8px; 
      border-radius: 999px; 
      border: 1px solid #2a2f3a; 
      opacity: .9; 
      font-size: 12px; 
    }

    /* ===== MENUS ===== */
    .menuWrap { 
      position: relative; 
    }
    
    .menu {
      position: absolute; 
      top: 46px; 
      left: 0;
      min-width: 230px;
      background: #0b0e14f2;
      border: 1px solid #2a2f3a; 
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      padding: 8px;
      display: none;
      z-index: 10;
    }
    
    .menu.open { 
      display: block; 
    }
    
    .menu .item {
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    
    .menu .item:hover { 
      background: #1b2230; 
    }
    
    .menu .item .hint { 
      opacity: 0.75; 
      font-size: 12px; 
    }
    
    .menu .sep { 
      height: 1px; 
      background: #2a2f3a; 
      margin: 6px 4px; 
    }

    /* ===== MODELS DRAWER ===== */
    /* ===== MODALS ===== */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    
    .modal.open {
      display: flex;
    }
    
    .modalContent {
      background: #0b0e14;
      border: 1px solid #2a2f3a;
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      position: relative;
    }
    
    .modalContent h3 {
      margin: 0 0 8px 0;
      font-size: 18px;
      font-weight: 700;
    }
    
    .modalClose {
      position: absolute;
      top: 20px;
      right: 20px;
      background: transparent;
      border: none;
      color: #e7e7e7;
      font-size: 24px;
      cursor: pointer;
      opacity: 0.6;
      padding: 4px 8px;
      line-height: 1;
    }
    
    .modalClose:hover {
      opacity: 1;
    }

    /* ===== FORM CONTROLS ===== */
    .row { 
      display: grid; 
      grid-template-columns: 1fr 140px; 
      gap: 10px; 
      align-items: center; 
      margin: 10px 0; 
    }
    
    .row label { 
      font-size: 12px; 
      opacity: .9; 
    }
    
    /* Package selector cards */
    .pkg-card {
      border: 1px solid #2a2f3a;
      border-radius: 10px;
      padding: 10px 14px;
      margin: 6px 0;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
      display: grid;
      grid-template-columns: 24px 1fr;
      gap: 10px;
      align-items: start;
    }
    .pkg-card:hover { border-color: #4a90d9; background: #0d1520; }
    .pkg-card.active { border-color: #4a90d9; background: #0d1520; }
    .pkg-card .radio {
      width: 16px; height: 16px; border-radius: 50%;
      border: 2px solid #4a5568; margin-top: 2px;
      display: flex; align-items: center; justify-content: center;
    }
    .pkg-card.active .radio { border-color: #4a90d9; }
    .pkg-card.active .radio::after {
      content: ''; width: 8px; height: 8px;
      border-radius: 50%; background: #4a90d9;
    }
    .pkg-card .pkg-name { font-size: 13px; font-weight: 600; }
    .pkg-card .pkg-desc { font-size: 11px; opacity: 0.7; margin-top: 3px; line-height: 1.4; }
    .pkg-card .pkg-badge {
      display: inline-block; font-size: 9px; font-weight: 700; text-transform: uppercase;
      padding: 1px 6px; border-radius: 4px; margin-left: 6px; vertical-align: middle;
    }
    .pkg-badge.stable { background: #1a3a2a; color: #4ade80; }
    .pkg-badge.preview { background: #3a2a1a; color: #fbbf24; }
    .pkg-badge.experimental { background: #3a1a1a; color: #f87171; }
    
    .models-section { margin-top: 16px; }
    .models-section-title { 
      font-size: 11px; font-weight: 600; text-transform: uppercase; 
      letter-spacing: 0.5px; opacity: 0.5; margin-bottom: 8px; 
    }
    
    input, select, textarea {
      width: 100%; 
      background: #0b0e14; 
      color: #e7e7e7; 
      border: 1px solid #2a2f3a; 
      border-radius: 12px;
      padding: 8px 10px; 
      font-size: 12px;
    }
    
    .small { 
      font-size: 12px; 
      opacity: 0.85; 
      line-height: 1.35; 
    }
    
    .status { 
      white-space: pre-wrap; 
      font-size: 12px; 
      opacity: 0.9; 
    }

    /* ===== VISUALIZATIONS ===== */
    .bar { 
      height: 10px; 
      border: 1px solid #2a2f3a; 
      border-radius: 999px; 
      overflow: hidden; 
      background: #0b0e14; 
    }
    
    .bar > div { 
      height: 100%; 
      width: 0%; 
      background: #60a5fa; 
    }
    
    .kv { 
      display: flex; 
      justify-content: space-between; 
      font-size: 12px; 
      margin: 6px 0; 
      gap: 10px; 
    }
    
    .mono { 
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace; 
    }
    
    .swatch { 
      width: 10px; 
      height: 10px; 
      border-radius: 999px; 
      display: inline-block; 
      margin-right: 6px; 
      vertical-align: middle; 
    }

    /* ===== PROPERTIES PANEL ===== */
    .unitHeader {
      margin-bottom: 16px;
    }
    
    .unitTitle {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .unitTitle input {
      flex: 1;
      background: transparent;
      border: 1px solid transparent;
      padding: 4px 8px;
      font-size: 16px;
      font-weight: 700;
      color: #e7e7e7;
      border-radius: 6px;
    }
    
    .unitTitle input:hover {
      background: #1c222e;
      border-color: #2a2f3a;
    }
    
    .unitTitle input:focus {
      background: #1c222e;
      border-color: #60a5fa;
      outline: none;
    }
    
    .unitSubtitle {
      font-size: 12px;
      opacity: 0.6;
    }
    
    /* Bordered sections (Parameters, Properties) */
    .borderedSection {
      border: 1px solid #2a2f3a;
      border-radius: 12px;
      padding: 12px;
      background: transparent;
      margin-bottom: 10px;
    }
    
    .sectionHeader {
      font-size: 11px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
      margin-bottom: 12px;
      padding: 0;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .sectionHeader:hover {
      opacity: 1;
    }
    
    .sectionToggle {
      font-size: 10px;
      opacity: 0.5;
      transition: transform 0.2s;
    }
    
    .sectionToggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .sectionContent {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .sectionContent.collapsed {
      max-height: 0;
    }
    
    /* Subsections (Details inside Properties) */
    .subSection {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #2a2f3a;
    }
    
    .subSectionHeader {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.6;
      margin-bottom: 8px;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .subSectionHeader:hover {
      opacity: 0.8;
    }
    
    .subSectionToggle {
      font-size: 9px;
      opacity: 0.5;
      transition: transform 0.2s;
    }
    
    .subSectionToggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .subSectionContent {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .subSectionContent.collapsed {
      max-height: 0;
    }
    
    .propGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .propItem {
      background: #0f1420;
      border: 1px solid #2a2f3a;
      border-radius: 10px;
      padding: 8px 10px;
    }
    
    .propLabel {
      font-size: 10px;
      opacity: 0.7;
      margin-bottom: 2px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .propValue {
      font-size: 14px;
      font-weight: 700;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    
    .propUnit {
      font-size: 11px;
      opacity: 0.6;
      margin-left: 3px;
    }
    
    .compBadge {
      display: inline-block;
      background: #1c222e;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 11px;
      margin: 4px 4px 4px 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    
    .compBadge .spec { 
      font-weight: 700; 
    }
    
    .compBadge .pct { 
      opacity: 0.7; 
      margin-left: 4px; 
    }

    /* ===== CONTROLS SECTION ===== */
    .controlsSection {
      margin-top: auto;
      padding-top: 14px;
      border-top: 1px solid #2a2f3a;
    }
    
    .controlsGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 12px;
      font-size: 11px;
      line-height: 1.5;
    }
    
    .controlsGrid b {
      font-weight: 600;
      opacity: 0.9;
    }

    /* ===== UNIT LIBRARY IN RIGHT PANEL ===== */
    .unitLibraryGrid { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 10px; 
    }
    
    .unitLibraryCard {
      border: 1px solid #2a2f3a;
      border-radius: 12px;
      background: #0f1420;
      padding: 12px;
      cursor: grab;
      transition: all 0.2s;
      user-select: none;
    }
    
    .unitLibraryCard:active {
      cursor: grabbing;
    }
    
    .unitLibraryCard:hover {
      border-color: #475068;
      background: #1c222e;
    }
    
    .unitLibraryCard .name { 
      font-size: 12px; 
      font-weight: 800; 
      margin-bottom: 4px; 
    }
    
    .unitLibraryCard .desc { 
      font-size: 11px; 
      opacity: 0.75; 
      line-height: 1.2; 
    }
  </style>
</head>
<body>
<div class="app">
  <div class="canvasWrap">
    <!-- Top toolbar -->
    <div class="topbar">
      <button class="btn primary" id="btnRun">â–¶ Run</button>
      <button class="btn" id="btnAdd" style="background:#dc2626; border-color:#dc2626; color:#fff;">+ Add Unit</button>
      
      <!-- Status Indicator -->
      <div id="statusIndicator" class="status-indicator" style="display:none;">
        <div class="status-icon"></div>
        <div class="status-text"></div>
        <button class="status-help" title="Diagnosis">?</button>
      </div>

      <div class="menuWrap">
        <button class="btn" id="btnMenu">â˜° Menu</button>
        <div class="menu" id="menuMain">
          <div class="item" id="mComponents">Components <span class="hint">view</span></div>
          <div class="item" id="mModels">Models <span class="hint">packages</span></div>
          <div class="item" id="mUnits">Units <span class="hint">display</span></div>
          <div class="sep"></div>
          <div class="item" id="mLoadDemo">Load demo</div>
          <div class="item" id="mClear">Clear scene</div>
        </div>
      </div>

      <div class="menuWrap">
        <button class="btn" id="btnFile">ðŸ’¾ File</button>
        <div class="menu" id="menuFile">
          <div class="item" id="mExport">Export JSON</div>
          <div class="item" id="mImport">Import JSON</div>
        </div>
      </div>
    </div>

    <!-- Models modal -->
    <div class="modal" id="modalModels">
      <div class="modalContent">
        <button class="modalClose" onclick="document.getElementById('modalModels').classList.remove('open')">Ã—</button>
        <h3>Thermodynamic Models</h3>
        <div class="small">Select the property package and auxiliary models for calculations.</div>
        <div id="modelsPanel" style="margin-top:10px;"></div>
      </div>
    </div>

    <!-- Units modal -->
    <div class="modal" id="modalUnits">
      <div class="modalContent">
        <button class="modalClose" onclick="document.getElementById('modalUnits').classList.remove('open')">Ã—</button>
        <h3>Unit System</h3>
        <div class="small">Choose display units for all properties.</div>
        <div class="card" id="unitsPanel" style="margin-top:10px;"></div>
      </div>
    </div>

    <!-- Components modal -->
    <div class="modal" id="modalComponents">
      <div class="modalContent">
        <button class="modalClose" onclick="document.getElementById('modalComponents').classList.remove('open')">Ã—</button>
        <h3>Components</h3>
        <div class="small">Available chemical components in the simulation.</div>
        <div class="card" id="componentsPanel" style="margin-top:10px; max-height:60vh; overflow-y:auto;"></div>
      </div>
    </div>

    <!-- Main SVG canvas -->
    <svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-label="process grid">
      <defs>
        <!-- Material Source -->
        <symbol id="ico-source" viewBox="0 0 64 64">
          <circle cx="20" cy="32" r="10" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M32 32h22" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M46 24l8 8-8 8" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Sink -->
        <symbol id="ico-sink" viewBox="0 0 64 64">
          <path d="M12 18h40" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M18 18v26c0 8 6 14 14 14s14-6 14-14V18" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M26 30h12" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
        </symbol>
        
        <!-- Electrical Source (Lightning/Grid) -->
        <symbol id="ico-electrical" viewBox="0 0 64 64">
          <path d="M36 6 16 36h16l-4 22 20-30H32z" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Mechanical Source (Gear/Shaft) -->
        <symbol id="ico-mechanical" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="14" fill="none" stroke="currentColor" stroke-width="4"/>
          <circle cx="32" cy="32" r="6" fill="currentColor"/>
          <path d="M32 10v8M32 46v8M10 32h8M46 32h8M18 18l6 6M40 40l6 6M18 46l6-6M40 24l6-6" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
        </symbol>
        
        <!-- Motor (Circle with M) -->
        <symbol id="ico-motor" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="22" fill="none" stroke="currentColor" stroke-width="4"/>
          <text x="32" y="42" text-anchor="middle" font-size="32" font-weight="bold" fill="currentColor">M</text>
        </symbol>
        
        <!-- Pump (Triangle with impeller) -->
        <symbol id="ico-pump" viewBox="0 0 64 64">
          <path d="M10 16 L54 32 L10 48 Z" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
          <path d="M20 32 A8 8 0 0 1 28 24" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M20 32 A8 8 0 0 0 28 40" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M35 32 A6 6 0 0 1 41 26" fill="none" stroke="currentColor" stroke-width="2.5"/>
          <path d="M35 32 A6 6 0 0 0 41 38" fill="none" stroke="currentColor" stroke-width="2.5"/>
        </symbol>
        
        <!-- Compressor (Circle with turbine blades) -->
        <symbol id="ico-compressor" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="22" fill="none" stroke="currentColor" stroke-width="4"/>
          <!-- Turbine blades -->
          <path d="M32 10 L32 22 M32 54 L32 42 M10 32 L22 32 M54 32 L42 32" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M16 16 L24 24 M48 48 L40 40 M16 48 L24 40 M48 16 L40 24" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <circle cx="32" cy="32" r="8" fill="currentColor"/>
        </symbol>
        
        <!-- Valve (Bowtie) -->
        <symbol id="ico-valve" viewBox="0 0 64 64">
          <path d="M8 32 L32 12 L32 52 L8 32 Z" fill="currentColor" opacity="0.8"/>
          <path d="M56 32 L32 12 L32 52 L56 32 Z" fill="currentColor" opacity="0.8"/>
          <path d="M8 32 L32 12 L32 52 L8 32 Z M56 32 L32 12 L32 52 L56 32 Z" fill="none" stroke="currentColor" stroke-width="3" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Heat Exchanger -->
        <symbol id="ico-hx" viewBox="0 0 64 64">
          <path d="M10 20h44" stroke="currentColor" stroke-width="4"/>
          <path d="M10 44h44" stroke="currentColor" stroke-width="4"/>
          <path d="M16 20c8 8 8 16 0 24" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M48 20c-8 8-8 16 0 24" fill="none" stroke="currentColor" stroke-width="4"/>
          <path d="M32 6v12" stroke="currentColor" stroke-width="4"/>
          <path d="M26 14h12" stroke="currentColor" stroke-width="4"/>
        </symbol>
        
        <!-- Single Stream Heater -->
        <symbol id="ico-heater" viewBox="0 0 64 64">
          <rect x="14" y="20" width="36" height="24" fill="none" stroke="currentColor" stroke-width="4" rx="4"/>
          <path d="M20 32 Q26 26, 32 32 T44 32" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M32 6 L32 20" stroke="currentColor" stroke-width="4"/>
          <path d="M26 10 L32 6 L38 10" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Electric Heater (circle with H, like motor with M) -->
        <symbol id="ico-electric_heater" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="22" fill="none" stroke="currentColor" stroke-width="4"/>
          <text x="32" y="42" text-anchor="middle" font-size="32" font-weight="bold" fill="currentColor">H</text>
        </symbol>
        
        <!-- Two-Stream Heat Exchanger -->
        <symbol id="ico-hex" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="20" fill="none" stroke="currentColor" stroke-width="4"/>
          <!-- Hot stream (vertical) -->
          <path d="M20 8 L20 24" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M20 40 L20 56" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Cold stream (vertical) -->
          <path d="M44 56 L44 40" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M44 24 L44 8" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Arrows -->
          <path d="M16 20 L20 24 L24 20" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M40 12 L44 8 L48 12" fill="none" stroke="currentColor" stroke-width="3"/>
        </symbol>
        
        <!-- Mixer (two-to-one merge) -->
        <symbol id="ico-mixer" viewBox="0 0 64 64">
          <!-- Two inlets converging to one outlet -->
          <path d="M8 16 L32 32 L8 48" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
          <path d="M32 32 L56 32" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Arrow on outlet -->
          <path d="M48 26 L56 32 L48 38" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
        </symbol>
        
        <!-- Splitter (one-to-two diverge) -->
        <symbol id="ico-flash_drum" viewBox="0 0 64 96">
          <!-- Vertical drum vessel -->
          <rect x="16" y="8" width="32" height="80" rx="16" ry="16" fill="none" stroke="currentColor" stroke-width="3"/>
          <!-- Liquid level line -->
          <line x1="18" y1="56" x2="46" y2="56" stroke="currentColor" stroke-width="2" stroke-dasharray="4 3" opacity="0.6"/>
          <!-- V label (top half) -->
          <text x="32" y="38" text-anchor="middle" font-size="16" font-weight="700" fill="currentColor" opacity="0.7">V</text>
          <!-- L label (bottom half) -->
          <text x="32" y="74" text-anchor="middle" font-size="16" font-weight="700" fill="currentColor" opacity="0.7">L</text>
        </symbol>
        
        <symbol id="ico-splitter" viewBox="0 0 64 64">
          <!-- Single inlet to two outlets -->
          <path d="M8 32 L32 32" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M32 32 L56 16" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <path d="M32 32 L56 48" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          <!-- Arrows on outlets -->
          <path d="M48 10 L56 16 L48 22" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
          <path d="M48 42 L56 48 L48 54" fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round" stroke-linecap="round"/>
        </symbol>
        
        <!-- Generic pipe/flow (fallback) -->
        <symbol id="ico-pipe" viewBox="0 0 64 64">
          <path d="M10 32h44" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
          <path d="M42 24l12 8-12 8" fill="none" stroke="currentColor" stroke-width="6" stroke-linejoin="round"/>
        </symbol>
        
        <!-- Battery (electrical energy storage) -->
        <symbol id="ico-battery" viewBox="0 0 64 64">
          <rect x="10" y="18" width="36" height="28" rx="3" fill="none" stroke="currentColor" stroke-width="3"/>
          <rect x="46" y="26" width="6" height="12" rx="1" fill="currentColor"/>
          <rect x="16" y="24" width="8" height="16" fill="currentColor" opacity="0.8"/>
          <rect x="27" y="24" width="8" height="16" fill="currentColor" opacity="0.5"/>
        </symbol>
        
        <!-- Power Hub (electrical bus/distribution) -->
        <symbol id="ico-power_hub" viewBox="0 0 64 96">
          <rect x="12" y="20" width="40" height="56" rx="6" fill="none" stroke="currentColor" stroke-width="3"/>
          <!-- Lightning bolt -->
          <path d="M36 34 L28 50 L35 50 L29 66" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          <!-- Bus bars -->
          <line x1="18" y1="38" x2="46" y2="38" stroke="currentColor" stroke-width="2" opacity="0.5"/>
          <line x1="18" y1="58" x2="46" y2="58" stroke="currentColor" stroke-width="2" opacity="0.5"/>
        </symbol>
        
        <!-- Electrical Sink (load/ground) -->
        <symbol id="ico-sink_electrical" viewBox="0 0 64 64">
          <circle cx="32" cy="28" r="14" fill="none" stroke="currentColor" stroke-width="3"/>
          <path d="M25 28 L39 28" stroke="currentColor" stroke-width="3"/>
          <path d="M32 21 L32 35" stroke="currentColor" stroke-width="3"/>
          <!-- Ground symbol -->
          <line x1="22" y1="48" x2="42" y2="48" stroke="currentColor" stroke-width="3"/>
          <line x1="26" y1="52" x2="38" y2="52" stroke="currentColor" stroke-width="2.5"/>
          <line x1="30" y1="56" x2="34" y2="56" stroke="currentColor" stroke-width="2"/>
        </symbol>
      </defs>
    </svg>
  </div>

  <!-- Right panel for properties and unit library -->
  <aside class="rightPanel">
    <div class="card" id="propEditor"></div>

    <!-- Controls section at bottom -->
    <div class="controlsSection">
      <div class="controlsGrid">
        <div><b>Pan:</b> Middle mouse / Shift + drag</div>
        <div><b>Zoom:</b> Mouse wheel</div>
        <div><b>Rotate:</b> R key</div>
        <div><b>Delete:</b> Del key</div>
      </div>
    </div>
  </aside>

  <!-- Hidden textarea for import/export operations -->
  <textarea id="io" style="display:none;"></textarea>
</div>

<script>
"use strict";

/* =========================
   CONSTANTS & ENUMS
   ========================= */
const PortDir = { IN: 0, OUT: 1 };
const StreamType = { 
  MATERIAL: 0,  // Grey
  HEAT: 1,      // Yellow/orange
  MECHANICAL: 2, // Purple
  ELECTRICAL: 3  // Green
};

// Stream visual properties
const StreamVisuals = {
  [StreamType.MATERIAL]: { 
    color: '#94a3b8', 
    portColor: '#94a3b8' 
  },
  [StreamType.HEAT]: { 
    color: '#fbbf24', 
    portColor: '#fbbf24' 
  },
  [StreamType.MECHANICAL]: { 
    color: '#a855f7', 
    portColor: '#a855f7' 
  },
  [StreamType.ELECTRICAL]: { 
    color: '#22c55e', 
    portColor: '#22c55e' 
  }
};

/* =========================
   COMPONENT REGISTRY
   Chemical components with physical properties
   ========================= */
class ComponentRegistry {
  static _components = new Map();

  static register(formula, spec) {
    const comp = {
      // Identification
      formula,                    // Chemical formula (e.g., 'H2O')
      name: spec.name,           // Common name (e.g., 'Water')
      CAS: spec.CAS || null,     // CAS registry number
      
      // Basic properties
      MW: spec.MW,               // Molecular weight (g/mol)
      
      // Critical properties (for Peng-Robinson EOS)
      Tc: spec.Tc,               // Critical temperature (K)
      Pc: spec.Pc,               // Critical pressure (Pa)
      omega: spec.omega || 0,    // Acentric factor (dimensionless)
      Vc: spec.Vc || null,       // Critical volume (mÂ³/mol) - optional
      Zc: spec.Zc || null,       // Critical compressibility factor - optional
      
      // Phase transition properties
      Tb: spec.Tb,               // Normal boiling point at 1 atm (K)
      Tm: spec.Tm || null,       // Melting point at 1 atm (K) - optional
      Hv: spec.Hv || null,       // Heat of vaporization at Tb (J/mol) - optional
      Hf: spec.Hf || null,       // Heat of fusion at Tm (J/mol) - optional
      
      // Vapor pressure correlation (Antoine equation)
      // log10(Psat[mmHg]) = A - B/(C + T[Â°C])
      // Will be converted to Pa in calculations
      antoine: spec.antoine || null,  // {A, B, C, Tmin, Tmax}
      
      // Ideal gas heat capacity correlation (polynomial)
      // Cp_ig = A + B*T + C*TÂ² + D*TÂ³ + E*Tâ´  [J/(molÂ·K)]
      // T in Kelvin
      cpig: spec.cpig || null,   // {A, B, C, D, E, Tmin, Tmax}
      
      // Liquid heat capacity (constant or temperature-dependent)
      cpLiq: spec.cpLiq || null,  // J/(molÂ·K) or {A, B, C} for Cp = A + B*T + C*TÂ²
      
      // Liquid density correlation (Rackett or polynomial)
      densityLiq: spec.densityLiq || null,  // {method, params}
      
      // Liquid density constant (kg/mÂ³ at reference conditions)
      // Simple constant approximation; used by ThermoAdapter.density()
      rhoLiq: spec.rhoLiq || null,
      
      // Safety and environmental
      flashPoint: spec.flashPoint || null,    // K
      autoIgnition: spec.autoIgnition || null, // K
      LEL: spec.LEL || null,                   // Lower explosive limit (vol%)
      UEL: spec.UEL || null,                   // Upper explosive limit (vol%)
      
      // Additional metadata
      phase298: spec.phase298 || 'unknown',    // Phase at 298K, 1 atm ('gas', 'liquid', 'solid')
      molecular: spec.molecular || null        // Molecular structure info (optional)
    };
    this._components.set(formula, comp);
  }

  static get(formula) {
    return this._components.get(formula);
  }

  static list() {
    return Array.from(this._components.values());
  }

  static exists(formula) {
    return this._components.has(formula);
  }
  
  static getPropertyNames() {
    // Return list of all possible property names for display
    return [
      { key: 'formula', name: 'Formula', unit: '' },
      { key: 'name', name: 'Name', unit: '' },
      { key: 'CAS', name: 'CAS Number', unit: '' },
      { key: 'MW', name: 'Molecular Weight', unit: 'g/mol' },
      { key: 'Tc', name: 'Critical Temperature', unit: 'K' },
      { key: 'Pc', name: 'Critical Pressure', unit: 'Pa' },
      { key: 'omega', name: 'Acentric Factor', unit: '-' },
      { key: 'Tb', name: 'Normal Boiling Point', unit: 'K' },
      { key: 'phase298', name: 'Phase at 298K', unit: '' },
      { key: 'antoine', name: 'Antoine Coefficients', unit: '{A, B, C}' },
      { key: 'cpig', name: 'Ideal Gas Cp', unit: 'J/(molÂ·K)' },
      { key: 'cpLiq', name: 'Liquid Cp', unit: 'J/(molÂ·K)' }
    ];
  }
  
  static validate(formula) {
    // Validate that component has all required properties for energy balance
    const comp = this.get(formula);
    if (!comp) return { valid: false, errors: ['Component not found'] };
    
    const errors = [];
    const warnings = [];
    
    // Required for ALL components
    if (!comp.MW) errors.push('Missing molecular weight (MW)');
    if (!comp.Tc) errors.push('Missing critical temperature (Tc)');
    if (!comp.Pc) errors.push('Missing critical pressure (Pc)');
    if (comp.omega === undefined) errors.push('Missing acentric factor (omega)');
    if (!comp.Tb) errors.push('Missing boiling point (Tb)');
    if (!comp.phase298) errors.push('Missing phase at 298K');
    
    // Required for vapor pressure calculations
    if (!comp.antoine) {
      errors.push('Missing Antoine coefficients');
    } else {
      // Support both single-range and multi-range Antoine
      if (Array.isArray(comp.antoine)) {
        // Multi-range: validate each range
        if (comp.antoine.length === 0) {
          errors.push('Antoine: Empty array (need at least one range)');
        } else {
          comp.antoine.forEach((range, idx) => {
            const prefix = `Antoine[${idx}]`;
            if (!range.A && range.A !== 0) errors.push(`${prefix}: Missing coefficient A`);
            if (!range.B && range.B !== 0) errors.push(`${prefix}: Missing coefficient B`);
            if (!range.C && range.C !== 0) errors.push(`${prefix}: Missing coefficient C`);
            if (!range.Tmin) errors.push(`${prefix}: Missing Tmin (required for multi-range)`);
            if (!range.Tmax) errors.push(`${prefix}: Missing Tmax (required for multi-range)`);
            
            // Validate range ordering
            if (range.Tmin && range.Tmax && range.Tmin >= range.Tmax) {
              errors.push(`${prefix}: Tmin (${range.Tmin}K) must be less than Tmax (${range.Tmax}K)`);
            }
          });
          
          // Check for overlaps and ordering (warnings, not errors)
          for (let i = 0; i < comp.antoine.length - 1; i++) {
            const curr = comp.antoine[i];
            const next = comp.antoine[i + 1];
            
            if (curr.Tmax && next.Tmin && curr.Tmax < next.Tmin) {
              // Gap between ranges - this is OK but worth noting
              warnings.push(`Antoine: Gap between range ${i} (${curr.Tmax}K) and range ${i+1} (${next.Tmin}K)`);
            } else if (curr.Tmax && next.Tmin && curr.Tmax > next.Tmin) {
              // Overlap - warn but allow (some overlap is intentional for smooth transition)
              const overlap = curr.Tmax - next.Tmin;
              if (overlap > 10) {  // Only warn if overlap > 10K
                warnings.push(`Antoine: Large overlap (${overlap.toFixed(0)}K) between range ${i} and ${i+1}`);
              }
            }
          }
        }
      } else {
        // Single-range: validate object
        if (!comp.antoine.A && comp.antoine.A !== 0) errors.push('Antoine: Missing coefficient A');
        if (!comp.antoine.B && comp.antoine.B !== 0) errors.push('Antoine: Missing coefficient B');
        if (!comp.antoine.C && comp.antoine.C !== 0) errors.push('Antoine: Missing coefficient C');
        if (!comp.antoine.Tmin) warnings.push('Antoine: Missing Tmin (range not validated)');
        if (!comp.antoine.Tmax) warnings.push('Antoine: Missing Tmax (range not validated)');
      }
    }
    
    // Required for energy balance (heat capacity)
    if (!comp.cpig) {
      errors.push('Missing ideal gas heat capacity correlation (cpig)');
    } else {
      if (comp.cpig.A === undefined) errors.push('cpig: Missing coefficient A');
      if (comp.cpig.B === undefined) errors.push('cpig: Missing coefficient B');
      if (comp.cpig.C === undefined) errors.push('cpig: Missing coefficient C');
      if (comp.cpig.D === undefined) errors.push('cpig: Missing coefficient D');
      if (!comp.cpig.Tmin) warnings.push('cpig: Missing Tmin (range not validated)');
      if (!comp.cpig.Tmax) warnings.push('cpig: Missing Tmax (range not validated)');
    }
    
    // Required for liquid phase energy balance
    if (!comp.cpLiq) {
      errors.push('Missing liquid heat capacity (cpLiq) - required for liquid phase calculations');
    }
    
    // Recommended for Peng-Robinson EOS
    if (!comp.Vc) warnings.push('Missing critical volume (Vc) - recommended for PR EOS');
    if (!comp.Zc) warnings.push('Missing critical compressibility (Zc)');
    
    // Recommended for phase change calculations
    if (!comp.Tm) warnings.push('Missing melting point (Tm)');
    if (!comp.Hv) warnings.push('Missing heat of vaporization (Hv)');
    
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }
  
  static validateAll() {
    // Validate all registered components
    const results = {};
    for (const comp of this.list()) {
      results[comp.formula] = this.validate(comp.formula);
    }
    return results;
  }
}

// Register initial components with COMPLETE, STANDARDIZED property sets
// All components must have: MW, Tc, Pc, omega, Tb, phase298, antoine, cpig, cpLiq
// Ideal gas Cp correlation: Cp_ig = A + B*T + C*TÂ² + D*TÂ³ + E*Tâ´  [J/(molÂ·K)]
// Liquid Cp: Approximately constant (liquids have much lower temperature dependence than gases)
// Valid for temperatures in [Tmin, Tmax]

ComponentRegistry.register('H2O', {
  name: 'Water',
  CAS: '7732-18-5',
  MW: 18.015,
  Tc: 647.1,
  Pc: 22064000,
  omega: 0.344,
  Vc: 0.0000559,
  Zc: 0.229,
  Tb: 373.15,
  Tm: 273.15,
  Hv: 40660,
  phase298: 'liquid',
  // Multiple Antoine ranges for extended temperature coverage
  antoine: [
    { A: 8.07131, B: 1730.63, C: 233.426, Tmin: 274, Tmax: 373, desc: 'Low temp range (1-100Â°C)' },
    { A: 8.14019, B: 1810.94, C: 244.485, Tmin: 372, Tmax: 647, desc: 'High temp range (99-374Â°C)' }
  ],
  // NIST WebBook correlation
  cpig: { A: 33.933, B: -0.008418, C: 2.9906e-5, D: -1.7825e-8, E: 3.6934e-12, Tmin: 273, Tmax: 1500 },
  cpLiq: 75.3,  // J/(molÂ·K) at 298K - approximately constant for liquid water
  rhoLiq: 1000  // kg/mÂ³ at 298K (liquid density at reference conditions)
});

ComponentRegistry.register('O2', {
  name: 'Oxygen',
  CAS: '7782-44-7',
  MW: 31.999,
  Tc: 154.6,
  Pc: 5043000,
  omega: 0.022,
  Vc: 0.0000734,
  Zc: 0.288,
  Tb: 90.2,
  Tm: 54.4,
  Hv: 6820,
  phase298: 'gas',
  antoine: { A: 6.69147, B: 319.013, C: 266.7, Tmin: 60, Tmax: 154 },
  // NIST WebBook - Shomate equation converted to polynomial
  cpig: { A: 29.659, B: -0.0085178, C: 2.3968e-5, D: -2.0269e-8, E: 6.6185e-12, Tmin: 100, Tmax: 2000 },
  cpLiq: 52.8,  // J/(molÂ·K) for liquid O2 near Tb (NIST)
  rhoLiq: 1141  // kg/mÂ³ (liquid O2 at NBP)
});

ComponentRegistry.register('H2', {
  name: 'Hydrogen',
  CAS: '1333-74-0',
  MW: 2.016,
  Tc: 33.2,
  Pc: 1297000,
  omega: -0.216,
  Vc: 0.0000641,
  Zc: 0.303,
  Tb: 20.4,
  Tm: 13.8,
  Hv: 904,
  phase298: 'gas',
  antoine: { A: 5.00395, B: 56.0, C: 258.0, Tmin: 14, Tmax: 33 },
  // NIST WebBook
  cpig: { A: 29.088, B: -0.0019226, C: 4.0002e-6, D: -8.7047e-10, E: 1.0227e-13, Tmin: 298, Tmax: 1000 },
  cpLiq: 28.8,  // J/(molÂ·K) for liquid H2 (20K, NIST)
  rhoLiq: 71    // kg/mÂ³ (liquid H2 at NBP)
});

ComponentRegistry.register('N2', {
  name: 'Nitrogen',
  CAS: '7727-37-9',
  MW: 28.014,
  Tc: 126.2,
  Pc: 3396000,
  omega: 0.037,
  Vc: 0.0000901,
  Zc: 0.289,
  Tb: 77.4,
  Tm: 63.1,
  Hv: 5577,
  phase298: 'gas',
  antoine: { A: 6.49457, B: 255.68, C: 266.55, Tmin: 63, Tmax: 126 },
  // NIST WebBook
  cpig: { A: 29.124, B: -0.0033536, C: 1.0735e-5, D: -9.5806e-9, E: 2.8861e-12, Tmin: 100, Tmax: 2000 },
  cpLiq: 54.4,  // J/(molÂ·K) for liquid N2 at 77K (NIST)
  rhoLiq: 807   // kg/mÂ³ (liquid N2 at NBP)
});

ComponentRegistry.register('Ar', {
  name: 'Argon',
  CAS: '7440-37-1',
  MW: 39.948,
  Tc: 150.9,
  Pc: 4898000,
  omega: -0.002,
  Vc: 0.0000749,
  Zc: 0.291,
  Tb: 87.3,
  Tm: 83.8,
  Hv: 6447,
  phase298: 'gas',
  antoine: { A: 6.61562, B: 304.226, C: 267.31, Tmin: 84, Tmax: 151 },
  // Monoatomic gas: Cp = 5/2 R (constant)
  cpig: { A: 20.786, B: 0, C: 0, D: 0, E: 0, Tmin: 100, Tmax: 5000 },
  cpLiq: 42.1,  // J/(molÂ·K) for liquid Ar at 87K (NIST)
  rhoLiq: 1394  // kg/mÂ³ (liquid Ar at NBP)
});

ComponentRegistry.register('CH4', {
  name: 'Methane',
  CAS: '74-82-8',
  MW: 16.043,
  Tc: 190.6,
  Pc: 4599000,
  omega: 0.011,
  Vc: 0.0000986,
  Zc: 0.286,
  Tb: 111.7,
  Tm: 90.7,
  Hv: 8180,
  phase298: 'gas',
  antoine: { A: 6.61184, B: 389.93, C: 266.0, Tmin: 91, Tmax: 191 },
  // NIST WebBook
  cpig: { A: 34.942, B: -0.039957, C: 1.9184e-4, D: -1.5303e-7, E: 3.9321e-11, Tmin: 298, Tmax: 1500 },
  cpLiq: 52.6,  // J/(molÂ·K) for liquid CH4 at 111K (NIST)
  rhoLiq: 423   // kg/mÂ³ (liquid CH4 at NBP)
});

ComponentRegistry.register('He', {
  name: 'Helium',
  CAS: '7440-59-7',
  MW: 4.003,
  Tc: 5.19,
  Pc: 227000,
  omega: -0.390,
  Vc: 0.0000574,
  Zc: 0.301,
  Tb: 4.22,
  Tm: 0.95,  // At 2.5 MPa (no solid at 1 atm)
  Hv: 84,    // Very low heat of vaporization
  phase298: 'gas',
  // Antoine coefficients for helium (low temperature range)
  antoine: { A: 3.75830, B: 2.29551, C: 0.50, Tmin: 2, Tmax: 5 },
  // NIST: Monatomic gas, constant Cp
  cpig: { A: 20.786, B: 0.0, C: 0.0, D: 0.0, E: 0.0, Tmin: 100, Tmax: 2000 },
  cpLiq: 4.5,  // J/(molÂ·K) for liquid helium (very low)
  rhoLiq: 125  // kg/mÂ³ (liquid He at NBP)
});

ComponentRegistry.register('CO2', {
  name: 'Carbon Dioxide',
  CAS: '124-38-9',
  MW: 44.010,
  Tc: 304.1,
  Pc: 7377000,
  omega: 0.228,
  Vc: 0.0000940,
  Zc: 0.274,
  Tb: 194.7,  // Sublimation point at 1 atm
  Tm: 216.6,
  Hv: 15326,  // Sublimation enthalpy
  phase298: 'gas',
  // Antoine for solid-vapor equilibrium (sublimation)
  antoine: { A: 9.8106, B: 1347.8, C: 273.0, Tmin: 154, Tmax: 196 },
  // NIST WebBook
  cpig: { A: 29.370, B: 0.034540, C: -2.0662e-5, D: 3.9969e-9, E: 2.9882e-14, Tmin: 298, Tmax: 1500 },
  cpLiq: 85.5,  // J/(molÂ·K) for liquid CO2 at 250K (NIST) - liquid exists above 5.2 bar
  rhoLiq: 1101  // kg/mÂ³ (liquid CO2 at ~250K, 10 bar)
});

/* =========================
   UTILITY FUNCTIONS
   ========================= */
function clamp(v, min, max) { 
  return Math.max(min, Math.min(max, v)); 
}

function compToString(comp) {
  if (!comp) return '';
  const arr = Object.entries(comp)
    .filter(([, f]) => f > 1e-6)
    .map(([s, f]) => `${s}:${(f * 100).toFixed(1)}%`);
  return arr.join(' ');
}

function formatStream(s) {
  if (!s) return 'â€”';
  if (s.type === StreamType.ELECTRICAL) 
    return `âš¡ ${((s.available || 0)/1000).toFixed(1)} kW`;
  if (s.type === StreamType.HEAT) 
    return `ðŸ”¥ ${((s.available || 0)/1000).toFixed(1)} kW`;
  if (s.type === StreamType.MECHANICAL) 
    return `âš™ ${((s.available || 0)/1000).toFixed(1)} kW`;
  if (s.type === StreamType.MATERIAL) {
    // Internal phase encoding: 'V', 'L', 'VL'
    const phaseDisplay = s.phase === 'V' ? 'Vapor' : 
                         s.phase === 'L' ? 'Liquid' : 
                         s.phase === 'VL' ? 'Two-Phase' : 'Unknown';
    const T_display = s.T ? (s.T - 273.15).toFixed(1) : '?';
    const P_display = s.P ? (s.P / 100000).toFixed(2) : '?';
    return `${phaseDisplay} T=${T_display}Â°C P=${P_display} bar`;
  }
  return JSON.stringify(s);
}

// Validation: Ensure stream type matches port type
function validateStreamType(stream, portType) {
  if (!stream) return false;
  if (stream.type !== portType) {
    console.error(`Stream type mismatch: stream.type=${stream.type}, portType=${portType}`);
    return false;
  }
  return true;
}

/* =========================
   MODEL REGISTRY
   Physics kernels for thermodynamics, PVT, etc.
   ========================= */
class ModelRegistry {
  constructor() {
    this.catalog = {
      // LEGACY CATEGORIES REMOVED (violated architecture):
      // - pvt_gas: Mixed units (T+273.15), bypassed ComponentRegistry
      // - pvt_liquid: Hardcoded densities, bypassed ComponentRegistry  
      // - water_psat: Water-specific, Â°C units, bypassed ThermoAdapter
      // - humidity: Water-specific, bypassed ThermoAdapter
      // - vle: Direct antoine access (breaks multi-range), bypassed ThermoAdapter
      // - flash: Complex dependencies, ThermoAdapter has better implementation
      
      // KEPT (safe):
      thermo_package: new Map(),    // Thermodynamic property packages
      reaction: new Map(),          // Chemical reactions (future)
      hx: new Map(),                // Heat exchanger models (COP, etc)
      pressure_drop: new Map(),     // Pressure drop correlations
      units: new Map(),             // Unit system for display (UI only)
    };
    this.active = {
      thermo_package: null,
      reaction: null,
      hx: null,
      pressure_drop: null,
      units: null,
    };
  }

  register(kind, model) {
    if (!this.catalog[kind]) throw new Error(`Unknown model kind: ${kind}`);
    if (!model?.id) throw new Error("Model must have id");
    this.catalog[kind].set(model.id, model);
    if (!this.active[kind]) this.active[kind] = model.id;
  }

  get(kind, id) {
    const m = this.catalog[kind];
    if (!m) return null;
    return m.get(id) || null;
  }

  list(kind) {
    const m = this.catalog[kind];
    if (!m) return [];
    return Array.from(m.values());
  }

  setActive(kind, id) {
    // Validate that the model exists before activating
    const model = this.get(kind, id);
    if (!model) {
      console.warn(`ModelRegistry.setActive: Model '${id}' not found for kind '${kind}'. Active model unchanged.`);
      return false;
    }
    
    this.active[kind] = id;
    return true;
  }

  getActive(kind) {
    return this.get(kind, this.active[kind]);
  }
}

const models = new ModelRegistry();

/* =========================
   THERMO MODEL INTERFACE
   Single entry point for ALL thermodynamic calculations
   
   INTERNAL CONVENTION:
   - All temperatures in Kelvin (K)
   - All pressures in Pascal (Pa)
   - UI conversions happen ONLY at display/edit boundaries
   
   REFERENCE STATES:
   - Enthalpy: Ideal gas at 298.15 K, 101325 Pa
   - Entropy: (not yet implemented)
   ========================= */

/**
 * @typedef {Object} FlashResult - Canonical result type for ALL flash calculations
 * 
 * MANDATORY FIELDS (always present on every return path):
 * @property {string} phase       - 'V', 'L', or 'VL'
 * @property {number} beta        - Vapor fraction (0 = all liquid, 1 = all vapor)
 * @property {number} vaporFraction - Same as beta (alias for UI code)
 * @property {Object} x           - Liquid mole fractions  {comp: fraction}
 * @property {Object} y           - Vapor mole fractions   {comp: fraction}
 * @property {Object} nL          - Liquid molar flows     {comp: mol/s}
 * @property {Object} nV          - Vapor molar flows      {comp: mol/s}
 * @property {number} iterations  - Solver iteration count
 * @property {boolean} converged  - TRUE only if residual < tolerance; never a default assumption
 * 
 * PH FLASH ADDITIONAL FIELDS (present on phFlash results):
 * @property {number} T_K           - Solved temperature (K)
 * @property {boolean} bracketed    - Whether the root was bracketed before solve
 * @property {number} residual_Jps  - Final enthalpy residual (J/s); 0 for exact two-phase lever rule
 * @property {number} [Tmin_K]      - Lower temperature bound used in solve
 * @property {number} [Tmax_K]      - Upper temperature bound used in solve
 * @property {string} [warning]     - Human-readable warning if !converged or out-of-range
 */



/* =========================
   THERMO PACKAGE SYSTEM
   
   A ThermoPackage encapsulates all physics that vary between thermodynamic models:
   heat capacity, enthalpy, density, vapor pressure, and VLE K-values.
   
   ThermoAdapter delegates physics calls to the active package while handling
   orchestration (flash algorithms, stream aggregation, bisection solvers).
   
   ADDING A NEW MODEL:
   1. Create a class extending ThermoPackage (or IdealRaoultPackage for partial override)
   2. Override the methods whose physics change
   3. Register with: models.register('thermo_package', new YourPackage())
   4. The Models panel will automatically pick it up
   ========================= */

class ThermoPackage {
  /**
   * @param {string} id          - Unique identifier (e.g., 'ideal_raoult')
   * @param {string} name        - Display name (e.g., 'Ideal Gas + Raoult\'s Law')
   * @param {string} description - One-line description for the UI
   */
  constructor(id, name, description) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.status = 'stable';  // 'stable' | 'preview' | 'experimental'
    this._warnedRanges = new Set();
    this._vaporOffsetCache = {};
  }

  // â”€â”€ Physics API (override in subclasses) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Molar heat capacity Cp [J/(molÂ·K)] */
  cpMolar(comp, T_K, P_Pa, phase) { throw new Error('ThermoPackage.cpMolar not implemented'); }

  /** Molar enthalpy H [J/mol] relative to liquid at 298.15 K */
  hMolar(comp, T_K, P_Pa, phase) { throw new Error('ThermoPackage.hMolar not implemented'); }

  /** Mass density [kg/mÂ³] */
  density(comp, T_K, P_Pa, phase) { throw new Error('ThermoPackage.density not implemented'); }

  /** Saturation (vapor) pressure [Pa], or null if unavailable */
  saturationPressure(comp, T_K) { throw new Error('ThermoPackage.saturationPressure not implemented'); }

  /** VLE K-value: Ki = yi/xi at given T, P.  Default: Raoult (Psat/P) */
  kValue(comp, T_K, P_Pa) {
    const Psat = this.saturationPressure(comp, T_K);
    return Psat ? Psat / P_Pa : 1.0;
  }

  // â”€â”€ Cache Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Clear all internal caches. Called on package switch and component changes. */
  clearCaches() {
    this._vaporOffsetCache = {};
    this._warnedRanges.clear();
  }
}

/**
 * IDEAL GAS + RAOULT'S LAW
 * 
 * Gas phase:   Ideal gas (PV = nRT, Cp from polynomial correlation)
 * Liquid phase: Constant Cp, constant density
 * VLE:          Raoult's law (Ki = Psat_i / P)
 * Vapor pressure: Antoine equation (with multi-range support)
 * 
 * Suitable for: low-pressure systems, ideal mixtures, educational use.
 * Limitations:  No pressure effect on liquid properties, no non-ideal mixing.
 */
class IdealRaoultPackage extends ThermoPackage {
  constructor() {
    super(
      'ideal_raoult',
      'Ideal Gas + Raoult\'s Law',
      'Ideal gas EOS, constant liquid properties, Raoult\'s law VLE. Suitable for low-pressure ideal systems.'
    );
    this.status = 'stable';
  }

  // â”€â”€ Heat Capacity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  cpMolar(comp, T_K, P_Pa, phaseHint = null) {
    const compData = ComponentRegistry.get(comp);
    if (!compData) { console.warn(`Component ${comp} not found`); return 0; }

    let phase = phaseHint;
    if (!phase) { phase = (T_K < compData.Tb) ? 'L' : 'V'; }

    if (phase === 'L') {
      if (!compData.cpLiq) {
        console.warn(`No liquid Cp for ${comp}, using ideal gas Cp (may be inaccurate)`);
        phase = 'V';
      } else {
        return compData.cpLiq;
      }
    }

    if (!compData.cpig) { console.warn(`No heat capacity correlation for ${comp}`); return 0; }
    const cpig = compData.cpig;

    // Clamp T to valid range to prevent catastrophic polynomial extrapolation
    let T_eval = T_K;
    if (cpig.Tmin && T_K < cpig.Tmin) {
      console.warn(`Temperature ${T_K}K below Cp correlation range for ${comp} (min ${cpig.Tmin}K)`);
      T_eval = cpig.Tmin;
    }
    if (cpig.Tmax && T_K > cpig.Tmax) {
      console.warn(`Temperature ${T_K}K above Cp correlation range for ${comp} (max ${cpig.Tmax}K)`);
      T_eval = cpig.Tmax;
    }

    const T = T_eval;
    return cpig.A + cpig.B * T + cpig.C * T * T + cpig.D * T * T * T + (cpig.E || 0) * T * T * T * T;
  }

  // â”€â”€ Enthalpy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  hMolar(comp, T_K, P_Pa, phaseHint = null) {
    const compData = ComponentRegistry.get(comp);
    if (!compData) { console.warn(`Component ${comp} not found in registry`); return 0; }

    const Tref = 298.15;
    let phase = phaseHint;
    if (!phase) { phase = (T_K < compData.Tb) ? 'L' : 'V'; }

    if (phase === 'V') {
      if (!compData.cpig) { console.warn(`No ideal gas Cp correlation for ${comp}`); return 0; }
      const cpig = compData.cpig;

      // Range warnings (deduplicated)
      if (cpig.Tmin && T_K < cpig.Tmin) {
        const wk = `${comp}-cpig-below-${cpig.Tmin}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K below Cp_ig range for ${comp} (min ${cpig.Tmin}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }
      if (cpig.Tmax && T_K > cpig.Tmax) {
        const wk = `${comp}-cpig-above-${cpig.Tmax}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K above Cp_ig range for ${comp} (max ${cpig.Tmax}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }

      function integratedCpig(T) {
        return cpig.A * T + cpig.B * T * T / 2 + cpig.C * T * T * T / 3
             + cpig.D * T * T * T * T / 4 + (cpig.E || 0) * T * T * T * T * T / 5;
      }
      function cpigAt(T) {
        return cpig.A + cpig.B * T + cpig.C * T * T + cpig.D * T * T * T + (cpig.E || 0) * T * T * T * T;
      }

      // Integrate with clamping: beyond valid range, extend linearly with Cp at boundary
      let hV_sens;
      const Tmin_cp = cpig.Tmin || 0;
      const Tmax_cp = cpig.Tmax || Infinity;

      if (T_K > Tmax_cp) {
        hV_sens = (integratedCpig(Tmax_cp) - integratedCpig(Tref)) + cpigAt(Tmax_cp) * (T_K - Tmax_cp);
      } else if (T_K < Tmin_cp) {
        hV_sens = (integratedCpig(Tmin_cp) - integratedCpig(Tref)) + cpigAt(Tmin_cp) * (T_K - Tmin_cp);
      } else {
        hV_sens = integratedCpig(T_K) - integratedCpig(Tref);
      }

      const dHref_vap = this._getVaporEnthalpyOffset(comp);
      return hV_sens + dHref_vap;

    } else if (phase === 'L') {
      if (!compData.cpLiq) { console.warn(`No liquid Cp for ${comp}`); return 0; }
      const cpLiq = compData.cpLiq;

      if (typeof cpLiq === 'object' && cpLiq.A !== undefined) {
        function integratedCpLiq(T) {
          return cpLiq.A * T + (cpLiq.B || 0) * T * T / 2 + (cpLiq.C || 0) * T * T * T / 3
               + (cpLiq.D || 0) * T * T * T * T / 4 + (cpLiq.E || 0) * T * T * T * T * T / 5;
        }
        return integratedCpLiq(T_K) - integratedCpLiq(Tref);
      } else {
        return cpLiq * (T_K - Tref);
      }
    } else {
      console.warn(`Unknown phase '${phase}' for ${comp}`);
      return 0;
    }
  }

  /** Compute vapor enthalpy reference offset. Cached for performance. */
  _getVaporEnthalpyOffset(comp) {
    if (this._vaporOffsetCache[comp] !== undefined) {
      return this._vaporOffsetCache[comp];
    }

    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.Hv || !compData.Tb) {
      console.warn(`Cannot compute vapor offset for ${comp} - missing Hv or Tb`);
      this._vaporOffsetCache[comp] = 0;
      return 0;
    }

    const Tref = 298.15;
    const Tb = compData.Tb;
    const Hv = compData.Hv;
    const cpig = compData.cpig;
    const cpLiq = compData.cpLiq;

    if (!cpig || !cpLiq) {
      console.warn(`Cannot compute vapor offset for ${comp} - missing Cp data`);
      this._vaporOffsetCache[comp] = 0;
      return 0;
    }

    function integratedCpig(T) {
      return cpig.A * T + cpig.B * T * T / 2 + cpig.C * T * T * T / 3
           + cpig.D * T * T * T * T / 4 + (cpig.E || 0) * T * T * T * T * T / 5;
    }
    const hV_sens_at_Tb = integratedCpig(Tb) - integratedCpig(Tref);

    let hL_at_Tb;
    if (typeof cpLiq === 'object' && cpLiq.A !== undefined) {
      function integratedCpLiq(T) {
        return cpLiq.A * T + (cpLiq.B || 0) * T * T / 2 + (cpLiq.C || 0) * T * T * T / 3
             + (cpLiq.D || 0) * T * T * T * T / 4 + (cpLiq.E || 0) * T * T * T * T * T / 5;
      }
      hL_at_Tb = integratedCpLiq(Tb) - integratedCpLiq(Tref);
    } else {
      hL_at_Tb = cpLiq * (Tb - Tref);
    }

    const dHref_vap = Hv - (hV_sens_at_Tb - hL_at_Tb);
    this._vaporOffsetCache[comp] = dHref_vap;
    return dHref_vap;
  }

  // â”€â”€ Density â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  density(comp, T_K, P_Pa, phaseHint) {
    if (phaseHint === 'L') {
      const compData = ComponentRegistry.get(comp);
      const rhoLiq = compData && compData.rhoLiq;
      if (rhoLiq) return rhoLiq;
      console.warn(`No liquid density (rhoLiq) for ${comp}, using default 1000 kg/mÂ³`);
      return 1000;
    } else if (phaseHint === 'V') {
      const compData = ComponentRegistry.get(comp);
      const MW = compData ? compData.MW : 28;
      const R = 8.314;
      return (P_Pa * MW / 1000) / (R * T_K);
    }
    return null;
  }

  // â”€â”€ Vapor Pressure (Antoine) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  saturationPressure(comp, T_K) {
    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.antoine) {
      console.warn(`No Antoine coefficients for ${comp}`);
      return null;
    }

    let antoineData = compData.antoine;
    const T_C = T_K - 273.15;

    if (Array.isArray(antoineData)) {
      let selectedRange = null;
      let closestRange = null;
      let closestDist = Infinity;

      for (const range of antoineData) {
        if (T_K >= range.Tmin && T_K <= range.Tmax) { selectedRange = range; break; }
        const dist = Math.min(Math.abs(T_K - range.Tmin), Math.abs(T_K - range.Tmax));
        if (dist < closestDist) { closestDist = dist; closestRange = range; }
      }

      if (selectedRange) {
        antoineData = selectedRange;
      } else {
        const side = T_K < closestRange.Tmin ? 'below' : 'above';
        const wk = `${comp}-antoine-${side}`;
        if (!this._warnedRanges.has(wk)) {
          const desc = closestRange.desc || `${closestRange.Tmin}-${closestRange.Tmax}K`;
          console.warn(`T=${T_K.toFixed(1)}K outside all Antoine ranges for ${comp}, using closest range (${desc})`);
          this._warnedRanges.add(wk);
        }
        antoineData = closestRange;
      }
    } else {
      if (antoineData.Tmin && T_K < antoineData.Tmin) {
        const wk = `${comp}-antoine-below-${antoineData.Tmin}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K below Antoine range for ${comp} (min ${antoineData.Tmin}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }
      if (antoineData.Tmax && T_K > antoineData.Tmax) {
        const wk = `${comp}-antoine-above-${antoineData.Tmax}`;
        if (!this._warnedRanges.has(wk)) {
          console.warn(`T=${T_K.toFixed(1)}K above Antoine range for ${comp} (max ${antoineData.Tmax}K) - using extrapolation`);
          this._warnedRanges.add(wk);
        }
      }
    }

    const log10_Psat_mmHg = antoineData.A - antoineData.B / (antoineData.C + T_C);
    const Psat_mmHg = Math.pow(10, log10_Psat_mmHg);
    return Psat_mmHg * 133.322;
  }

  // â”€â”€ VLE K-value (Raoult's law) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  kValue(comp, T_K, P_Pa) {
    const Psat = this.saturationPressure(comp, T_K);
    return Psat ? Psat / P_Pa : 1.0;
  }
}

/**
 * PENG-ROBINSON EQUATION OF STATE (Stub)
 * 
 * Cubic EOS for non-ideal gas and liquid phases:
 *   P = RT/(V-b) - a(T)/[V(V+b) + b(V-b)]
 * 
 * Will provide: departure functions for H and Cp, liquid density from cubic roots,
 * fugacity coefficients for rigorous VLE (Ki = Ï†_L_i / Ï†_V_i).
 * 
 * Currently falls back to IdealRaoultPackage for all methods.
 * Override methods here as the implementation is built out.
 * 
 * STATUS: preview â€” not yet implemented; selecting this uses ideal gas as fallback.
 */
class PengRobinsonPackage extends IdealRaoultPackage {
  constructor() {
    super();
    // Override base class identity
    this.id = 'peng_robinson';
    this.name = 'Peng-Robinson EOS';
    this.description = 'Cubic EOS for non-ideal systems. Accurate for hydrocarbons at moderate to high pressures. (Not yet implemented â€” falls back to ideal gas.)';
    this.status = 'preview';
  }

  // â”€â”€ Future overrides â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When implementing, override these one by one.
  // Each override replaces the ideal-gas version with PR departure functions.

  // cpMolar(comp, T_K, P_Pa, phase) {
  //   // TODO: Cp_ig(T) + Cp_departure(T, P, phase)
  //   // Cp_dep = -T * dÂ²a/dTÂ² * ... (from EOS)
  // }

  // hMolar(comp, T_K, P_Pa, phase) {
  //   // TODO: H_ig(T) + H_departure(T, P, phase)
  //   // H_dep = [a - T*da/dT] * integral term from cubic solution
  // }

  // density(comp, T_K, P_Pa, phase) {
  //   // TODO: Solve cubic ZÂ³ - (1-B)ZÂ² + (A-3BÂ²-2B)Z - (AB-BÂ²-BÂ³) = 0
  //   // Ï = P * MW / (Z * R * T)
  // }

  // saturationPressure(comp, T_K) {
  //   // TODO: Iterative bubble point: find P where Ï†_L = Ï†_V
  // }

  // kValue(comp, T_K, P_Pa) {
  //   // TODO: Ki = Ï†_L_i(T,P,x) / Ï†_V_i(T,P,y)
  //   // Requires iterative solution with composition dependence
  // }
}

class ThermoAdapter {
  constructor(pkg) {
    if (!pkg || !(pkg instanceof ThermoPackage)) {
      throw new Error('ThermoAdapter requires a ThermoPackage instance');
    }
    this._pkg = pkg;
  }
  
  /** Proxy _warnedRanges to active package (used by saturationTemperature and tests) */
  get _warnedRanges() { return this._pkg._warnedRanges; }
  set _warnedRanges(v) { this._pkg._warnedRanges = v; }
  
  /** Switch active thermo package. Clears all caches and warnings. */
  setPackage(pkg) {
    if (!pkg || !(pkg instanceof ThermoPackage)) {
      throw new Error('setPackage requires a ThermoPackage instance');
    }
    this._pkg.clearCaches();
    this._pkg = pkg;
  }
  
  /** Get active package info */
  getPackage() { return this._pkg; }
  
  /**
   * Normalize phase hint to single-phase value
   * 
   * CRITICAL: Prevents passing 'VL' to single-phase property functions (cpMolar, hMolar, etc)
   * which expect only 'V' or 'L'. This is a common silent corruption bug when VL streams
   * have undefined quality and fallback logic uses phaseConstraint='VL' as a phase hint.
   * 
   * @param {string} phaseConstraintOrHint - Phase from stream.phaseConstraint or similar
   * @param {string} defaultPhase - Default single phase to use ('L' or 'V'), default 'L'
   * @returns {string} Single phase: 'V' or 'L' (never 'VL')
   */
  normalizeSinglePhaseHint(phaseConstraintOrHint, defaultPhase = 'L') {
    // Validate defaultPhase is single-phase
    if (defaultPhase !== 'V' && defaultPhase !== 'L') {
      console.warn(`normalizeSinglePhaseHint: invalid defaultPhase '${defaultPhase}', using 'L'`);
      defaultPhase = 'L';
    }
    
    // Map to single phase
    if (phaseConstraintOrHint === 'V') return 'V';
    if (phaseConstraintOrHint === 'L') return 'L';
    
    // Anything else (including 'VL', null, undefined, '') â†’ defaultPhase
    return defaultPhase;
  }
  
  /**
   * Get component property (molecular weight, critical properties, etc.)
   * @param {string} comp - Component formula (e.g., 'H2O')
   * @param {string} prop - Property name: 'MW', 'Tc', 'Pc', 'omega', etc.
   * @returns {number} Property value
   */
  getComponentProp(comp, prop) {
    const compData = ComponentRegistry.get(comp);
    if (!compData) {
      console.warn(`Component ${comp} not found`);
      return null;
    }
    return compData[prop];
  }
  
  /** Molar heat capacity [J/(molÂ·K)] â€” delegated to active thermo package */
  cpMolar(comp, T_K, P_Pa, phaseHint = null) {
    return this._pkg.cpMolar(comp, T_K, P_Pa, phaseHint);
  }
  
  /** Molar enthalpy [J/mol] â€” delegated to active thermo package */
  hMolar(comp, T_K, P_Pa, phaseHint = null) {
    return this._pkg.hMolar(comp, T_K, P_Pa, phaseHint);
  }
  
    /**
   * Compute complete enthalpy properties for a material stream
   * 
   * Calculates total enthalpy flow (Hdot) and mixture molar enthalpy (hMolarMix)
   * 
   * For single phase: Hdot = Î£(n_i * h_i(T, P, phase))
   * For two-phase:    Hdot = Î£(nV_i * h_i(T, P, 'V')) + Î£(nL_i * h_i(T, P, 'L'))
   * 
   * CRITICAL: For VL phase, only uses nV/nL if split is actually defined
   * If quality is undefined (e.g., single-component at saturation), falls back
   * to single-phase calculation with warning
   * 
   * @param {Object} stream - Material stream with {T, P, n, phase, nV, nL, ...}
   * @returns {Object} Stream with added enthalpy properties
   */
  computeStreamEnthalpy(stream) {
    if (!stream || stream.type !== StreamType.MATERIAL) {
      console.warn('computeStreamEnthalpy called on non-material stream');
      return stream;
    }
    
    // Total molar flow
    const nTot = Object.values(stream.n || {}).reduce((sum, n) => sum + n, 0);
    
    if (nTot < 1e-12) {
      // Empty stream
      stream.nTot = 0;
      stream.hMolarMix = 0;
      stream.Hdot_J_s = 0;
      return stream;
    }
    
    let Hdot_total = 0;  // J/s (internal unit)
    
    // Check if VL split is actually defined
    if (stream.phase === 'VL' && this._isVLSplitDefined(stream)) {
      // TWO-PHASE WITH DEFINED SPLIT: Direct sum of component contributions
      // Hdot = Î£(nV_i * hV_i) + Î£(nL_i * hL_i)
      
      // Vapor contribution
      for (const [comp, n_i] of Object.entries(stream.nV)) {
        if (n_i > 1e-12) {  // Skip negligible flows
          const h_i = this.hMolar(comp, stream.T, stream.P, 'V');
          Hdot_total += n_i * h_i;  // mol/s * J/mol = J/s
        }
      }
      
      // Liquid contribution
      for (const [comp, n_i] of Object.entries(stream.nL)) {
        if (n_i > 1e-12) {  // Skip negligible flows
          const h_i = this.hMolar(comp, stream.T, stream.P, 'L');
          Hdot_total += n_i * h_i;  // mol/s * J/mol = J/s
        }
      }
      
    } else if (stream.phase === 'VL' && !this._isVLSplitDefined(stream)) {
      // VL PHASE BUT UNDEFINED SPLIT (e.g., saturation with unknown quality)
      // Fallback to single-phase calculation with warning
      
      // CRITICAL: Use normalizeSinglePhaseHint to prevent passing 'VL' to hMolar
      // stream.phaseConstraint might be 'VL', which is invalid for single-phase functions
      const fallbackPhase = this.normalizeSinglePhaseHint(stream.phaseConstraint, 'L');
      
      console.warn(`VL phase with undefined quality detected - using ${fallbackPhase} phase for enthalpy (PH flash required)`);
      
      for (const [comp, n_i] of Object.entries(stream.n)) {
        if (n_i > 1e-12) {
          const h_i = this.hMolar(comp, stream.T, stream.P, fallbackPhase);
          Hdot_total += n_i * h_i;
        }
      }
      
      // Mark stream with warning
      stream.enthalpyWarning = `Quality undefined at saturation - ${fallbackPhase} phase assumed. PH flash required for accurate enthalpy.`;
      
    } else {
      // SINGLE PHASE: Sum component contributions
      // Hdot = Î£(n_i * h_i)
      const phase = stream.phase || 'V';
      
      for (const [comp, n_i] of Object.entries(stream.n)) {
        if (n_i > 1e-12) {  // Skip negligible flows
          const h_i = this.hMolar(comp, stream.T, stream.P, phase);
          Hdot_total += n_i * h_i;  // mol/s * J/mol = J/s
        }
      }
    }
    
    // Compute mixture molar enthalpy
    const hMolarMix = Hdot_total / nTot;  // J/mol
    
    // Store on stream (INTERNAL UNITS: J/s, J/mol)
    stream.nTot = nTot;
    stream.hMolarMix = hMolarMix;  // J/mol
    stream.Hdot_J_s = Hdot_total;  // J/s (canonical internal unit)
    
    // Validation: Ensure non-empty stream has non-zero enthalpy unless at reference
    if (nTot > 1e-12 && Math.abs(Hdot_total) < 1e-6 && Math.abs(stream.T - 298.15) > 0.1) {
      console.warn(`Stream at T=${stream.T}K has Hdotâ‰ˆ0 - possible enthalpy calculation error`);
    }
    
    return stream;
  }
  
  /**
   * Get total enthalpy flow rate in J/s, ensuring it's computed
   * 
   * CRITICAL: This function guarantees enthalpy is computed before use.
   * Use this in units that need inlet enthalpy (valve, heater, etc) to avoid
   * silent failures when Hdot is undefined.
   * 
   * INTERNAL UNITS: Returns J/s (canonical)
   * 
   * @param {Object} stream - Material stream
   * @returns {number} Hdot in J/s, or 0 if stream invalid
   */
  getHdot_Jps(stream) {
    if (!stream || stream.type !== StreamType.MATERIAL) {
      console.warn('getHdot_Jps: invalid or non-material stream');
      return 0;
    }
    
    // Check if stream has minimum required fields for enthalpy calculation
    if (!stream.T || !stream.P || !stream.n) {
      console.warn('getHdot_Jps: stream missing T, P, or n - cannot compute enthalpy');
      return 0;
    }
    
    // If Hdot already computed and valid, return it (J/s)
    if (stream.Hdot_J_s !== undefined && stream.Hdot_J_s !== null && !isNaN(stream.Hdot_J_s)) {
      return stream.Hdot_J_s;  // Already in J/s
    }
    
    // Need to compute enthalpy on-demand
    // First ensure flash is done if needed
    if (!stream.phase) {
      try {
        const flashResult = this.tpFlash(stream);
        stream.phase = flashResult.phase;
        stream.beta = flashResult.beta;
        stream.nV = flashResult.nV;
        stream.nL = flashResult.nL;
        stream.x = flashResult.x;
        stream.y = flashResult.y;
      } catch (err) {
        console.warn(`getHdot_Jps: flash failed - ${err.message}`);
        return 0;
      }
    }
    
    // Now compute enthalpy
    try {
      this.computeStreamEnthalpy(stream);
      return stream.Hdot_J_s;  // J/s
    } catch (err) {
      console.warn(`getHdot_Jps: enthalpy calculation failed - ${err.message}`);
      return 0;
    }
  }
  
  /**
   * Density
   * @param {string} comp - Component formula
   * @param {number} T_K - Temperature in Kelvin
   * @param {number} P_Pa - Pressure in Pascal
   * @param {string} phaseHint - 'V' for vapor, 'L' for liquid
   * @returns {number} Density in kg/mÂ³
   */
  /** Mass density [kg/mÂ³] â€” delegated to active thermo package */
  density(comp, T_K, P_Pa, phaseHint) {
    return this._pkg.density(comp, T_K, P_Pa, phaseHint);
  }
  
  
  /**
   * Temperature-Pressure flash calculation
   * Determines phase split and equilibrium for given T, P, composition
   * @param {Object} stream - {T: K, P: Pa, n: {comp: mol/s}, phaseConstraint: 'V'|'L'|'VL'}
   * @returns {Object} {phase, beta, vaporFraction, x, y, nL, nV}
   */
  tpFlash(stream) {
    const T_K = stream.T;
    const P_Pa = stream.P;
    const n = stream.n;
    const phaseConstraint = stream.phaseConstraint || 'VL';
    
    // Built-in TP flash implementation (legacy external flash model removed in v1.5.0)
    // Uses Raoult's law with Rachford-Rice for multi-component VLE
    
    const comps = Object.keys(n);
    const nTotal = Object.values(n).reduce((a,b) => a+b, 0);
    
    if (nTotal < 1e-12) {
      return {
        phase: 'V',
        beta: 1.0,
        vaporFraction: 1.0,
        x: {},
        y: {},
        nL: {},
        nV: {}
      };
    }
    
    // Simple single-component flash using saturation pressure
    if (comps.length === 1) {
      const comp = comps[0];
      const Psat = this.saturationPressure(comp, T_K);
      
      if (!Psat) {
        // No saturation pressure available, use phase constraint
        if (phaseConstraint === 'L') {
          return {
            phase: 'L',
            beta: 0.0,
            vaporFraction: 0.0,
            x: { [comp]: 1.0 },
            y: {},
            nL: { [comp]: n[comp] },
            nV: {}
          };
        }
        return {
          phase: 'V',
          beta: 1.0,
          vaporFraction: 1.0,
          x: {},
          y: { [comp]: 1.0 },
          nL: {},
          nV: { [comp]: n[comp] }
        };
      }
      
      const K = Psat / P_Pa;
      
      if (phaseConstraint === 'V' || K > 1.05) {
        // Vapor phase
        return {
          phase: 'V',
          beta: 1.0,
          vaporFraction: 1.0,
          x: {},
          y: { [comp]: 1.0 },
          nL: {},
          nV: { [comp]: n[comp] }
        };
      } else if (phaseConstraint === 'L' || K < 0.95) {
        // Liquid phase
        return {
          phase: 'L',
          beta: 0.0,
          vaporFraction: 0.0,
          x: { [comp]: 1.0 },
          y: {},
          nL: { [comp]: n[comp] },
          nV: {}
        };
      } else {
        // FIX 4: Two-phase region (0.95 < K < 1.05)
        // For single component at saturation: K â‰ˆ 1
        // Quality (vapor fraction) is UNDEFINED from TP alone
        // Requires energy balance (PH flash) to determine actual split
        
        return {
          phase: 'VL',
          beta: null,  // Undefined - requires PH flash
          vaporFraction: null,
          x: { [comp]: 1.0 },
          y: { [comp]: 1.0 },
          nL: {},  // Cannot determine without energy balance
          nV: {},  // Cannot determine without energy balance
          warning: 'Single-component at saturation: quality undefined in TP flash. Requires PH flash for vapor fraction.'
        };
      }
    }
    
    // â”€â”€ Multi-component Rachford-Rice VLE flash (Raoult's law) â”€â”€
    // K_i = Psat_i(T) / P for each component
    // Solve: Î£ z_i(K_i - 1) / (1 + Î²(K_i - 1)) = 0  for Î² âˆˆ [0, 1]
    
    const z = {};   // Overall mole fractions
    const K = {};   // K-values
    let allAbove = true;   // All K > 1 â†’ all vapor
    let allBelow = true;   // All K < 1 â†’ all liquid
    
    for (const c of comps) {
      z[c] = n[c] / nTotal;
      const Psat = this.saturationPressure(c, T_K);
      if (Psat) {
        K[c] = Psat / P_Pa;
      } else {
        // No Psat data (supercritical or missing Antoine) â†’ non-condensable
        K[c] = T_K > (ComponentRegistry.get(c)?.Tc || 1e6) ? 1e6 : 1.0;
      }
      if (K[c] <= 1.0) allAbove = false;
      if (K[c] >= 1.0) allBelow = false;
    }
    
    // Phase constraint shortcuts
    if (phaseConstraint === 'L') {
      return {
        phase: 'L', beta: 0.0, vaporFraction: 0.0,
        x: { ...z }, y: {},
        nL: { ...n }, nV: {}
      };
    }
    if (phaseConstraint === 'V') {
      return {
        phase: 'V', beta: 1.0, vaporFraction: 1.0,
        x: {}, y: { ...z },
        nL: {}, nV: { ...n }
      };
    }
    
    // Check dew/bubble conditions
    // Bubble point check: Î£ z_i K_i.  If < 1, all liquid (below bubble point)
    // Dew point check:    Î£ z_i / K_i. If < 1, all vapor (above dew point)
    let sumZK = 0, sumZoverK = 0;
    for (const c of comps) { sumZK += z[c] * K[c]; sumZoverK += z[c] / K[c]; }
    
    if (sumZK <= 1.0) {
      // Below bubble point â†’ all liquid
      return {
        phase: 'L', beta: 0.0, vaporFraction: 0.0,
        x: { ...z }, y: {},
        nL: { ...n }, nV: {}
      };
    }
    
    if (sumZoverK <= 1.0) {
      // Above dew point â†’ all vapor
      return {
        phase: 'V', beta: 1.0, vaporFraction: 1.0,
        x: {}, y: { ...z },
        nL: {}, nV: { ...n }
      };
    }
    
    // â”€â”€ Two-phase: solve Rachford-Rice by Newton-Raphson â”€â”€
    let beta = 0.5;  // Initial guess
    
    for (let iter = 0; iter < 50; iter++) {
      let f = 0, df = 0;
      for (const c of comps) {
        const km1 = K[c] - 1;
        const denom = 1 + beta * km1;
        f += z[c] * km1 / denom;
        df -= z[c] * km1 * km1 / (denom * denom);
      }
      
      if (Math.abs(f) < 1e-12) break;
      
      const step = f / df;
      beta -= step;
      
      // Clamp to valid range
      beta = Math.max(1e-10, Math.min(1 - 1e-10, beta));
    }
    
    // Compute phase compositions and flows
    const x = {}, y = {}, nL_out = {}, nV_out = {};
    for (const c of comps) {
      x[c] = z[c] / (1 + beta * (K[c] - 1));
      y[c] = K[c] * x[c];
      nL_out[c] = x[c] * (1 - beta) * nTotal;
      nV_out[c] = y[c] * beta * nTotal;
    }
    
    return {
      phase: 'VL',
      beta: beta,
      vaporFraction: beta,
      x, y,
      nL: nL_out,
      nV: nV_out
    };
  }
  
  /**
   * Pressure-Enthalpy flash calculation
   * 
   * Accepts target enthalpy via EITHER:
   *   - Second argument: phFlash(stream, H_target_Jps)
   *   - Stream property:  phFlash({ P, n, H_target_Jps })
   * 
   * The solver uses the two-argument form; direct callers and tests may use either.
   * If both are provided, the explicit second argument takes precedence.
   * 
   * @param {Object} stream - {P: Pa, n: {comp: mol/s}, H_target_Jps?: number}
   * @param {number} [H_target_Jps] - Target enthalpy in J/s (optional if on stream)
   * @returns {Object} Flash result with T_K, converged, residual_Jps, etc.
   */
  phFlash(stream, H_target_Jps) {
    // PH FLASH: Given P, n, and target enthalpy, solve for T and phase split
    // Supports single-component (with saturation handling) and mixtures
    
    // CRITICAL: Accept H_target_Jps from either the second argument or the stream object.
    // The explicit argument takes precedence when provided.
    if (H_target_Jps === undefined || H_target_Jps === null) {
      H_target_Jps = stream.H_target_Jps;
    }
    
    // Validate that we actually have a target
    if (H_target_Jps === undefined || H_target_Jps === null || !isFinite(H_target_Jps)) {
      console.error('phFlash: No valid H_target_Jps provided (neither as argument nor on stream)');
      return {
        phase: 'V', beta: 1.0, vaporFraction: 1.0,
        x: {}, y: {}, nL: {}, nV: {},
        T_K: 298.15, iterations: 0,
        converged: false, bracketed: false,
        residual_Jps: NaN,
        warning: 'phFlash called without valid H_target_Jps'
      };
    }
    
    const P_Pa = stream.P;
    const n = stream.n;
    const phaseConstraint = stream.phaseConstraint || 'VL';
    
    const nTot = Object.values(n).reduce((sum, val) => sum + val, 0);
    
    if (nTot < 1e-12) {
      // Empty stream - return default vapor at reference T
      return {
        phase: 'V',
        beta: 1.0,
        vaporFraction: 1.0,
        x: {},
        y: {},
        nL: {},
        nV: {},
        T_K: 298.15,
        iterations: 0,
        converged: true,
        bracketed: true,
        residual_Jps: 0,
        warning: undefined
      };
    }
    
    // Target molar enthalpy
    const h_target = H_target_Jps / nTot;  // J/mol
    
    // Check if single component
    const comps = Object.keys(n);
    const isSingleComponent = (comps.length === 1);
    
    if (isSingleComponent && phaseConstraint === 'VL') {
      // SINGLE-COMPONENT SPECIAL HANDLING
      return this._phFlash_SingleComponent(comps[0], P_Pa, n, h_target, H_target_Jps);
    }
    
    // GENERAL CASE (mixtures or constrained phase)
    return this._phFlash_General(P_Pa, n, h_target, H_target_Jps, phaseConstraint);
  }
  
  /**
   * PH flash for single component with saturation handling
   * 
   * Determines region (subcooled, two-phase, superheated) using saturation enthalpies,
   * then solves for T (subcooled/superheated) or quality (two-phase).
   * 
   * Returns SAME metadata contract as _phFlash_General:
   *   {T_K, converged, bracketed, residual_Jps, iterations, Tmin_K, Tmax_K, warning, ...}
   * 
   * @private
   */
  _phFlash_SingleComponent(comp, P_Pa, n, h_target, H_target_Jps) {
    const nTot = n[comp];
    const compData = ComponentRegistry.get(comp);
    
    // Find saturation temperature at this pressure
    const Tsat = this._findSaturationTemperature(comp, P_Pa);
    
    if (!Tsat) {
      // Cannot find Tsat (supercritical, no Antoine data, etc.) â€” fall back to general method
      console.warn(`Cannot find Tsat for ${comp} at P=${P_Pa}Pa - using general PH flash`);
      return this._phFlash_General(P_Pa, n, h_target, H_target_Jps, 'VL');
    }
    
    // Compute liquid and vapor enthalpies at saturation
    const hf = this.hMolar(comp, Tsat, P_Pa, 'L');  // Saturated liquid enthalpy (J/mol)
    const hg = this.hMolar(comp, Tsat, P_Pa, 'V');  // Saturated vapor enthalpy (J/mol)
    
    // Determine region and solve
    if (h_target < hf * 0.9999) {
      // â”€â”€â”€ SUBCOOLED LIQUID: h < hf â”€â”€â”€
      // Adaptive lower bound: use melting point or fraction of Tb, with absolute minimum
      const Tmin_solve = Math.max(50, compData.Tm || (compData.Tb ? compData.Tb * 0.4 : 50));
      const Tmax_solve = Tsat;
      
      const solveResult = this._solveTemperatureForEnthalpy(comp, P_Pa, h_target, 'L', Tmin_solve, Tmax_solve);
      const residual_Jps = solveResult.residual * nTot;  // J/mol â†’ J/s
      
      return {
        phase: 'L',
        beta: 0.0,
        vaporFraction: 0.0,
        x: { [comp]: 1.0 },
        y: {},
        nL: { [comp]: nTot },
        nV: {},
        T_K: solveResult.T_K,
        iterations: solveResult.iterations,
        converged: solveResult.converged,
        bracketed: solveResult.bracketed,
        residual_Jps: residual_Jps,
        Tmin_K: Tmin_solve,
        Tmax_K: Tmax_solve,
        warning: solveResult.warning
      };
      
    } else if (h_target > hg * 1.0001) {
      // â”€â”€â”€ SUPERHEATED VAPOR: h > hg â”€â”€â”€
      const Tmin_solve = Tsat;
      const Tmax_solve = 3000;  // Match _phFlash_General's upper bound
      
      const solveResult = this._solveTemperatureForEnthalpy(comp, P_Pa, h_target, 'V', Tmin_solve, Tmax_solve);
      const residual_Jps = solveResult.residual * nTot;  // J/mol â†’ J/s
      
      return {
        phase: 'V',
        beta: 1.0,
        vaporFraction: 1.0,
        x: {},
        y: { [comp]: 1.0 },
        nL: {},
        nV: { [comp]: nTot },
        T_K: solveResult.T_K,
        iterations: solveResult.iterations,
        converged: solveResult.converged,
        bracketed: solveResult.bracketed,
        residual_Jps: residual_Jps,
        Tmin_K: Tmin_solve,
        Tmax_K: Tmax_solve,
        warning: solveResult.warning
      };
      
    } else {
      // â”€â”€â”€ TWO-PHASE: hf â‰¤ h â‰¤ hg â”€â”€â”€
      // Compute quality from lever rule â€” exact for single component
      const beta = (h_target - hf) / (hg - hf);
      const beta_clamped = Math.max(0, Math.min(1, beta));
      
      const nV_val = beta_clamped * nTot;
      const nL_val = (1 - beta_clamped) * nTot;
      
      // Residual is zero by construction (lever rule gives exact h)
      return {
        phase: 'VL',
        beta: beta_clamped,
        vaporFraction: beta_clamped,
        x: { [comp]: 1.0 },
        y: { [comp]: 1.0 },
        nL: { [comp]: nL_val },
        nV: { [comp]: nV_val },
        T_K: Tsat,
        iterations: 1,
        converged: true,
        bracketed: true,
        residual_Jps: 0,
        Tmin_K: Tsat,
        Tmax_K: Tsat,
        warning: undefined
      };
    }
  }
  
  /**
   * General PH flash for mixtures or constrained phases
   * @private
   */
  _phFlash_General(P_Pa, n, h_target, H_target_Jps, phaseConstraint) {
    const nTot = Object.values(n).reduce((sum, val) => sum + val, 0);
    
    // Define enthalpy calculation function at temperature T
    const Hcalc = (T_K) => {
      // Build temporary stream
      const tempStream = {
        type: StreamType.MATERIAL,
        T: T_K,
        P: P_Pa,
        n: { ...n },
        phaseConstraint
      };
      
      // Flash at this T
      const flashResult = this.tpFlash(tempStream);
      
      // Augment with flash results
      tempStream.phase = flashResult.phase;
      tempStream.beta = flashResult.beta;
      tempStream.nV = flashResult.nV;
      tempStream.nL = flashResult.nL;
      tempStream.x = flashResult.x;
      tempStream.y = flashResult.y;
      
      // Compute enthalpy
      this.computeStreamEnthalpy(tempStream);
      
      return tempStream.Hdot_J_s;  // J/s (internal unit)
    };
    
    // Solve for T using bracketed method
    // Adaptive bounds based on component properties
    const comps = Object.keys(n);
    let Tmin_default = 200;
    for (const c of comps) {
      const cd = ComponentRegistry.get(c);
      if (cd) {
        const Tlow = Math.max(20, (cd.Tm || cd.Tb * 0.5 || 50) - 20);
        Tmin_default = Math.min(Tmin_default, Tlow);
      }
    }
    let Tmin = Tmin_default;
    let Tmax = 2000;  // K
    
    // Narrow bracket if phase-constrained
    if (phaseConstraint === 'L') {
      Tmax = 700;  // Reasonable max for liquids
    }
    
    // Regula falsi with bisection fallback
    let T_solution = null;
    let iterations = 0;
    const MAX_ITER = 150;
    const TOL = Math.max(5e-4 * Math.abs(H_target_Jps), 1e-3);  // J/s â€” 0.05% relative or 1 mJ/s absolute
    const ZERO_DENOMINATOR_THRESHOLD = 1e-6;  // Guard against Hmax â‰ˆ Hmin
    
    let Hmin = Hcalc(Tmin);
    let Hmax = Hcalc(Tmax);
    
    // Check if solution is bracketed
    let bracketed = (H_target_Jps - Hmin) * (H_target_Jps - Hmax) <= 0;
    
    if (!bracketed) {
      // Not bracketed - try wider range
      if (H_target_Jps < Hmin) {
        Tmin = 100;
        Hmin = Hcalc(Tmin);
      }
      if (H_target_Jps > Hmax) {
        Tmax = 3000;
        Hmax = Hcalc(Tmax);
      }
      
      // CRITICAL: Re-check bracketing after widening
      bracketed = (H_target_Jps - Hmin) * (H_target_Jps - Hmax) <= 0;
      
      if (!bracketed) {
        // STILL not bracketed - target is outside achievable range
        // Choose endpoint closest to target as best effort
        const distMin = Math.abs(Hmin - H_target_Jps);
        const distMax = Math.abs(Hmax - H_target_Jps);
        
        T_solution = (distMin < distMax) ? Tmin : Tmax;
        const H_final = (distMin < distMax) ? Hmin : Hmax;
        const residual = H_final - H_target_Jps;
        
        console.warn(`PH flash: Target H=${(H_target_Jps/1000).toFixed(1)} kW outside achievable range [${(Hmin/1000).toFixed(1)}, ${(Hmax/1000).toFixed(1)}] kW. Using T=${T_solution.toFixed(1)}K (residual=${(residual/1000).toFixed(1)} kW)`);
        
        // Final flash at best-effort temperature
        const finalStream = {
          type: StreamType.MATERIAL,
          T: T_solution,
          P: P_Pa,
          n: { ...n },
          phaseConstraint
        };
        
        const flashResult = this.tpFlash(finalStream);
        
        return {
          phase: flashResult.phase,
          beta: flashResult.beta,
          vaporFraction: flashResult.vaporFraction || flashResult.beta,
          x: flashResult.x,
          y: flashResult.y,
          nL: flashResult.nL,
          nV: flashResult.nV,
          T_K: T_solution,
          iterations: 0,
          converged: false,
          bracketed: false,
          residual_Jps: residual,
          Tmin_K: Tmin,
          Tmax_K: Tmax,
          warning: `Target enthalpy outside achievable range. Residual: ${(residual/1000).toFixed(1)} kW`
        };
      }
    }
    
    // Bracketed solver loop
    let residual = Infinity;
    
    for (let iter = 0; iter < MAX_ITER; iter++) {
      iterations = iter + 1;
      
      // Guard against near-zero denominator
      const denominator = Hmax - Hmin;
      
      let T_new;
      if (Math.abs(denominator) < ZERO_DENOMINATOR_THRESHOLD) {
        // Hmax â‰ˆ Hmin - use bisection instead of regula falsi
        T_new = (Tmin + Tmax) / 2;
      } else {
        // Regula falsi step
        T_new = Tmin - (Hmin - H_target_Jps) * (Tmax - Tmin) / denominator;
      }
      
      // Ensure T_new is within bounds
      const T_clamped = Math.max(Tmin + 0.01, Math.min(Tmax - 0.01, T_new));
      
      const H_new = Hcalc(T_clamped);
      const error = H_new - H_target_Jps;
      residual = error;
      
      // CRITICAL: Convergence based on residual, not iterations
      if (Math.abs(error) < TOL) {
        T_solution = T_clamped;
        break;
      }
      
      // Update bracket
      if (error * (Hmin - H_target_Jps) > 0) {
        Tmin = T_clamped;
        Hmin = H_new;
      } else {
        Tmax = T_clamped;
        Hmax = H_new;
      }
      
      // Bisection fallback if bracket gets too narrow
      if (Tmax - Tmin < 0.01) {
        T_solution = (Tmin + Tmax) / 2;
        // Recompute residual at chosen T
        const H_final = Hcalc(T_solution);
        residual = H_final - H_target_Jps;
        break;
      }
    }
    
    // If no solution found, use midpoint
    if (!T_solution) {
      T_solution = (Tmin + Tmax) / 2;
      const H_final = Hcalc(T_solution);
      residual = H_final - H_target_Jps;
      console.warn(`PH flash did not converge after ${MAX_ITER} iterations. Using T=${T_solution.toFixed(2)}K (residual=${(residual/1000).toFixed(3)} kW)`);
    }
    
    // Final flash at solution temperature
    const finalStream = {
      type: StreamType.MATERIAL,
      T: T_solution,
      P: P_Pa,
      n: { ...n },
      phaseConstraint
    };
    
    const flashResult = this.tpFlash(finalStream);
    
    // CRITICAL: Convergence based on residual, not iterations
    const converged = Math.abs(residual) < TOL;
    
    return {
      phase: flashResult.phase,
      beta: flashResult.beta,
      vaporFraction: flashResult.vaporFraction || flashResult.beta,
      x: flashResult.x,
      y: flashResult.y,
      nL: flashResult.nL,
      nV: flashResult.nV,
      T_K: T_solution,
      iterations,
      converged,
      bracketed: true,  // If we got here, it was bracketed
      residual_Jps: residual,
      Tmin_K: Tmin,
      Tmax_K: Tmax,
      warning: converged ? undefined : `PH flash residual ${(residual/1000).toFixed(3)} kW exceeds tolerance ${(TOL/1000).toFixed(3)} kW`
    };
  }
  
  /**
   * Find saturation temperature at given pressure by inverting Antoine equation
   * Uses bisection on Psat(T) = P_target
   * 
   * CRITICAL: Must handle cryogenic fluids where Tc << 200K
   * Returns null if no valid Tsat can be found (supercritical, no Antoine data, etc.)
   * 
   * @private
   * @param {string} comp - Component formula
   * @param {number} P_Pa - Target pressure in Pa
   * @returns {number|null} Saturation temperature in K, or null
   */
  _findSaturationTemperature(comp, P_Pa) {
    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.antoine) {
      return null;
    }
    
    // Supercritical check: if P > Pc, no saturation temperature exists
    if (compData.Pc && P_Pa > compData.Pc) {
      return null;
    }
    
    // Use bracketed search to invert Psat(T) = P
    const targetPsat = P_Pa;
    
    // Adaptive lower bound: use triple point (Tm), or fraction of Tb, or absolute minimum
    // Must be well below Tc for the bracket to contain Tsat
    let Tmin = Math.max(10, compData.Tm || (compData.Tb ? compData.Tb * 0.4 : 10));
    let Tmax = compData.Tc || 1000;  // K - critical temperature is the upper limit for VLE
    
    // Guard: if bracket is inverted or degenerate, cannot solve
    if (Tmin >= Tmax) {
      console.warn(`_findSaturationTemperature: Tmin (${Tmin.toFixed(1)}K) >= Tmax (${Tmax.toFixed(1)}K) for ${comp}`);
      return null;
    }
    
    const MAX_ITER = 50;
    const TOL = 1;  // Pa
    
    for (let iter = 0; iter < MAX_ITER; iter++) {
      const Tmid = (Tmin + Tmax) / 2;
      const Psat = this.saturationPressure(comp, Tmid);
      
      if (!Psat) return null;
      
      const error = Psat - targetPsat;
      
      if (Math.abs(error) < TOL) {
        return Tmid;
      }
      
      if (error > 0) {
        // Psat too high, decrease T
        Tmax = Tmid;
      } else {
        // Psat too low, increase T
        Tmin = Tmid;
      }
      
      if (Tmax - Tmin < 0.01) {
        return (Tmin + Tmax) / 2;
      }
    }
    
    return (Tmin + Tmax) / 2;
  }
  
  /**
   * Solve for temperature given target molar enthalpy in single phase
   * Uses bisection search on h(T) = h_target
   * 
   * Returns a result object with convergence metadata (matches _phFlash_General contract)
   * 
   * @private
   * @param {string} comp - Component formula
   * @param {number} P_Pa - Pressure in Pa
   * @param {number} h_target - Target molar enthalpy in J/mol
   * @param {string} phase - 'V' or 'L'
   * @param {number} Tmin - Lower temperature bound (K)
   * @param {number} Tmax - Upper temperature bound (K)
   * @returns {{T_K: number, converged: boolean, residual: number, iterations: number, bracketed: boolean, warning?: string}}
   */
  _solveTemperatureForEnthalpy(comp, P_Pa, h_target, phase, Tmin, Tmax) {
    const MAX_ITER = 50;
    const TOL = 1;  // J/mol
    
    // Guard: inverted bracket
    if (Tmin >= Tmax) {
      console.warn(`_solveTemperatureForEnthalpy: Tmin (${Tmin.toFixed(1)}K) >= Tmax (${Tmax.toFixed(1)}K) for ${comp}`);
      return { T_K: (Tmin + Tmax) / 2, converged: false, residual: NaN, iterations: 0, bracketed: false,
               warning: `Invalid temperature bracket [${Tmin.toFixed(1)}, ${Tmax.toFixed(1)}] K` };
    }
    
    // Check bracketing: is h_target between h(Tmin) and h(Tmax)?
    const h_lo = this.hMolar(comp, Tmin, P_Pa, phase);
    const h_hi = this.hMolar(comp, Tmax, P_Pa, phase);
    const bracketed = (h_target - h_lo) * (h_target - h_hi) <= 0;
    
    if (!bracketed) {
      // Target is outside achievable range â€” return closest endpoint
      const dist_lo = Math.abs(h_lo - h_target);
      const dist_hi = Math.abs(h_hi - h_target);
      const T_best = (dist_lo < dist_hi) ? Tmin : Tmax;
      const h_best = (dist_lo < dist_hi) ? h_lo : h_hi;
      const residual = h_best - h_target;
      
      return { T_K: T_best, converged: false, residual, iterations: 0, bracketed: false,
               warning: `Target molar enthalpy ${h_target.toFixed(1)} J/mol outside achievable range [${h_lo.toFixed(1)}, ${h_hi.toFixed(1)}] J/mol` };
    }
    
    // Bisection loop
    let residual = Infinity;
    let iterations = 0;
    
    for (let iter = 0; iter < MAX_ITER; iter++) {
      iterations = iter + 1;
      const Tmid = (Tmin + Tmax) / 2;
      const h_mid = this.hMolar(comp, Tmid, P_Pa, phase);
      
      residual = h_mid - h_target;
      
      if (Math.abs(residual) < TOL) {
        return { T_K: Tmid, converged: true, residual, iterations, bracketed: true };
      }
      
      // Enthalpy increases with T
      if (residual > 0) {
        // h too high, decrease T
        Tmax = Tmid;
      } else {
        // h too low, increase T
        Tmin = Tmid;
      }
      
      if (Tmax - Tmin < 0.01) {
        const T_final = (Tmin + Tmax) / 2;
        residual = this.hMolar(comp, T_final, P_Pa, phase) - h_target;
        return { T_K: T_final, converged: Math.abs(residual) < TOL, residual, iterations, bracketed: true };
      }
    }
    
    const T_final = (Tmin + Tmax) / 2;
    residual = this.hMolar(comp, T_final, P_Pa, phase) - h_target;
    return { T_K: T_final, converged: Math.abs(residual) < TOL, residual, iterations, bracketed: true,
             warning: `Bisection did not converge after ${MAX_ITER} iterations. Residual: ${residual.toFixed(3)} J/mol` };
  }
  
  
  /** Saturation pressure [Pa] â€” delegated to active thermo package */
  saturationPressure(comp, T_K) {
    return this._pkg.saturationPressure(comp, T_K);
  }
  
  /**
   * Authoritative saturation temperature calculation (inverse Antoine)
   * 
   * Given pressure, find temperature where Psat(T) = P
   * Uses same range selection logic as saturationPressure
   * 
   * @param {string} comp - Component formula
   * @param {number} P_Pa - Pressure in Pa
   * @returns {number} Saturation temperature in K, or null if no Antoine data
   */
  saturationTemperature(comp, P_Pa) {
    const compData = ComponentRegistry.get(comp);
    if (!compData || !compData.antoine) {
      console.warn(`No Antoine coefficients for ${comp}`);
      return null;
    }
    
    const P_mmHg = P_Pa / 133.322;  // Pa to mmHg
    const log10_P = Math.log10(P_mmHg);
    
    let antoineData = compData.antoine;
    
    // For multiple ranges, need to determine which range applies
    // Simple heuristic: try each range and pick the first valid one
    if (Array.isArray(antoineData)) {
      let T_sat = null;
      for (const range of antoineData) {
        // Inverse Antoine: T[Â°C] = B/(A - log10(P)) - C
        const T_C = range.B / (range.A - log10_P) - range.C;
        const T_K = T_C + 273.15;
        
        // Check if this T is within the range
        if (T_K >= range.Tmin && T_K <= range.Tmax) {
          T_sat = T_K;
          break;
        }
      }
      
      // If no range matched, use first range and warn
      if (T_sat === null) {
        const range = antoineData[0];
        const T_C = range.B / (range.A - log10_P) - range.C;
        T_sat = T_C + 273.15;
        
        const warnKey = `${comp}-tsat-outofrange`;
        if (!this._warnedRanges.has(warnKey)) {
          console.warn(`Tsat calculation for ${comp} at P=${(P_Pa/1e5).toFixed(2)} bar outside all Antoine ranges`);
          this._warnedRanges.add(warnKey);
        }
      }
      return T_sat;
    } else {
      // Single range: compute directly
      const T_C = antoineData.B / (antoineData.A - log10_P) - antoineData.C;
      return T_C + 273.15;
    }
  }
  
  /**
   * Check if a two-phase split is actually defined
   * A split is considered defined if nV and nL exist and sum to nTot within tolerance
   * @param {Object} stream - Stream with n, nV, nL
   * @returns {boolean} True if split is valid and defined
   */
  _isVLSplitDefined(stream) {
    if (!stream.nV || !stream.nL) return false;
    
    const nTot = Object.values(stream.n || {}).reduce((sum, n) => sum + n, 0);
    const nV_tot = Object.values(stream.nV).reduce((sum, n) => sum + n, 0);
    const nL_tot = Object.values(stream.nL).reduce((sum, n) => sum + n, 0);
    
    const TOLERANCE = 1e-6;  // mol/s
    const diff = Math.abs((nV_tot + nL_tot) - nTot);
    
    return diff < TOLERANCE && nTot > 1e-12;
  }
  
  /**
   * Stream heat capacity (mixture)
   * Accounts for phase of each component
   * 
   * INTERNAL UNITS: Returns J/s/K (not kW/K)
   * For UI display, use: formatPower_kW(Cp_J_s_K * deltaT) / deltaT
   * 
   * @param {Object} stream - {T: K, P: Pa, n: {comp: mol/s}, phase: 'V'|'L'|'VL'}
   * @returns {number} Total heat capacity in J/s/K
   */
  streamCp(stream) {
    let Cp_total_J_s_K = 0;
    
    // For single-phase streams
    if (stream.phase === 'V' || stream.phase === 'L') {
      for (const [comp, n_mols] of Object.entries(stream.n)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, stream.phase);
        Cp_total_J_s_K += n_mols * Cp_J_molK;  // mol/s * J/(molÂ·K) = J/s/K
      }
      return Cp_total_J_s_K;
    }
    
    // For two-phase streams (VL) - only if split is defined
    if (stream.phase === 'VL' && this._isVLSplitDefined(stream)) {
      // Vapor contribution
      for (const [comp, n_mols] of Object.entries(stream.nV)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, 'V');
        Cp_total_J_s_K += n_mols * Cp_J_molK;
      }
      // Liquid contribution
      for (const [comp, n_mols] of Object.entries(stream.nL)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, 'L');
        Cp_total_J_s_K += n_mols * Cp_J_molK;
      }
      return Cp_total_J_s_K;
    }
    
    // Fallback for VL with undefined split
    if (stream.phase === 'VL') {
      console.warn('VL phase with undefined quality - using liquid phase for Cp (PH flash required)');
      
      // CRITICAL: Use normalizeSinglePhaseHint to prevent passing 'VL' to cpMolar
      // stream.phaseConstraint might be 'VL', which is invalid for single-phase functions
      const fallbackPhase = this.normalizeSinglePhaseHint(stream.phaseConstraint, 'L');
      
      for (const [comp, n_mols] of Object.entries(stream.n)) {
        const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, fallbackPhase);
        Cp_total_J_s_K += n_mols * Cp_J_molK;
      }
      return Cp_total_J_s_K;
    }
    
    // Final fallback: assume vapor if no phase info
    for (const [comp, n_mols] of Object.entries(stream.n)) {
      const Cp_J_molK = this.cpMolar(comp, stream.T, stream.P, 'V');
      Cp_total_J_s_K += n_mols * Cp_J_molK;
    }
    return Cp_total_J_s_K;
  }
  
  /**
   * Stream mass flow (mixture)
   * @param {Object} stream - {n: {comp: mol/s}}
   * @returns {number} Total mass flow in kg/s
   */
  streamMassFlow(stream) {
    let m_total_kgs = 0;
    for (const [comp, n_mols] of Object.entries(stream.n)) {
      const MW = this.getComponentProp(comp, 'MW');  // g/mol
      m_total_kgs += n_mols * MW / 1000;  // kg/s
    }
    return m_total_kgs;
  }
  
  /**
   * P0.1 FIX: Stream volumetric flow via package (not inline PV=nRT)
   * Vapor uses compressibility Z from package (IG: Z=1, PR: Z from EOS)
   * Liquid uses density from package
   * @param {Object} stream - Material stream with T, P, n, phase, nV, nL
   * @returns {number} Volumetric flow in mÂ³/s
   */
  streamVolFlow_m3ps(stream) {
    if (!stream || !stream.n) return 0;
    const R = 8.314;  // J/(molÂ·K)
    
    const calcVaporVol = (n_map, T, P) => {
      const nV = Object.values(n_map).reduce((a, b) => a + b, 0);
      if (nV < 1e-15) return 0;
      // Z factor from package (ideal gas: Z=1)
      const Z = this.pkg.compressibilityZ 
        ? this.pkg.compressibilityZ(n_map, T, P) 
        : 1.0;
      return nV * Z * R * T / P;
    };
    
    const calcLiquidVol = (n_map, T, P) => {
      let vol = 0;
      for (const [comp, n] of Object.entries(n_map)) {
        if (n < 1e-15) continue;
        const rho = this.density(comp, T, P, 'L');
        const MW = this.getComponentProp(comp, 'MW');
        vol += n * (MW / 1000) / rho;
      }
      return vol;
    };
    
    if (stream.phase === 'V') {
      return calcVaporVol(stream.n, stream.T, stream.P);
    } else if (stream.phase === 'L') {
      return calcLiquidVol(stream.n, stream.T, stream.P);
    } else if (stream.phase === 'VL' && stream.nV && stream.nL) {
      return calcVaporVol(stream.nV, stream.T, stream.P)
           + calcLiquidVol(stream.nL, stream.T, stream.P);
    }
    // Fallback: treat as vapor
    return calcVaporVol(stream.n, stream.T, stream.P);
  }
  
  /**
   * P0.3 FIX: Compressor work calculation via thermo package
   * Keeps ideal-gas isentropic relations in the package, not in the unit.
   * Future PR EOS will override with s(T,P)-based isentropic calculation.
   * 
   * @param {Object} inStream - Inlet material stream {T, P, n, phase}
   * @param {number} Pout - Outlet pressure in Pa
   * @param {number} eta - Isentropic efficiency (0-1)
   * @returns {Object} {W_isentropic_W, W_shaft_W, H_target_Jps, T_isentropic_K, gammaMix, cpMix}
   */
  computeCompressorWork(inStream, Pout, eta) {
    const R = 8.314;
    const nTotal = Object.values(inStream.n).reduce((a, b) => a + b, 0);
    
    // Mixture Cp via package
    let cpMix = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const xi = n / nTotal;
      cpMix += xi * this.cpMolar(comp, inStream.T, inStream.P, 'V');
    }
    
    // Ideal gas: gamma = Cp/(Cp-R), isentropic T-P relation
    // PR EOS would override this entire method with entropy-based calc
    const cvMix = cpMix - R;
    const gammaMix = cpMix / cvMix;
    const ratio = Pout / inStream.P;
    
    const T_isentropic_K = inStream.T * Math.pow(ratio, (gammaMix - 1) / gammaMix);
    const W_isentropic_W = nTotal * cpMix * (T_isentropic_K - inStream.T);  // W (J/s)
    const W_shaft_W = W_isentropic_W / eta;
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps + W_shaft_W;
    
    return {
      W_isentropic_W,
      W_shaft_W,
      H_in_Jps,
      H_target_Jps,
      T_isentropic_K,
      gammaMix,
      cpMix
    };
  }
  
  /**
   * Pump work calculation via thermo package
   * Incompressible liquid: W = VÂ·Î”P / Î·
   * @param {Object} inStream - Inlet material stream
   * @param {number} Pout - Outlet pressure in Pa
   * @param {number} eta - Efficiency (0-1)
   * @returns {Object} {W_hydraulic_W, W_shaft_W, H_target_Jps, V_m3ps}
   */
  computePumpWork(inStream, Pout, eta) {
    let V_m3ps = 0;
    for (const [comp, n] of Object.entries(inStream.n)) {
      const rho = this.density(comp, inStream.T, inStream.P, 'L');
      const MW = this.getComponentProp(comp, 'MW');
      V_m3ps += n * (MW / 1000) / rho;
    }
    
    const deltaP = Pout - inStream.P;
    const W_hydraulic_W = V_m3ps * deltaP;  // W (J/s) = mÂ³/s Ã— Pa
    const W_shaft_W = W_hydraulic_W / eta;
    
    const H_in_Jps = this.getHdot_Jps(inStream);
    const H_target_Jps = H_in_Jps + W_shaft_W;
    
    return {
      W_hydraulic_W,
      W_shaft_W,
      H_in_Jps,
      H_target_Jps,
      V_m3ps
    };
  }
}

// Global thermo adapter instance
// Instantiate default package and thermo adapter
const idealRaoultPkg = new IdealRaoultPackage();
const pengRobinsonPkg = new PengRobinsonPackage();
const thermo = new ThermoAdapter(idealRaoultPkg);

// =============================================================================
// UI FORMATTING HELPERS
// =============================================================================
// These functions convert internal units (J/s, J/mol, J/s/K) to display units (kW, kJ/mol, kW/K)
// CRITICAL: Internal calculations must NEVER use these - they are for display ONLY

/**
 * Format power (enthalpy flow rate) for UI display
 * @param {number} Hdot_J_s - Power in J/s (internal unit)
 * @param {number} decimals - Number of decimal places (default: 2)
 * @returns {string} Formatted string "X.XX kW"
 */
function formatPower_kW(Hdot_J_s, decimals = 2) {
  if (Hdot_J_s === undefined || Hdot_J_s === null || isNaN(Hdot_J_s)) {
    return 'N/A';
  }
  return (Hdot_J_s / 1000).toFixed(decimals);
}

/**
 * Format molar enthalpy for UI display
 * @param {number} h_J_mol - Molar enthalpy in J/mol (internal unit)
 * @param {number} decimals - Number of decimal places (default: 2)
 * @returns {string} Formatted string "X.XX kJ/mol"
 */
function formatEnthalpy_kJmol(h_J_mol, decimals = 2) {
  if (h_J_mol === undefined || h_J_mol === null || isNaN(h_J_mol)) {
    return 'N/A';
  }
  return (h_J_mol / 1000).toFixed(decimals);
}

/**
 * Format heat capacity for UI display
 * @param {number} Cp_J_s_K - Heat capacity in J/s/K (internal unit)
 * @param {number} decimals - Number of decimal places (default: 2)
 * @returns {string} Formatted string "X.XX kW/K"
 */
function formatHeatCapacity_kWK(Cp_J_s_K, decimals = 2) {
  if (Cp_J_s_K === undefined || Cp_J_s_K === null || isNaN(Cp_J_s_K)) {
    return 'N/A';
  }
  return (Cp_J_s_K / 1000).toFixed(decimals);
}


/* =========================
   MODEL IMPLEMENTATIONS
   ========================= */

// PVT Models (Pressure-Volume-Temperature)
// =============================================================================
// LEGACY MODELS REMOVED (v1.5.0 - Architecture Cleanup)
// =============================================================================
// The following models have been REMOVED to enforce single-entrypoint architecture:
//
// 1. pvt_gas (ideal): Mixed units (T+273.15 violation), bypassed ComponentRegistry
// 2. thermo (constant_cp): Hardcoded Cp values, bypassed ComponentRegistry
// 3. water_psat (antoine): Water-specific, Â°C units, bypassed ThermoAdapter
// 4. humidity (simple): Water-specific, called water_psat directly
// 5. pvt_liquid (incompressible): Hardcoded densities, bypassed ComponentRegistry
// 6. vle (raoult): Direct antoine.A/B/C access (BREAKS multi-range!), bypassed ThermoAdapter
// 7. flash (successive_substitution): Complex dependencies, ThermoAdapter has better impl
//
// ALL thermodynamic calculations MUST go through ThermoAdapter.
// =============================================================================

// Heat Exchanger
models.register('hx', {
  id: 'cop_cooling',
  name: 'COP cooling',
  desc: 'COP = Q_cooling / W_electric',
  coolingPower(QkW_electric, COP) { 
    return QkW_electric * COP; 
  }
});

// Pressure Drop
models.register('pressure_drop', {
  id: 'none',
  name: 'No Î”P',
  desc: 'P_out = P_in',
  deltaPFraction() { return 0; }
});


// Thermo Packages
models.register('thermo_package', idealRaoultPkg);
models.register('thermo_package', pengRobinsonPkg);

// Unit Systems
// Unit Systems - SI (bar) is default
models.register('units', {
  id: 'SI_bar',
  name: 'SI (bar)',
  desc: 'Temperature (Â°C), Pressure (bar), Flow (mol/h, kg/h, mÂ³/h)',
  
  temperature: { from: (K) => K - 273.15, to: (C) => C + 273.15, symbol: 'Â°C', decimals: 1 },
  pressure: { from: (Pa) => Pa / 100000, to: (bar) => bar * 100000, symbol: 'bar', decimals: 3 },
  molarFlow: { from: (mols) => mols * 3600, to: (molh) => molh / 3600, symbol: 'mol/h', decimals: 1 },
  massFlow: { from: (kgs) => kgs * 3600, to: (kgh) => kgh / 3600, symbol: 'kg/h', decimals: 2 },
  volumeFlow: { from: (m3s) => m3s * 3600, to: (m3h) => m3h / 3600, symbol: 'mÂ³/h', decimals: 2 }
});

models.register('units', {
  id: 'SI',
  name: 'SI Units',
  desc: 'Temperature (K), Pressure (Pa), Flow (mol/s, kg/s, mÂ³/s)',
  
  temperature: { from: (K) => K, to: (K) => K, symbol: 'K', decimals: 2 },
  pressure: { from: (Pa) => Pa, to: (Pa) => Pa, symbol: 'Pa', decimals: 0 },
  molarFlow: { from: (mols) => mols, to: (mols) => mols, symbol: 'mol/s', decimals: 3 },
  massFlow: { from: (kgs) => kgs, to: (kgs) => kgs, symbol: 'kg/s', decimals: 4 },
  volumeFlow: { from: (m3s) => m3s, to: (m3s) => m3s, symbol: 'mÂ³/s', decimals: 4 }
});

models.register('units', {
  id: 'Imperial',
  name: 'Imperial Units',
  desc: 'Temperature (Â°F), Pressure (psi), Flow (lbmol/h, lb/h, ftÂ³/h)',
  
  temperature: { 
    from: (K) => (K - 273.15) * 9/5 + 32, 
    to: (F) => (F - 32) * 5/9 + 273.15, 
    symbol: 'Â°F', 
    decimals: 1 
  },
  pressure: { 
    from: (Pa) => Pa / 6894.76, 
    to: (psi) => psi * 6894.76, 
    symbol: 'psi', 
    decimals: 2 
  },
  molarFlow: { 
    from: (mols) => mols * 3600 / 453.592, 
    to: (lbmolh) => lbmolh * 453.592 / 3600, 
    symbol: 'lbmol/h', 
    decimals: 1 
  },
  massFlow: { 
    from: (kgs) => kgs * 3600 * 2.20462, 
    to: (lbh) => lbh / 2.20462 / 3600, 
    symbol: 'lb/h', 
    decimals: 1 
  },
  volumeFlow: { 
    from: (m3s) => m3s * 3600 * 35.3147, 
    to: (ft3h) => ft3h / 35.3147 / 3600, 
    symbol: 'ftÂ³/h', 
    decimals: 1 
  }
});

/* =========================
   ERROR SEVERITY SYSTEM
   Categorizes operational errors by damage level
   ========================= */
const ErrorSeverity = {
  MINOR: { 
    icon: 'âš ï¸', 
    color: '#fbbf24', 
    prefix: 'WARNING',
    level: 1
  },
  MAJOR: { 
    icon: 'ðŸ”§', 
    color: '#f97316', 
    prefix: 'MAJOR DAMAGE',
    level: 2
  },
  CATASTROPHIC: { 
    icon: 'ðŸ’¥', 
    color: '#ef4444', 
    prefix: 'CATASTROPHIC',
    level: 3
  }
};

/* =========================
   ERROR CATALOG & DIAGNOSIS
   Natural language explanations for common failures
   ========================= */
const ErrorCatalog = {
  // Catastrophic failures
  'compressor.*liquid': {
    severity: ErrorSeverity.CATASTROPHIC,
    title: 'Compressor Destroyed',
    explanation: 'Compressors are designed to handle gases, not liquids. When liquid enters a compressor, it cannot be compressed and causes immediate mechanical failure. Think of it like trying to compress water in a sealed cylinder - the incompressible liquid will destroy the compression mechanism.',
    causes: [
      'Upstream condenser or cooler dropped temperature below dew point',
      'Feed stream is liquid or two-phase with high liquid fraction',
      'Insufficient separation before compression',
      'Temperature control failure upstream'
    ],
    fixes: [
      'Add a knockout drum or separator before the compressor',
      'Ensure feed temperature is above dew point',
      'Check flash calculation results - inlet should show vapor phase',
      'Add heating if stream is too cold'
    ]
  },
  
  // Major damage
  'pump.*cavitation.*vapor': {
    severity: ErrorSeverity.MAJOR,
    title: 'Pump Cavitation',
    explanation: 'Pumps are designed for liquids and cannot handle vapor. When vapor enters a pump, cavitation occurs - the formation and collapse of vapor bubbles that physically damage the pump impeller. This causes vibration, noise, reduced efficiency, and mechanical wear.',
    causes: [
      'Feed stream is vapor or two-phase with high vapor fraction',
      'Upstream heater raised temperature above bubble point',
      'Pressure drop upstream caused flashing',
      'Insufficient NPSH (Net Positive Suction Head)'
    ],
    fixes: [
      'Ensure feed is subcooled liquid',
      'Add cooling if stream is too hot',
      'Check flash results - inlet should show liquid phase',
      'Increase system pressure or decrease temperature'
    ]
  },
  
  // Configuration warnings
  'power.*overload': {
    severity: ErrorSeverity.MINOR,
    title: 'Power Source Overload',
    explanation: 'The electrical or mechanical power demand exceeds the available capacity from the power source. The connected equipment cannot operate properly without sufficient power supply.',
    causes: [
      'Power source capacity too small for connected load',
      'Too many units connected to single power source',
      'Compression ratio or pressure rise too high',
      'Motor efficiency losses not accounted for'
    ],
    fixes: [
      'Increase power source max capacity',
      'Add additional power sources',
      'Reduce compression ratio or pressure rise',
      'Check motor efficiency parameter'
    ]
  },
  
  'no.*input': {
    severity: ErrorSeverity.MINOR,
    title: 'Missing Input Connection',
    explanation: 'This unit requires an input stream but none is connected. Process equipment needs material or power feeds to operate.',
    causes: [
      'Unit was just added and not yet connected',
      'Connection was deleted',
      'Upstream unit missing or disconnected'
    ],
    fixes: [
      'Connect an appropriate input stream',
      'Add upstream source or equipment',
      'Check unit ports match stream types (material, power, etc.)'
    ]
  },
  
  'no.*output': {
    severity: ErrorSeverity.MINOR,
    title: 'No Output Connection',
    explanation: 'This unit has no outlet stream. While not necessarily an error, process streams typically need destinations.',
    causes: [
      'Unit was just added and not yet connected',
      'Downstream equipment missing',
      'This is an endpoint (sink) and this is normal'
    ],
    fixes: [
      'Add downstream equipment or sink',
      'Connect outlet to next process step',
      'If this is intentional, no action needed'
    ]
  },
  
  'temperature.*cross': {
    severity: ErrorSeverity.MAJOR,
    title: 'Heat Exchanger Temperature Cross',
    explanation: 'In a heat exchanger, the hot stream cannot exit colder than the cold stream inlet (and vice versa). This violates the second law of thermodynamics and indicates impossible heat transfer.',
    causes: [
      'Specified outlet temperatures are thermodynamically infeasible',
      'Approach temperature is too small or negative',
      'Heat capacity imbalance too extreme',
      'Stream flow rates or properties changed'
    ],
    fixes: [
      'Increase approach temperature (typically 5-20K)',
      'Adjust hot or cold outlet temperature targets',
      'Check stream flow rates and heat capacities',
      'Use effectiveness mode instead of fixed outlet temps'
    ]
  },
  
  'thermodynamic.*violation.*heat': {
    severity: ErrorSeverity.CATASTROPHIC,
    title: 'Thermodynamic Violation in Heat Transfer',
    explanation: 'Heat is flowing in the wrong direction! The hot stream is gaining heat or the cold stream is losing heat. This violates the second law of thermodynamics and is physically impossible.',
    causes: [
      'Outlet temperature set higher than inlet for hot stream',
      'Outlet temperature set lower than inlet for cold stream',
      'Severe numerical error in calculation',
      'Wrong stream assignment (hot/cold swapped)'
    ],
    fixes: [
      'Check that hot inlet > hot outlet',
      'Check that cold outlet > cold inlet',
      'Verify stream connections are correct',
      'Use approach temperature mode for automatic calculation'
    ]
  }
};

// Diagnose errors from scene state
function diagnoseErrors(scene) {
  const diagnostics = [];
  
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const ud = scene.runtime.unitData.get(id);
    
    // Check for unit-level errors
    if (ud?.last?.error) {
      const errorMsg = ud.last.error.message.toLowerCase();
      
      // Match against catalog
      for (const [pattern, info] of Object.entries(ErrorCatalog)) {
        const regex = new RegExp(pattern, 'i');
        if (regex.test(errorMsg)) {
          diagnostics.push({
            unitId: id,
            unitName: u.name || def.name,
            ...info,
            originalMessage: ud.last.error.message
          });
          break;
        }
      }
    }
    
    // Check for missing connections
    if (def.ports && def.ports.length > 0) {
      // Check inputs
      const inputPorts = def.ports.filter(p => p.dir === PortDir.IN);
      const outputPorts = def.ports.filter(p => p.dir === PortDir.OUT);
      
      for (const port of inputPorts) {
        const hasConnection = scene.connections.some(
          c => c.to.unitId === id && c.to.portId === port.portId
        );
        if (!hasConnection && def.defId !== 'source' && def.defId !== 'battery' && def.defId !== 'source_mechanical') {
          diagnostics.push({
            unitId: id,
            unitName: u.name || def.name,
            ...ErrorCatalog['no.*input'],
            originalMessage: `No input connected to ${port.portId}`
          });
        }
      }
      
      // Check outputs (warning only, not critical)
      for (const port of outputPorts) {
        const hasConnection = scene.connections.some(
          c => c.from.unitId === id && c.from.portId === port.portId
        );
        if (!hasConnection && def.defId !== 'sink') {
          // This is less critical, only add if there are no other errors for this unit
          const hasOtherError = diagnostics.some(d => d.unitId === id);
          if (!hasOtherError) {
            diagnostics.push({
              unitId: id,
              unitName: u.name || def.name,
              ...ErrorCatalog['no.*output'],
              originalMessage: `No output connected from ${port.portId}`
            });
          }
        }
      }
    }
  }
  
  return diagnostics;
}

/* =========================
   UNIT CATEGORIES
   Categories for organizing units with color coding
   ========================= */
const UnitCategories = {
  // Material sources
  SOURCE: { name: 'Sources', color: '#10b981' },      // Green
  
  // Material sinks  
  SINK: { name: 'Sinks', color: '#6366f1' },          // Indigo
  
  // Power sources
  POWER_SOURCE: { name: 'Power Sources', color: '#eab308' },  // Yellow
  
  // Power conversion
  POWER_CONVERSION: { name: 'Power Conversion', color: '#f59e0b' }, // Orange
  
  // Pressure change equipment
  PRESSURE: { name: 'Pressure Change', color: '#8b5cf6' }, // Purple
  
  // Heat exchangers
  HEAT_EXCHANGER: { name: 'Heat Exchangers', color: '#3b82f6' }, // Blue
  
  // Separators
  SEPARATOR: { name: 'Separators', color: '#ec4899' }, // Pink
  
  // Topology (mixers, splitters, tees)
  TOPOLOGY: { name: 'Topology', color: '#14b8a6' },    // Teal
  
  // Power management (hub, battery, power sink)
  POWER_MANAGEMENT: { name: 'Power Management', color: '#facc15' },  // Gold
  
  // Reactors
  REACTOR: { name: 'Reactors', color: '#ef4444' },    // Red
  
  // Test units
  TEST: { name: 'Test Units', color: '#64748b' }      // Slate
};

/* =========================
   UNIT REGISTRY
   Defines available unit operations
   
   STREAM TYPE SYSTEM:
   -------------------
   Each port MUST have a 'type' field that matches one of:
   - StreamType.MATERIAL  (for gas/liquid material streams)
   - StreamType.HEAT      (for heat transfer)
   - StreamType.MECHANICAL (for mechanical work)
   - StreamType.ELECTRICAL (for electrical power)
   
   Port definition format:
   { portId: 'unique_id', dir: PortDir.IN/OUT, type: StreamType.XXX, x: pos_x, y: pos_y }
   
   Stream object MUST have matching 'type' field:
   - MATERIAL: { type: StreamType.MATERIAL, phase: 'gas'/'liquid', T, P, nDot/mDot, comp }
   - HEAT: { type: StreamType.HEAT, QkW }
   - MECHANICAL: { type: StreamType.MECHANICAL, WkW }
   - ELECTRICAL: { type: StreamType.ELECTRICAL, QkW }
   
   Connections are only allowed between ports of the SAME type.
   The solver validates that streams produced match their port types.
   
   CATEGORY SYSTEM:
   ---------------
   Each unit belongs to a category from UnitCategories.
   Units in the same category share the same color.
   Category is displayed in the properties panel.
   ========================= */
class UnitRegistry {
  static _defs = new Map();

  static register(defId, spec) {
    const category = spec.category || UnitCategories.UTILITY;
    const def = {
      defId,
      name: spec.name,
      category: category.name,
      w: Math.max(2, spec.w || 2),  // Minimum 2x2 for better readability
      h: Math.max(2, spec.h || 2),
      color: category.color, // Color comes from category
      ports: spec.ports || [],
      tick: spec.tick || null
    };
    this._defs.set(defId, def);
  }

  static get(id) { 
    return this._defs.get(id); 
  }

  static list() { 
    return Array.from(this._defs.values()); 
  }
  
  static listByCategory() {
    const byCategory = {};
    for (const def of this._defs.values()) {
      const cat = def.category;
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push(def);
    }
    return byCategory;
  }
}

// Source - Generic material stream source
UnitRegistry.register('source', {
  name: 'Source',
  category: UnitCategories.SOURCE,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    // Create material stream with molar composition
    const n = {};
    n[par.species] = par.nDot;
    
    ports.out = {
      type: StreamType.MATERIAL,
      T: par.T + 273.15,  // Convert Â°C to K
      P: par.P,           // Already in Pa
      n: n,               // mol/s for each component
      phaseConstraint: par.phaseConstraint || 'VL' // User-controlled phase constraint
    };
  }
});

// Sink - Stream terminator
UnitRegistry.register('sink', {
  name: 'Sink',
  category: UnitCategories.SINK,
  w: 2,
  h: 2,
  ports: [{ portId: 'in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 }],
  tick(u, ports, par) { 
    // Store incoming stream info for display
    if (ports.in) {
      u.last = {
        stream: { ...ports.in }
      };
    }
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTERY â€” Electrical energy storage (discharge only, for now)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ PURPOSE                                                                    â”‚
// â”‚   Provides electrical power up to its rated capacity.                      â”‚
// â”‚   Behaviorally identical to a fixed-output generator: outputs its max      â”‚
// â”‚   capacity on every tick. The downstream system (hub or direct consumer)   â”‚
// â”‚   decides how much to actually draw.                                       â”‚
// â”‚                                                                            â”‚
// â”‚ PORTS                                                                      â”‚
// â”‚   out (ELECTRICAL, OUT) â€” available power in W                             â”‚
// â”‚                                                                            â”‚
// â”‚ PARAMETERS                                                                 â”‚
// â”‚   maxPower [kW] â€” rated discharge capacity (default: 1000 kW)             â”‚
// â”‚                                                                            â”‚
// â”‚ DESIGN NOTES                                                               â”‚
// â”‚   â€¢ The battery has NO demand-response logic. It is a dumb source.         â”‚
// â”‚   â€¢ When connected to a Power Hub, the hub controls dispatch:              â”‚
// â”‚     firm sources are drawn first, batteries fill the gap.                  â”‚
// â”‚   â€¢ When connected directly to a consumer (no hub), the consumer           â”‚
// â”‚     takes what it needs; excess capacity is simply unused.                 â”‚
// â”‚   â€¢ Charge management (SOC, charge/discharge cycles) is deferred to a     â”‚
// â”‚     future version. Currently the battery can only discharge.              â”‚
// â”‚                                                                            â”‚
// â”‚ INTERNAL UNITS                                                             â”‚
// â”‚   All internal values in W (J/s). par.maxPower is in kW (user-facing).    â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
UnitRegistry.register('battery', {
  name: 'Battery',
  category: UnitCategories.POWER_MANAGEMENT,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    const maxPower_W = (par.maxPower || 1000) * 1000;
    ports.out = {
      type: StreamType.ELECTRICAL,
      available: maxPower_W,
      demand: u._hubDemand_W || 0  // Preserve demand written by hub Step C
    };
    u.last = {
      maxPower_W: maxPower_W,
      type: 'battery'  // Hub uses this to identify dispatchable sources
    };
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POWER HUB â€” Electrical bus that balances supply and demand
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ PURPOSE                                                                    â”‚
// â”‚   Central switchboard that balances electrical supply and demand.           â”‚
// â”‚   Aggregates power from firm sources (generators, solar, etc.) and         â”‚
// â”‚   dispatchable sources (batteries), distributes to consumers, and          â”‚
// â”‚   routes surplus to a waste/accounting port.                               â”‚
// â”‚                                                                            â”‚
// â”‚ PORTS                                                                      â”‚
// â”‚   firm_in    (ELECTRICAL, IN,  multiConnect) â€” firm/non-dispatchable       â”‚
// â”‚   battery_in (ELECTRICAL, IN,  multiConnect) â€” dispatchable storage        â”‚
// â”‚   dist_out   (ELECTRICAL, OUT) â€” distribution bus to consumers             â”‚
// â”‚   surplus_out(ELECTRICAL, OUT) â€” excess power (â†’ sink, or unconnected)     â”‚
// â”‚                                                                            â”‚
// â”‚ PARAMETERS                                                                 â”‚
// â”‚   curtailmentMode ['proportional'] â€” strategy when supply < demand         â”‚
// â”‚     â€¢ 'proportional': each consumer gets demand_i Ã— (supply/demand)        â”‚
// â”‚     â€¢ (future: priority-based, shed-last, etc.)                            â”‚
// â”‚                                                                            â”‚
// â”‚ BALANCING ALGORITHM (runs in solver post-processing)                       â”‚
// â”‚   1. firm_supply   = Î£ available on firm_in connections                    â”‚
// â”‚   2. battery_max   = Î£ available on battery_in connections                 â”‚
// â”‚   3. total_demand  = Î£ powerDemand of consumers on dist_out               â”‚
// â”‚   4. battery_draw  = clamp(total_demand âˆ’ firm_supply, 0, battery_max)    â”‚
// â”‚   5. total_supply  = firm_supply + battery_draw                           â”‚
// â”‚   6. curtailment   = min(1, total_supply / total_demand)                  â”‚
// â”‚   7. surplus       = max(0, total_supply âˆ’ total_demand) â†’ surplus_out    â”‚
// â”‚                                                                            â”‚
// â”‚ DESIGN NOTES                                                               â”‚
// â”‚   â€¢ The hub is NOT required to operate equipment. A battery or generator   â”‚
// â”‚     can connect directly to a motor/heater. The hub is only needed when    â”‚
// â”‚     multiple sources and/or consumers must be arbitrated.                  â”‚
// â”‚   â€¢ surplus_out does not require a connection. If unconnected, surplus     â”‚
// â”‚     is simply logged in diagnostics.                                       â”‚
// â”‚   â€¢ The tick only aggregates inputs. All balancing logic runs in the       â”‚
// â”‚     solver's hub post-processing pass (after converter demand rollup).     â”‚
// â”‚                                                                            â”‚
// â”‚ INTERNAL UNITS                                                             â”‚
// â”‚   All values in W (J/s).                                                  â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
UnitRegistry.register('power_hub', {
  name: 'Power Hub',
  category: UnitCategories.POWER_MANAGEMENT,
  w: 2,
  h: 3,
  ports: [
    { portId: 'firm_in',     dir: PortDir.IN,  type: StreamType.ELECTRICAL, x: 0, y: 0, multiConnect: true },
    { portId: 'battery_in',  dir: PortDir.IN,  type: StreamType.ELECTRICAL, x: 0, y: 3, multiConnect: true },
    { portId: 'dist_out',    dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 0 },
    { portId: 'surplus_out', dir: PortDir.OUT, type: StreamType.ELECTRICAL, x: 2, y: 3 }
  ],
  tick(u, ports, par) {
    // Input ports arrive pre-merged by the solver (multiConnect aggregation).
    // Each is a single stream with available = sum of all connected sources.
    const firmIn = ports.firm_in;
    const battIn = ports.battery_in;
    
    const firmSupply_W    = firmIn ? (firmIn.available || 0) : 0;
    const batteryMax_W    = battIn ? (battIn.available || 0) : 0;
    const totalSupply_W   = firmSupply_W + batteryMax_W;
    
    // Forward pass: advertise supply on distribution port.
    // Use carried-forward value from Step C if available (converges across iterations).
    ports.dist_out = {
      type: StreamType.ELECTRICAL,
      available: u._hubDistAvail_W !== undefined ? u._hubDistAvail_W : totalSupply_W,
      demand: 0
    };
    
    // Surplus: use carried-forward value from Step C (defaults to 0 on first tick).
    // Step C updates u._hubSurplus_W after demand rollup.
    ports.surplus_out = {
      type: StreamType.ELECTRICAL,
      available: u._hubSurplus_W || 0,
      demand: 0
    };
    
    u.last = {
      firmSupply_W:      firmSupply_W,
      batteryMax_W:      batteryMax_W,
      totalCapacity_W:   totalSupply_W,  // Theoretical max (before dispatch)
      totalSupply_W:     totalSupply_W,  // Overwritten by post-processing
      totalDemand_W:     0,         // Set by post-processing
      batteryDraw_W:     0,         // Set by post-processing
      surplus_W:         0,         // Set by post-processing
      curtailmentFactor: 1.0,       // Set by post-processing
      curtailmentMode:   par.curtailmentMode || 'proportional'
    };
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ELECTRICAL SINK â€” Absorbs and accounts for electrical power
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ PURPOSE                                                                    â”‚
// â”‚   Terminates an electrical stream and logs the absorbed power.             â”‚
// â”‚   Typically connected to a Power Hub's surplus_out port to account for     â”‚
// â”‚   excess generation, but can be used standalone.                           â”‚
// â”‚                                                                            â”‚
// â”‚ PORTS                                                                      â”‚
// â”‚   in (ELECTRICAL, IN) â€” incoming power to absorb                           â”‚
// â”‚                                                                            â”‚
// â”‚ PARAMETERS                                                                 â”‚
// â”‚   (none)                                                                   â”‚
// â”‚                                                                            â”‚
// â”‚ DIAGNOSTICS                                                                â”‚
// â”‚   absorbed_W â€” total power absorbed (W)                                   â”‚
// â”‚                                                                            â”‚
// â”‚ INTERNAL UNITS                                                             â”‚
// â”‚   All values in W (J/s).                                                  â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
UnitRegistry.register('sink_electrical', {
  name: 'Electrical Sink',
  category: UnitCategories.POWER_MANAGEMENT,
  w: 2,
  h: 2,
  ports: [{ portId: 'in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 0, y: 1 }],
  tick(u, ports, par) {
    const sIn = ports.in;
    u.last = {
      absorbed_W: sIn ? (sIn.available || 0) : 0
    };
  }
});

// Mechanical Source - For testing/standalone mechanical systems
UnitRegistry.register('source_mechanical', {
  name: 'Mechanical Source',
  category: UnitCategories.POWER_SOURCE,
  w: 2,
  h: 2,
  ports: [{ portId: 'out', dir: PortDir.OUT, type: StreamType.MECHANICAL, x: 2, y: 1 }],
  tick(u, ports, par) {
    const maxPower_W = (par.maxPower || 1000) * 1000;
    ports.out = {
      type: StreamType.MECHANICAL,
      available: maxPower_W,  // W
      demand: 0
    };
  }
});

// Electric Motor - Converts electrical to mechanical power
UnitRegistry.register('motor', {
  name: 'Electric Motor',
  category: UnitCategories.POWER_CONVERSION,
  w: 2,
  h: 2,
  ports: [
    { portId: 'elec_in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 0, y: 1 },
    { portId: 'mech_out', dir: PortDir.OUT, type: StreamType.MECHANICAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const elecIn = ports.elec_in;
    if (!elecIn) return;
    
    const eta = par.eta || 0.92;
    const W_mech_W = elecIn.available * eta;  // All in W
    
    u.last = {
      W_elec_W: elecIn.available,
      W_mech_W: W_mech_W,
      eta: eta,
      efficiency_pct: (eta * 100).toFixed(1)
    };
    
    ports.mech_out = {
      type: StreamType.MECHANICAL,
      available: W_mech_W,  // W
      demand: 0
    };
  }
});

// Electric Heater - Converts electrical power to heat
UnitRegistry.register('electric_heater', {
  name: 'Electric Heater',
  category: UnitCategories.POWER_CONVERSION,
  w: 2,
  h: 2,
  ports: [
    { portId: 'elec_in', dir: PortDir.IN, type: StreamType.ELECTRICAL, x: 0, y: 1 },
    { portId: 'heat_out', dir: PortDir.OUT, type: StreamType.HEAT, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const elecIn = ports.elec_in;
    if (!elecIn) return;
    
    const eta = par.eta || 0.99;
    const Q_available_W = elecIn.available * eta;  // All in W
    
    u.last = {
      W_elec_available_W: elecIn.available,
      Q_available_W: Q_available_W,
      eta: eta,
      efficiency_pct: (eta * 100).toFixed(1)
    };
    
    ports.heat_out = {
      type: StreamType.HEAT,
      available: Q_available_W,  // W
      demand: 0
    };
  }
});

// Valve - Isenthalpic pressure reduction
UnitRegistry.register('valve', {
  name: 'Valve',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.in;
    if (!sIn) return;
    
    const Pout = par.Pout || 101325;
    
    // Check for pressure increase (valve can't do this)
    if (Pout > sIn.P) {
      u.last = {
        error: {
          severity: ErrorSeverity.MINOR,
          message: 'Outlet pressure higher than inlet - valve cannot increase pressure'
        }
      };
      return;
    }
    
    // ISENTHALPIC THROTTLING: H_in = H_out
    // Get inlet enthalpy (computed on-demand if not available)
    const H_in_Jps = thermo.getHdot_Jps(sIn);
    
    // Check if enthalpy computation failed (distinguish from valid zero at Tref)
    if (H_in_Jps === 0 && (!sIn.T || !sIn.P || !sIn.n)) {
      u.last = {
        error: {
          severity: ErrorSeverity.MAJOR,
          message: 'Cannot compute inlet enthalpy - missing stream properties'
        }
      };
      return;
    }
    
    ports.out = {
      type: StreamType.MATERIAL,
      P: Pout,
      n: { ...sIn.n },
      phaseConstraint: 'VL',  // Allow phase change
      H_target_Jps: H_in_Jps  // Guaranteed valid
    };
    
    u.last = {
      Pin: sIn.P,
      Pout: Pout,
      deltaP: sIn.P - Pout,
      ratio: (sIn.P / Pout).toFixed(2),
      mode: 'isenthalpic',
      H_in_kW: (H_in_Jps / 1000).toFixed(2)
    };
  }
});

// Pump - Raises liquid pressure
UnitRegistry.register('pump', {
  name: 'Pump',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'power_in', dir: PortDir.IN, type: StreamType.MECHANICAL, x: 1, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    const sPower = ports.power_in;
    if (!sIn) return;
    
    const Pout = par.Pout || (sIn.P + 500000);  // Default +5 bar
    const eta = par.eta || 0.70;
    
    // CRITICAL: Check for vapor (pumps need liquid!)
    if (sIn.phase === 'V' || (sIn.phase === 'VL' && sIn.vaporFraction > 0.1)) {
      u.last = {
        error: {
          severity: ErrorSeverity.MAJOR,
          message: 'Pump cavitation - vapor or two-phase at inlet (pump requires liquid)'
        }
      };
      return;
    }
    
    // Incompressible liquid assumption â€” delegate to ThermoAdapter (P0.3)
    const work = thermo.computePumpWork(sIn, Pout, eta);
    
    // ALWAYS report demand so hub/network can see it (even if power is insufficient)
    u.powerDemand = work.W_shaft_W;
    
    // Check if enough power available (all in W, P0.2)
    if (sPower && work.W_shaft_W > sPower.available + 1) {
      u.last = {
        error: {
          severity: ErrorSeverity.MINOR,
          message: `Insufficient power: need ${(work.W_shaft_W/1000).toFixed(1)} kW, available ${(sPower.available/1000).toFixed(1)} kW`
        },
        W_shaft: work.W_shaft_W,
        W_hydraulic: work.W_hydraulic_W
      };
      return;
    }
    
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: Pout,
      n: { ...sIn.n },
      phaseConstraint: 'L',
      H_target_Jps: work.H_target_Jps
    };
    
    u.last = {
      Pin: sIn.P,
      Pout: Pout,
      deltaP: Pout - sIn.P,
      V_m3h: work.V_m3ps * 3600,
      W_hydraulic: work.W_hydraulic_W,  // W
      W_shaft: work.W_shaft_W,          // W
      eta: eta,
      eta_pct: (eta * 100).toFixed(0),
      H_in_kW: (work.H_in_Jps / 1000).toFixed(2),
      H_out_kW: (work.H_target_Jps / 1000).toFixed(2)
    };
  }
});

// Compressor - Raises gas pressure
UnitRegistry.register('compressor', {
  name: 'Compressor',
  category: UnitCategories.PRESSURE,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'power_in', dir: PortDir.IN, type: StreamType.MECHANICAL, x: 1, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    const sPower = ports.power_in;
    if (!sIn) return;
    
    const Pout = par.Pout || (sIn.P * 2);  // Default 2Ã— compression
    const eta = par.eta || 0.75;
    
    // CRITICAL: Check for liquid (compressors destroy with liquid!)
    if (sIn.phase === 'L' || (sIn.phase === 'VL' && sIn.vaporFraction < 0.9)) {
      u.last = {
        error: {
          severity: ErrorSeverity.CATASTROPHIC,
          message: 'Compressor destroyed by liquid ingestion (compressor requires vapor)'
        }
      };
      return;
    }
    
    // P0.3: Delegate work calculation to ThermoAdapter
    // (keeps ideal-gas isentropic relations in package, not in unit)
    const work = thermo.computeCompressorWork(sIn, Pout, eta);
    
    // ALWAYS report demand so hub/network can see it (even if power is insufficient)
    u.powerDemand = work.W_shaft_W;
    
    // Check if enough power available (all in W, P0.2)
    if (sPower && work.W_shaft_W > sPower.available + 1) {
      u.last = {
        error: {
          severity: ErrorSeverity.MINOR,
          message: `Insufficient power: need ${(work.W_shaft_W/1000).toFixed(1)} kW, available ${(sPower.available/1000).toFixed(1)} kW`
        },
        W_shaft: work.W_shaft_W,
        W_isentropic: work.W_isentropic_W
      };
      return;
    }
    
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: Pout,
      n: { ...sIn.n },
      phaseConstraint: 'V',
      H_target_Jps: work.H_target_Jps
    };
    
    u.last = {
      Pin: sIn.P,
      Pout: Pout,
      ratio: (Pout / sIn.P).toFixed(2),
      Tin: sIn.T - 273.15,
      gamma: work.gammaMix.toFixed(3),
      W_isentropic: work.W_isentropic_W,  // W
      W_shaft: work.W_shaft_W,             // W
      eta: eta,
      eta_pct: (eta * 100).toFixed(0),
      H_in_kW: (work.H_in_Jps / 1000).toFixed(2),
      H_out_kW: (work.H_target_Jps / 1000).toFixed(2)
    };
  }
});

// Heater - Single stream heater with external heat source
// Operates in setpoint mode: user specifies T_out, unit computes Q.
// If connected to a heat stream, Q is limited to available supply.
// Analogous to compressor (user specifies P_out, unit computes W).
UnitRegistry.register('heater', {
  name: 'Heater',
  category: UnitCategories.HEAT_EXCHANGER,
  w: 2,
  h: 2,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'heat_in', dir: PortDir.IN, type: StreamType.HEAT, x: 1, y: 0 },
    { portId: 'mat_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    if (!sIn) return;
    
    // Get inlet enthalpy
    const H_in_Jps = thermo.getHdot_Jps(sIn);
    
    if (H_in_Jps === 0 && (!sIn.T || !sIn.P || !sIn.n)) {
      u.last = { error: { severity: ErrorSeverity.MAJOR,
        message: 'Cannot compute inlet enthalpy â€” missing stream properties' } };
      return;
    }
    
    // â”€â”€ Setpoint: compute Q_demand from target outlet temperature â”€â”€
    const T_setpoint_C = (par.T_out !== undefined && par.T_out !== null) ? par.T_out : (sIn.T - 273.15 + 50);
    const T_setpoint_K = T_setpoint_C + 273.15;
    
    if (T_setpoint_K < sIn.T - 0.01) {
      u.last = { error: { severity: ErrorSeverity.MAJOR,
        message: `Setpoint (${T_setpoint_C.toFixed(1)}Â°C) < inlet (${(sIn.T-273.15).toFixed(1)}Â°C) â€” use a heat exchanger for cooling` } };
      return;
    }
    
    const outProxy = { type: StreamType.MATERIAL, T: T_setpoint_K, P: sIn.P, n: { ...sIn.n } };
    const H_setpoint_Jps = thermo.getHdot_Jps(outProxy);
    const Q_demand_W = Math.max(0, H_setpoint_Jps - H_in_Jps);  // W (J/s)
    
    // â”€â”€ Limit Q to available heat supply if connected â”€â”€
    const sHeat = ports.heat_in;
    let Q_actual_W = Q_demand_W;
    let supplyLimited = false;
    
    if (sHeat && sHeat.available >= 0) {
      Q_actual_W = Math.min(Q_demand_W, sHeat.available);  // available in W
      if (Q_demand_W > sHeat.available + 10) {  // 10 W tolerance
        supplyLimited = true;
      }
    }
    
    const H_out_Jps = H_in_Jps + Q_actual_W;  // W + W = W
    
    // â”€â”€ Store heat demand for upstream signaling (P0.2: in W) â”€â”€
    // Reports FULL demand (not limited) so the hub can compute true curtailment
    u.heatDemand = Q_demand_W;
    
    // â”€â”€ Output stream â€” solver PH-flashes to find actual T and phase â”€â”€
    ports.mat_out = {
      type: StreamType.MATERIAL,
      P: sIn.P,
      n: { ...sIn.n },
      phaseConstraint: 'VL',
      H_target_Jps: H_out_Jps
    };
    
    u.last = {
      T_in_C: sIn.T - 273.15,
      T_setpoint_C: T_setpoint_C,
      Q_demand_W: Q_demand_W,
      Q_actual_W: Q_actual_W,
      H_in_kW: (H_in_Jps / 1000).toFixed(2),
      H_out_kW: (H_out_Jps / 1000).toFixed(2),
      supplyLimited: supplyLimited
    };
    
    if (supplyLimited) {
      u.last.error = { severity: ErrorSeverity.MINOR,
        message: `Setpoint ${T_setpoint_C.toFixed(0)}Â°C not achievable â€” need ${(Q_demand_W/1000).toFixed(1)} kW, supply limited to ${(sHeat.available/1000).toFixed(1)} kW` };
    }
  }
});

// Two-Stream Heat Exchanger
UnitRegistry.register('hex', {
  name: 'Heat Exchanger',
  category: UnitCategories.HEAT_EXCHANGER,
  w: 2,
  h: 2,
  ports: [
    // Hot side (horizontal)
    { portId: 'hot_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'hot_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 },
    // Cold side (vertical)
    { portId: 'cold_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 1, y: 0 },
    { portId: 'cold_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 1, y: 2 }
  ],
  tick(u, ports, par) {
    const sHot = ports.hot_in;
    const sCold = ports.cold_in;
    if (!sHot || !sCold) return;
    
    // User can specify approach temperature or outlet temperatures
    const T_approach = par.T_approach !== undefined ? par.T_approach : 10;  // K (default 10K minimum)
    const T_hot_out_target = (par.T_hot_out !== undefined && par.T_hot_out !== null) ? (par.T_hot_out + 273.15) : null;
    const T_cold_out_target = (par.T_cold_out !== undefined && par.T_cold_out !== null) ? (par.T_cold_out + 273.15) : null;
    
    // Compute inlet enthalpies using full thermo system (handles phase, latent heat, nonlinear Cp)
    const H_hot_in = thermo.getHdot_Jps(sHot);    // J/s
    const H_cold_in = thermo.getHdot_Jps(sCold);  // J/s
    
    // Stream Cp still needed for approach-temp heuristic and effectiveness display
    const Cp_hot = thermo.streamCp(sHot);    // J/s/K
    const Cp_cold = thermo.streamCp(sCold);  // J/s/K
    
    // Helper: compute exact stream enthalpy at a given temperature
    function H_at_T(stream, T_K) {
      const proxy = { type: StreamType.MATERIAL, T: T_K, P: stream.P, n: { ...stream.n } };
      return thermo.getHdot_Jps(proxy);
    }
    
    // Determine outlet enthalpies and duty
    let H_hot_out, H_cold_out, Q_J_s;
    let T_hot_out_est, T_cold_out_est;  // Estimated T for feasibility checks
    
    if (T_hot_out_target !== null) {
      // Hot outlet temperature specified by user
      T_hot_out_est = T_hot_out_target;
      H_hot_out = H_at_T(sHot, T_hot_out_target);
      Q_J_s = H_hot_in - H_hot_out;  // Energy released by hot stream (J/s)
      H_cold_out = H_cold_in + Q_J_s;  // Energy balance: cold stream absorbs Q
      // Estimate cold outlet T for feasibility check (using Cp as approximation)
      T_cold_out_est = (Cp_cold > 1e-12) ? (sCold.T + Q_J_s / Cp_cold) : sCold.T;
      
    } else if (T_cold_out_target !== null) {
      // Cold outlet temperature specified by user
      T_cold_out_est = T_cold_out_target;
      H_cold_out = H_at_T(sCold, T_cold_out_target);
      Q_J_s = H_cold_out - H_cold_in;  // Energy absorbed by cold stream (J/s)
      H_hot_out = H_hot_in - Q_J_s;  // Energy balance: hot stream releases Q
      // Estimate hot outlet T for feasibility check
      T_hot_out_est = (Cp_hot > 1e-12) ? (sHot.T - Q_J_s / Cp_hot) : sHot.T;
      
    } else {
      // Approach temperature mode: use Cp heuristic for initial T estimation,
      // then compute exact enthalpies for energy balance
      const T_hot_min = sCold.T + T_approach;
      const T_cold_max = sHot.T - T_approach;
      
      if (Cp_hot < Cp_cold) {
        // Hot stream is limiting (reaches approach first)
        T_hot_out_est = Math.max(T_hot_min, sHot.T - (sHot.T - sCold.T) * 0.8);
        H_hot_out = H_at_T(sHot, T_hot_out_est);
        Q_J_s = H_hot_in - H_hot_out;
        H_cold_out = H_cold_in + Q_J_s;
        T_cold_out_est = (Cp_cold > 1e-12) ? (sCold.T + Q_J_s / Cp_cold) : sCold.T;
      } else {
        // Cold stream is limiting
        T_cold_out_est = Math.min(T_cold_max, sCold.T + (sHot.T - sCold.T) * 0.8);
        H_cold_out = H_at_T(sCold, T_cold_out_est);
        Q_J_s = H_cold_out - H_cold_in;
        H_hot_out = H_hot_in - Q_J_s;
        T_hot_out_est = (Cp_hot > 1e-12) ? (sHot.T - Q_J_s / Cp_hot) : sHot.T;
      }
    }
    
    // Feasibility checks (using estimated outlet temperatures)
    let error = null;
    
    if (T_hot_out_est < sCold.T + T_approach) {
      error = {
        severity: ErrorSeverity.MAJOR,
        message: `Temperature cross: Hot outlet (${(T_hot_out_est-273.15).toFixed(1)}Â°C) below cold inlet + approach`
      };
    }
    
    if (T_cold_out_est > sHot.T - T_approach) {
      error = {
        severity: ErrorSeverity.MAJOR,
        message: `Temperature cross: Cold outlet (${(T_cold_out_est-273.15).toFixed(1)}Â°C) above hot inlet - approach`
      };
    }
    
    if (T_hot_out_est > sHot.T) {
      error = {
        severity: ErrorSeverity.CATASTROPHIC,
        message: 'Thermodynamic violation: Hot stream gaining heat!'
      };
    }
    
    if (T_cold_out_est < sCold.T) {
      error = {
        severity: ErrorSeverity.CATASTROPHIC,
        message: 'Thermodynamic violation: Cold stream losing heat!'
      };
    }
    
    if (error) {
      u.last = { error };
      return;
    }
    
    // Output streams via H_target_Jps â€” solver uses PH flash to determine T and phase.
    // This correctly handles phase changes (boiling/condensing) in the heat exchanger.
    ports.hot_out = {
      type: StreamType.MATERIAL,
      P: sHot.P,  // Assume negligible pressure drop
      n: { ...sHot.n },
      phaseConstraint: sHot.phaseConstraint || 'VL',
      H_target_Jps: H_hot_out
    };
    
    ports.cold_out = {
      type: StreamType.MATERIAL,
      P: sCold.P,
      n: { ...sCold.n },
      phaseConstraint: sCold.phaseConstraint || 'VL',
      H_target_Jps: H_cold_out
    };
    
    // Calculate effectiveness (using Cp approximation for display)
    const Q_max = Math.min(Cp_hot, Cp_cold) * (sHot.T - sCold.T);  // J/s
    const effectiveness = Q_max > 1e-6 ? (Q_J_s / Q_max * 100).toFixed(1) : 'N/A';
    
    u.last = {
      T_hot_in: sHot.T,
      T_hot_out: T_hot_out_est,
      T_cold_in: sCold.T,
      T_cold_out: T_cold_out_est,
      Q: Q_J_s / 1000,  // Display in kW
      effectiveness: effectiveness,
      approach: Math.min(T_hot_out_est - sCold.T, sHot.T - T_cold_out_est)
    };
  }
});

// L-V Separator - Adiabatic flash drum / knockout vessel
// Performs equilibrium VLE flash and splits vapor and liquid products.
// No parameters: separation is dictated by thermodynamic equilibrium at inlet T, P.
// Analogous to compressor (which sets outlet P), the separator's "setpoint" is simply
// perfect phase equilibrium â€” the flash is the physics, not a user knob.
UnitRegistry.register('flash_drum', {
  name: 'L-V Separator',
  category: UnitCategories.SEPARATOR,
  w: 2,
  h: 3,
  ports: [
    { portId: 'in',      dir: PortDir.IN,  type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'vap_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 0 },
    { portId: 'liq_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 3 }
  ],
  tick(u, ports, par) {
    const sIn = ports.in;
    if (!sIn) return;
    
    const nTotal = Object.values(sIn.n || {}).reduce((a, b) => a + b, 0);
    
    if (nTotal < 1e-15) {
      const empty = { type: StreamType.MATERIAL, T: sIn.T || 298.15, P: sIn.P || 101325, n: {} };
      ports.vap_out = { ...empty, phaseConstraint: 'V' };
      ports.liq_out = { ...empty, phaseConstraint: 'L' };
      u.last = { warning: 'Empty inlet' };
      return;
    }
    
    // â”€â”€ Read inlet flash results (computed by solver on upstream output) â”€â”€
    // The solver already TP- or PH-flashed the upstream output port.
    // The inlet stream has: T, P, phase, nV, nL, beta, x, y
    const nV = sIn.nV || {};
    const nL = sIn.nL || {};
    
    const nV_total = Object.values(nV).reduce((a, b) => a + b, 0);
    const nL_total = Object.values(nL).reduce((a, b) => a + b, 0);
    
    // â”€â”€ Isobaric, adiabatic separation at inlet T, P â”€â”€
    // Vapor product: nV at (T, P) constrained to V
    // Liquid product: nL at (T, P) constrained to L
    // If single-phase inlet, one outlet is empty.
    
    if (sIn.phase === 'V' || nL_total < 1e-15) {
      // All vapor â€” nothing to separate
      ports.vap_out = { type: StreamType.MATERIAL, T: sIn.T, P: sIn.P, n: { ...sIn.n }, phaseConstraint: 'V' };
      ports.liq_out = { type: StreamType.MATERIAL, T: sIn.T, P: sIn.P, n: {}, phaseConstraint: 'L' };
    } else if (sIn.phase === 'L' || nV_total < 1e-15) {
      // All liquid â€” nothing to separate
      ports.vap_out = { type: StreamType.MATERIAL, T: sIn.T, P: sIn.P, n: {}, phaseConstraint: 'V' };
      ports.liq_out = { type: StreamType.MATERIAL, T: sIn.T, P: sIn.P, n: { ...sIn.n }, phaseConstraint: 'L' };
    } else {
      // Two-phase: split into V and L products
      ports.vap_out = { type: StreamType.MATERIAL, T: sIn.T, P: sIn.P, n: { ...nV }, phaseConstraint: 'V' };
      ports.liq_out = { type: StreamType.MATERIAL, T: sIn.T, P: sIn.P, n: { ...nL }, phaseConstraint: 'L' };
    }
    
    // â”€â”€ Diagnostics â”€â”€
    u.last = {
      T_C: (sIn.T - 273.15),
      P_bar: (sIn.P / 1e5),
      phase: sIn.phase,
      beta: sIn.vaporFraction ?? sIn.beta ?? null,
      nV_total: nV_total,
      nL_total: nL_total,
      nTotal: nTotal,
      vap_pct: (nV_total / nTotal * 100),
      liq_pct: (nL_total / nTotal * 100)
    };
  }
});

// Mixer - Adiabatic stream mixer (2 inlets to 1 outlet)
UnitRegistry.register('mixer', {
  name: 'Mixer',
  category: UnitCategories.TOPOLOGY,
  w: 2,
  h: 2,
  ports: [
    { portId: 'in1', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 0 },
    { portId: 'in2', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 2 },
    { portId: 'out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 1 }
  ],
  tick(u, ports, par) {
    const s1 = ports.in1;
    const s2 = ports.in2;
    
    // At least one inlet must have data.
    // A connected-but-not-yet-computed inlet (e.g., a recycle stream on the first
    // solver iteration) is treated as zero flow. This bootstraps successive
    // substitution for recycle loops â€” the standard "tear stream" approach.
    if (!s1 && !s2) return;
    
    // Effective inlets: missing â†’ zero-flow placeholder
    const EMPTY_STREAM = { type: StreamType.MATERIAL, T: 298.15, P: 101325, n: {} };
    const eff1 = s1 || EMPTY_STREAM;
    const eff2 = s2 || EMPTY_STREAM;
    
    // â”€â”€ Pressure: minimum of inlets that have real data â”€â”€
    // Ignore placeholders (recycle bootstrap) â€” only real streams set pressure
    const pressures = [];
    if (s1 && s1.P > 0) pressures.push(s1.P);
    if (s2 && s2.P > 0) pressures.push(s2.P);
    const P_out = pressures.length > 0 ? Math.min(...pressures) : 101325;
    
    // â”€â”€ Molar balance: merge compositions â”€â”€
    const n_out = {};
    for (const [comp, n] of Object.entries(eff1.n || {})) {
      n_out[comp] = (n_out[comp] || 0) + n;
    }
    for (const [comp, n] of Object.entries(eff2.n || {})) {
      n_out[comp] = (n_out[comp] || 0) + n;
    }
    
    // Clamp tiny negatives from numerical noise
    for (const comp in n_out) {
      if (n_out[comp] < 0) n_out[comp] = 0;
    }
    
    const nTotal = Object.values(n_out).reduce((a, b) => a + b, 0);
    
    // Handle empty streams gracefully
    if (nTotal < 1e-15) {
      ports.out = {
        type: StreamType.MATERIAL,
        T: 298.15,
        P: P_out,
        n: {},
        phaseConstraint: 'VL'
      };
      u.last = { warning: 'All inlets are empty â€” zero total flow' };
      return;
    }
    
    // â”€â”€ Energy balance: adiabatic mixer (Q = 0, W = 0) â”€â”€
    // H_out = H_in1 + H_in2  (total enthalpy flow in J/s)
    // For empty placeholder streams, getHdot_Jps returns 0 (no flow = no enthalpy)
    const H_in1 = s1 ? thermo.getHdot_Jps(eff1) : 0;
    const H_in2 = s2 ? thermo.getHdot_Jps(eff2) : 0;
    const H_out_Jps = H_in1 + H_in2;
    
    // â”€â”€ Output stream spec: solver will PH-flash to find T and phase â”€â”€
    ports.out = {
      type: StreamType.MATERIAL,
      P: P_out,
      n: n_out,
      phaseConstraint: 'VL',
      H_target_Jps: H_out_Jps
    };
    
    // â”€â”€ Diagnostics for display â”€â”€
    u.last = {
      P_out: P_out,
      nTotal: nTotal,
      H_in1_kW: (H_in1 / 1000).toFixed(2),
      H_in2_kW: (H_in2 / 1000).toFixed(2),
      H_out_kW: (H_out_Jps / 1000).toFixed(2),
      nComponents: Object.keys(n_out).length
    };
  }
});

// Splitter - Stream splitter (1 inlet to 2 outlets, no component separation)
UnitRegistry.register('splitter', {
  name: 'Splitter',
  category: UnitCategories.TOPOLOGY,
  w: 2,
  h: 2,
  ports: [
    { portId: 'in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'out1', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 0 },
    { portId: 'out2', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 2 }
  ],
  tick(u, ports, par) {
    const sIn = ports.in;
    if (!sIn) return;
    
    // Split fraction: percentage of inlet going to out1 (0â€“100)
    const pct = (par.splitPct !== undefined && par.splitPct !== null) ? par.splitPct : 50;
    const frac1 = Math.max(0, Math.min(100, pct)) / 100;
    const frac2 = 1 - frac1;
    
    // â”€â”€ Molar balance: identical composition split â”€â”€
    const n_out1 = {};
    const n_out2 = {};
    for (const [comp, n] of Object.entries(sIn.n || {})) {
      n_out1[comp] = Math.max(0, frac1 * n);
      n_out2[comp] = Math.max(0, frac2 * n);
    }
    
    const nTotal = Object.values(sIn.n || {}).reduce((a, b) => a + b, 0);
    
    // Handle empty inlet gracefully
    if (nTotal < 1e-15) {
      const empty = { type: StreamType.MATERIAL, T: 298.15, P: sIn.P || 101325, n: {}, phaseConstraint: 'VL' };
      ports.out1 = { ...empty };
      ports.out2 = { ...empty };
      u.last = { warning: 'Inlet stream is empty â€” zero total flow' };
      return;
    }
    
    // â”€â”€ Energy balance: split enthalpy proportionally â”€â”€
    // Specific enthalpy is identical in both outlets (same T, P, composition)
    // So H_out1 = frac1 * H_in, H_out2 = frac2 * H_in
    const H_in_Jps = thermo.getHdot_Jps(sIn);
    
    ports.out1 = {
      type: StreamType.MATERIAL,
      P: sIn.P,
      n: n_out1,
      phaseConstraint: sIn.phaseConstraint || 'VL',
      H_target_Jps: frac1 * H_in_Jps
    };
    
    ports.out2 = {
      type: StreamType.MATERIAL,
      P: sIn.P,
      n: n_out2,
      phaseConstraint: sIn.phaseConstraint || 'VL',
      H_target_Jps: frac2 * H_in_Jps
    };
    
    // â”€â”€ Diagnostics â”€â”€
    u.last = {
      splitPct: pct,
      P: sIn.P,
      nTotal: nTotal,
      nOut1: Object.values(n_out1).reduce((a, b) => a + b, 0),
      nOut2: Object.values(n_out2).reduce((a, b) => a + b, 0),
      H_in_kW: (H_in_Jps / 1000).toFixed(2),
      H_out1_kW: (frac1 * H_in_Jps / 1000).toFixed(2),
      H_out2_kW: (frac2 * H_in_Jps / 1000).toFixed(2)
    };
  }
});

// Flash Drum (L-V Separator) â€” Adiabatic phase separation
// Inlet stream flashes at its T, P conditions.
// Vapor exits top, liquid exits bottom.
// No parameters â€” separation is determined by thermodynamics.
// Analogous pattern: splitter splits by fraction, flash drum splits by phase.
UnitRegistry.register('flash_drum', {
  name: 'Flash Drum',
  category: UnitCategories.SEPARATOR,
  w: 2,
  h: 3,
  ports: [
    { portId: 'mat_in', dir: PortDir.IN, type: StreamType.MATERIAL, x: 0, y: 1 },
    { portId: 'vap_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 0 },
    { portId: 'liq_out', dir: PortDir.OUT, type: StreamType.MATERIAL, x: 2, y: 3 }
  ],
  tick(u, ports, par) {
    const sIn = ports.mat_in;
    if (!sIn) return;
    
    // The inlet stream arrives already flashed by the solver.
    // It carries: T, P, n, nV, nL, beta, phase, x, y, Hdot_J_s
    
    const nV = sIn.nV || {};
    const nL = sIn.nL || {};
    const nTotal_V = Object.values(nV).reduce((a, b) => a + b, 0);
    const nTotal_L = Object.values(nL).reduce((a, b) => a + b, 0);
    const nTotal = nTotal_V + nTotal_L;
    
    if (nTotal < 1e-15) {
      const empty = { type: StreamType.MATERIAL, T: sIn.T || 298.15, P: sIn.P || 101325, n: {}, phaseConstraint: 'VL' };
      ports.vap_out = { ...empty };
      ports.liq_out = { ...empty };
      u.last = { error: { severity: ErrorSeverity.MAJOR, message: 'Empty feed' } };
      return;
    }
    
    // â”€â”€ Vapor outlet â”€â”€
    // Phase constraint = V: solver will compute vapor-only enthalpy
    ports.vap_out = {
      type: StreamType.MATERIAL,
      T: sIn.T,
      P: sIn.P,
      n: { ...nV },
      phaseConstraint: 'V'
    };
    
    // â”€â”€ Liquid outlet â”€â”€
    // Phase constraint = L: solver will compute liquid-only enthalpy
    ports.liq_out = {
      type: StreamType.MATERIAL,
      T: sIn.T,
      P: sIn.P,
      n: { ...nL },
      phaseConstraint: 'L'
    };
    
    // â”€â”€ Diagnostics â”€â”€
    const beta = sIn.beta !== undefined ? sIn.beta : (nTotal > 0 ? nTotal_V / nTotal : 0);
    
    u.last = {
      T_C: (sIn.T - 273.15),
      P_bar: (sIn.P / 1e5),
      phase: sIn.phase || 'unknown',
      beta: beta,
      vap_pct: (beta * 100),
      nTotal: nTotal,
      nV_total: nTotal_V,
      nL_total: nTotal_L
    };
    
    // Composition detail per component
    const comps = [...new Set([...Object.keys(nV), ...Object.keys(nL)])];
    for (const c of comps) {
      const feed = (nV[c] || 0) + (nL[c] || 0);
      if (feed > 1e-15) {
        u.last[`K_${c}`] = ((sIn.y?.[c] || 0) / (sIn.x?.[c] || 1e-30));
        u.last[`recovery_V_${c}_pct`] = ((nV[c] || 0) / feed * 100);
      }
    }
  }
});

/* =========================
   SCENE CLASS
   Manages the process flowsheet state
   ========================= */
class Scene {
  constructor() {
    // Grid properties (kept for backwards compatibility in export/import)
    this.gridW = 22;
    this.gridH = 14;
    this.tile = 48; // Size of one grid cell in world units
    
    // Scene data
    this.units = new Map();
    this.connections = [];
    this._idCounter = 0;
    
    // Runtime calculation results
    this.runtime = {
      unitData: new Map(),
      lastSolve: { ok: true, iterations: 0, warnings: [] }
    };
  }

  placeUnit(defId, x, y) {
    const def = UnitRegistry.get(defId);
    if (!def) return null;
    
    // Check collision with existing units
    if (this._collision(x, y, def.w, def.h, null)) return null;
    
    // Create new unit with default parameters
    const id = `${defId}-${++this._idCounter}`;
    const unit = { 
      id, 
      defId, 
      name: `${def.name} ${this._idCounter}`, // Default name
      x, 
      y, 
      rot: 0, 
      params: {} 
    };
    
    // Set default parameters based on unit type
    switch (defId) {
      case 'source_gas':
        unit.params = { species: 'H2', T: 25, P: 101325, nDot: 1.0 };
        break;
      case 'source_power':
        unit.params = { QkW: 10 };
        break;
      case 'hx_cop':
        unit.params = { COP: 2.5, TminClamp: -50 };
        break;
    }
    
    this.units.set(id, unit);
    return id;
  }

  deleteUnit(id) {
    this.units.delete(id);
    // Remove all connections involving this unit
    this.connections = this.connections.filter(
      c => c.from.unitId !== id && c.to.unitId !== id
    );
  }

  moveUnit(id, nx, ny) {
    const u = this.units.get(id);
    if (!u) return;
    
    const def = UnitRegistry.get(u.defId);
    
    // Check collision at new position
    if (this._collision(nx, ny, def.w, def.h, id)) return;
    
    u.x = nx;
    u.y = ny;
  }

  rotateUnit(id) {
    const u = this.units.get(id);
    if (!u) return;
    u.rot = (u.rot + 1) % 4;
  }

  unitAt(x, y) {
    for (const [id, u] of this.units) {
      const def = UnitRegistry.get(u.defId);
      if (x >= u.x && x < u.x + def.w && y >= u.y && y < u.y + def.h) {
        return u;
      }
    }
    return null;
  }

  _collision(x, y, w, h, skipId) {
    for (const [id, u] of this.units) {
      if (id === skipId) continue;
      
      const def = UnitRegistry.get(u.defId);
      const ox = u.x, oy = u.y, ow = def.w, oh = def.h;
      
      // AABB collision detection
      if (!(x + w <= ox || ox + ow <= x || y + h <= oy || oy + oh <= y)) {
        return true;
      }
    }
    return false;
  }

  connect(from, to) {
    // Validate units exist
    const uFrom = this.units.get(from.unitId);
    const uTo = this.units.get(to.unitId);
    if (!uFrom || !uTo) return null;

    // Validate ports exist and are compatible
    const defFrom = UnitRegistry.get(uFrom.defId);
    const defTo = UnitRegistry.get(uTo.defId);
    const pFrom = defFrom.ports.find(p => p.portId === from.portId);
    const pTo = defTo.ports.find(p => p.portId === to.portId);
    if (!pFrom || !pTo) return null;
    if (pFrom.type !== pTo.type) return null; // Check stream type compatibility

    // Check if target IN port already has a connection
    // Exception: multiConnect ports accept unlimited connections
    const existingToPort = this.connections.find(
      c => c.to.unitId === to.unitId && c.to.portId === to.portId
    );
    if (existingToPort && !(pTo && pTo.multiConnect)) return null;

    // Check source OUT port connections based on stream type
    const existingFromPort = this.connections.find(
      c => c.from.unitId === from.unitId && c.from.portId === from.portId
    );
    
    // For MATERIAL streams: strict 1-to-1 (physical splitting not allowed)
    if (pFrom.type === StreamType.MATERIAL && existingFromPort) {
      return null;
    }
    
    // For POWER streams (ELECTRICAL, MECHANICAL): allow multiple outputs from source
    // This models electrical bus / mechanical shaft sharing

    // Create connection
    const id = `conn-${++this._idCounter}`;
    this.connections.push({ id, from, to });
    return id;
  }

  exportJSON() {
    const data = {
      version: 8,
      grid: { w: this.gridW, h: this.gridH, tile: this.tile },
      units: [],
      connections: [],
      modelsActive: models.active
    };
    
    for (const u of this.units.values()) {
      data.units.push({
        id: u.id,
        defId: u.defId,
        name: u.name,
        x: u.x,
        y: u.y,
        rot: u.rot,
        params: u.params
      });
    }
    
    data.connections = [...this.connections];
    return JSON.stringify(data, null, 2);
  }

  importJSON(str) {
    const data = JSON.parse(str);
    
    // Guard against missing fields with defaults
    this.gridW = data.grid?.w ?? 50;
    this.gridH = data.grid?.h ?? 50;
    this.tile = data.grid?.tile ?? 48;
    
    this.units.clear();
    this.connections = [];
    
    // Import units and rebuild ID counter to avoid collisions
    let maxUnitId = 0;
    for (const u of (data.units || [])) {
      // Guard against missing unit fields
      const unit = {
        id: u.id || `unit-${++maxUnitId}`,
        defId: u.defId || 'source_gas',
        name: u.name || 'Unit',
        x: u.x ?? 0,
        y: u.y ?? 0,
        rot: u.rot ?? 0,
        params: u.params || {}
      };
      
      this.units.set(unit.id, unit);
      
      // Extract numeric suffix from ID to rebuild counter
      // IDs like "pump-5", "valve-12" â†’ extract max number
      const match = unit.id.match(/-(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        maxUnitId = Math.max(maxUnitId, num);
      }
    }
    
    // Import connections and rebuild ID counter
    let maxConnId = 0;
    for (const c of (data.connections || [])) {
      // Guard against missing connection fields
      const conn = {
        id: c.id || `conn-${++maxConnId}`,
        from: {
          unitId: c.from?.unitId || '',
          portId: c.from?.portId || ''
        },
        to: {
          unitId: c.to?.unitId || '',
          portId: c.to?.portId || ''
        }
      };
      
      this.connections.push(conn);
      
      // Extract numeric suffix from connection ID
      const match = conn.id.match(/-(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        maxConnId = Math.max(maxConnId, num);
      }
    }
    
    // Set _idCounter to max of both to ensure no collisions
    this._idCounter = Math.max(maxUnitId, maxConnId);
    
    // Import active models with validation
    // Skip null/undefined model IDs (models not yet registered)
    if (data.modelsActive) {
      for (const k in data.modelsActive) {
        const modelId = data.modelsActive[k];
        
        // Skip if no model is set for this kind
        if (modelId === null || modelId === undefined) {
          continue;
        }
        
        const success = models.setActive(k, modelId);
        if (!success) {
          console.warn(`Failed to activate model '${modelId}' for kind '${k}' during import`);
        }
        
        // If restoring thermo_package, also switch the actual engine
        if (k === 'thermo_package' && success) {
          const pkg = models.getActive('thermo_package');
          if (pkg && pkg instanceof ThermoPackage) {
            thermo.setPackage(pkg);
          }
        }
      }
    }
  }
}

const scene = new Scene();

/* =========================
   SOLVER
   Successive substitution for flowsheet calculations
   ========================= */
function solveScene(scene) {
  const MAX_ITER = 20;
  let iter = 0;
  let changed = true;

  // Initialize runtime data for all units
  scene.runtime.unitData.clear();
  for (const [id, u] of scene.units) {
    scene.runtime.unitData.set(id, {
      ports: {},
      last: {},
      errors: []
    });
  }

  // Iterative successive substitution
  while (changed && iter < MAX_ITER) {
    changed = false;
    iter++;

    for (const [id, u] of scene.units) {
      const def = UnitRegistry.get(u.defId);
      if (!def.tick) continue;

      const ud = scene.runtime.unitData.get(id);
      const inPorts = {};

      // FIX 3: Reset transient state before each tick to prevent stale data
      // This ensures no diagnostics or power demand carries across iterations
      ud.errors = [];           // Clear errors from previous iteration
      u.last = {};              // Clear unit-specific calculation results
      u.powerDemand = 0;        // Reset power demand (will be recalculated)
      u.heatDemand = 0;         // Reset heat demand (will be recalculated)
      ud.last = {};             // Clear runtime diagnostics
      ud.powerDemand = 0;       // Clear runtime power demand
      ud.heatDemand = 0;        // Clear runtime heat demand

      // Gather input streams from connections
      for (const p of def.ports) {
        if (p.dir === PortDir.IN) {
          if (p.multiConnect) {
            // MultiConnect port: merge all connected streams into one
            const conns = scene.connections.filter(
              c => c.to.unitId === id && c.to.portId === p.portId
            );
            if (conns.length === 0) {
              inPorts[p.portId] = null;
            } else {
              // Merge electrical streams: sum available
              let totalAvailable = 0;
              for (const conn of conns) {
                const fromUD = scene.runtime.unitData.get(conn.from.unitId);
                const stream = fromUD?.ports?.[conn.from.portId];
                if (stream) totalAvailable += stream.available || 0;
              }
              inPorts[p.portId] = {
                type: p.type,
                available: totalAvailable,
                demand: 0,
                _sourceCount: conns.length  // diagnostic: how many sources
              };
            }
          } else {
            // Standard single-connect port
            const conn = scene.connections.find(
              c => c.to.unitId === id && c.to.portId === p.portId
            );
            if (conn) {
              const fromUD = scene.runtime.unitData.get(conn.from.unitId);
              inPorts[p.portId] = fromUD?.ports?.[conn.from.portId] || null;
            } else {
              inPorts[p.portId] = null;
            }
          }
        }
      }

      // Store old state to detect changes (strip demand â€” backward annotation)
      const oldPorts = {};
      for (const [portId, stream] of Object.entries(ud.ports)) {
        if (stream && stream.demand !== undefined) {
          const { demand, ...rest } = stream;
          oldPorts[portId] = rest;
        } else {
          oldPorts[portId] = stream;
        }
      }
      const oldJSON = JSON.stringify(oldPorts);

      // Execute unit calculation
      def.tick(u, inPorts, u.params);

      // Perform flash calculations through thermo adapter (single entrypoint)
      // Choose flash method based on stream specification
      for (const p of def.ports) {
        if (p.dir === PortDir.OUT && p.type === StreamType.MATERIAL) {
          const stream = inPorts[p.portId];
          if (stream && stream.n) {
            // Skip flash for zero-flow streams (e.g. a splitter outlet at 0%)
            const nTotal = Object.values(stream.n).reduce((a, b) => a + b, 0);
            if (nTotal < 1e-15) {
              stream.phase = 'V';
              stream.beta = 1;
              stream.vaporFraction = 1;
              stream.x = {};
              stream.y = {};
              stream.nV = {};
              stream.nL = {};
              stream.Hdot_J_s = 0;
              // Assign a default T if not set
              if (!stream.T) stream.T = 298.15;
            } else {
            try {
              let result;
              
              // Choose flash method based on what's specified
              if (stream.H_target_Jps !== undefined && stream.H_target_Jps !== null) {
                // PH FLASH: Enthalpy is specified, solve for T
                result = thermo.phFlash(stream, stream.H_target_Jps);
                
                // Write back solved temperature
                stream.T = result.T_K;
                
              } else {
                // TP FLASH: Temperature is specified
                result = thermo.tpFlash(stream);
              }
              
              // Augment stream with flash results
              stream.phase = result.phase;
              stream.vaporFraction = result.vaporFraction || result.beta;
              stream.beta = result.beta;
              stream.x = result.x;
              stream.y = result.y;
              stream.nV = result.nV;
              stream.nL = result.nL;
              
              // Store any flash warnings
              if (result.warning) {
                if (!ud.errors) ud.errors = [];
                ud.errors.push(`${p.portId}: ${result.warning}`);
              }
              
              // Compute enthalpy immediately after flash
              thermo.computeStreamEnthalpy(stream);
              
            } catch (err) {
              ud.errors.push(`Flash failed on ${p.portId}: ${err.message}`);
            }
            } // end else (nTotal > 0)
          }
        }
      }

      // Store output streams and validate types
      for (const p of def.ports) {
        if (p.dir === PortDir.OUT) {
          const stream = inPorts[p.portId];
          ud.ports[p.portId] = stream;
          
          // Validate stream type matches port type
          if (stream && !validateStreamType(stream, p.type)) {
            ud.errors.push(`Port ${p.portId}: stream type mismatch`);
          }
        }
      }

      // Check if anything changed (forward computation only)
      // Exclude 'demand' field from comparison â€” it's a backward annotation
      // written by post-processing, not a forward computation result.
      // Including it causes infinite oscillation (tick resets to 0, post-pass restores).
      const forwardPorts = {};
      for (const [portId, stream] of Object.entries(ud.ports)) {
        if (stream && stream.demand !== undefined) {
          const { demand, ...rest } = stream;
          forwardPorts[portId] = rest;
        } else {
          forwardPorts[portId] = stream;
        }
      }
      const newJSON = JSON.stringify(forwardPorts);
      if (oldJSON !== newJSON) changed = true;

      // Store unit-specific calculation results
      ud.last = u.last || {};
    }
    
    // â”€â”€ Demand rollup (inside loop for convergence) â”€â”€
    
    // Step A: Copy demand values from unit calculations into runtime data
    for (const [_id, _u] of scene.units) {
      const _ud = scene.runtime.unitData.get(_id);
      _ud.powerDemand = _u.powerDemand || 0;
      _ud.heatDemand = _u.heatDemand || 0;
    }
    
    // Step B: Propagate demand through power conversion units
    // Motor:          downstream powerDemand â†’ electrical demand (Ã· Î·)
    // Electric heater: downstream heatDemand  â†’ electrical demand (Ã· Î·)
    // IMPORTANT: Do NOT overwrite W_elec_W / W_mech_W (actual throughput from tick).
    //            Store demand as separate fields for hub to read.
    for (const [_id, _u] of scene.units) {
      const _def = UnitRegistry.get(_u.defId);
      const _ud = scene.runtime.unitData.get(_id);
      
      if (_def.category === UnitCategories.POWER_CONVERSION.name) {
        const outConns = scene.connections.filter(c => c.from.unitId === _id);
        
        if (_u.defId === 'motor') {
          let downstreamDemand = 0;
          for (const conn of outConns) {
            const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
            if (consumerUD) downstreamDemand += consumerUD.powerDemand || 0;
          }
          const eta = _u.params.eta || 0.92;
          _ud.powerDemand = downstreamDemand / eta;  // Hub reads this
          _ud.last.W_mech_demand_W = downstreamDemand;
          _ud.last.W_elec_demand_W = _ud.powerDemand;
          
          for (const p of _def.ports) {
            if (p.dir === PortDir.OUT && _ud.ports[p.portId]) {
              _ud.ports[p.portId].demand = downstreamDemand;
            }
          }
        }
        
        if (_u.defId === 'electric_heater') {
          let downstreamHeat = 0;
          for (const conn of outConns) {
            const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
            if (consumerUD) downstreamHeat += consumerUD.heatDemand || 0;
          }
          const eta = _u.params.eta || 0.99;
          _ud.powerDemand = downstreamHeat / eta;  // Hub reads this
          _ud.last.Q_heat_demand_W = downstreamHeat;
          _ud.last.W_elec_demand_W = _ud.powerDemand;
          
          for (const p of _def.ports) {
            if (p.dir === PortDir.OUT && _ud.ports[p.portId]) {
              _ud.ports[p.portId].demand = downstreamHeat;
            }
          }
        }
      }
    }
    
    // Step C: Hub balancing â€” compute dispatch, curtailment, surplus
    for (const [_id, _u] of scene.units) {
      if (_u.defId !== 'power_hub') continue;
      
      const _ud = scene.runtime.unitData.get(_id);
      const hubLast = _u.last || {};
      
      const firmSupply_W   = hubLast.firmSupply_W   || 0;
      const batteryMax_W   = hubLast.batteryMax_W   || 0;
      
      // Sum consumer demands from dist_out connections
      const distConns = scene.connections.filter(
        c => c.from.unitId === _id && c.from.portId === 'dist_out'
      );
      
      let totalDemand_W = 0;
      for (const conn of distConns) {
        const consumerUD = scene.runtime.unitData.get(conn.to.unitId);
        if (consumerUD) {
          totalDemand_W += consumerUD.powerDemand || 0;
        }
      }
      
      // Battery dispatch: firm sources first, batteries fill the gap
      const gap_W = Math.max(0, totalDemand_W - firmSupply_W);
      const batteryDraw_W = Math.min(gap_W, batteryMax_W);
      const totalSupply_W = firmSupply_W + batteryDraw_W;
      
      // Firm sources: how much is actually consumed
      const firmUsed_W = Math.min(firmSupply_W, totalDemand_W);
      
      // Curtailment
      const curtailmentMode = hubLast.curtailmentMode || 'proportional';
      let curtailmentFactor = 1.0;
      if (totalDemand_W > 0 && totalSupply_W < totalDemand_W) {
        curtailmentFactor = totalSupply_W / totalDemand_W;
      }
      
      // Surplus
      const surplus_W = Math.max(0, totalSupply_W - totalDemand_W);
      
      // Update dist_out and surplus_out â€” if available changed, force another iteration
      // Exclude demand from comparison (backward annotation, same as main convergence check)
      const stripDemand = (s) => { if (!s) return s; const { demand, ...rest } = s; return rest; };
      const oldDist = JSON.stringify(stripDemand(_ud.ports.dist_out));
      const oldSurplus = JSON.stringify(stripDemand(_ud.ports.surplus_out));
      
      if (_ud.ports.dist_out) {
        _ud.ports.dist_out.available = totalSupply_W;
        _ud.ports.dist_out.demand = totalDemand_W;
      }
      if (_ud.ports.surplus_out) {
        _ud.ports.surplus_out.available = surplus_W;
      }
      
      if (JSON.stringify(stripDemand(_ud.ports.dist_out)) !== oldDist) changed = true;
      if (JSON.stringify(stripDemand(_ud.ports.surplus_out)) !== oldSurplus) changed = true;
      
      // Write demand back to battery sources (proportional to capacity)
      const battConns = scene.connections.filter(
        c => c.to.unitId === _id && c.to.portId === 'battery_in'
      );
      for (const conn of battConns) {
        const srcUD = scene.runtime.unitData.get(conn.from.unitId);
        const srcU  = scene.units.get(conn.from.unitId);
        if (srcUD && srcUD.ports[conn.from.portId]) {
          const srcAvail = srcUD.ports[conn.from.portId].available || 0;
          // Proportional share: this battery's fraction of total battery capacity
          const share = batteryMax_W > 0 ? srcAvail / batteryMax_W : 0;
          const thisDemand = batteryDraw_W * share;
          srcUD.ports[conn.from.portId].demand = thisDemand;
          // Carry forward for battery tick (survives u.last clearing)
          if (srcU) srcU._hubDemand_W = thisDemand;
        }
      }
      
      // Write demand back to firm sources (proportional to capacity)
      const firmConns = scene.connections.filter(
        c => c.to.unitId === _id && c.to.portId === 'firm_in'
      );
      for (const conn of firmConns) {
        const srcUD = scene.runtime.unitData.get(conn.from.unitId);
        const srcU  = scene.units.get(conn.from.unitId);
        if (srcUD && srcUD.ports[conn.from.portId]) {
          const srcAvail = srcUD.ports[conn.from.portId].available || 0;
          const share = firmSupply_W > 0 ? srcAvail / firmSupply_W : 0;
          const thisDemand = firmUsed_W * share;
          srcUD.ports[conn.from.portId].demand = thisDemand;
          // Carry forward for battery tick (survives u.last clearing)
          if (srcU) srcU._hubDemand_W = thisDemand;
        }
      }
      
      // Update diagnostics
      _ud.last.totalDemand_W     = totalDemand_W;
      _ud.last.batteryDraw_W     = batteryDraw_W;
      _ud.last.totalSupply_W     = totalSupply_W;
      _ud.last.firmUsed_W        = firmUsed_W;
      _ud.last.surplus_W         = surplus_W;
      _ud.last.curtailmentFactor = curtailmentFactor;
      _u.last.totalDemand_W      = totalDemand_W;
      _u.last.batteryDraw_W      = batteryDraw_W;
      _u.last.totalSupply_W      = totalSupply_W;
      _u.last.firmUsed_W         = firmUsed_W;
      _u.last.surplus_W          = surplus_W;
      _u.last.curtailmentFactor  = curtailmentFactor;
      
      // Carry forward for next iteration's tick (survives u.last clearing)
      _u._hubSurplus_W    = surplus_W;
      _u._hubDistAvail_W  = totalSupply_W;
    }
  }

  // â”€â”€ Post-loop processing (only needs final converged values) â”€â”€

  // Enthalpy computation for all material streams
  for (const [id, u] of scene.units) {
    const ud = scene.runtime.unitData.get(id);
    const def = UnitRegistry.get(u.defId);
    
    for (const p of def.ports) {
      const stream = ud.ports[p.portId];
      if (stream && stream.type === StreamType.MATERIAL) {
        // Compute and store enthalpy properties
        thermo.computeStreamEnthalpy(stream);
      }
    }
  }
  
  // Mass and energy balance validation
  const balanceErrors = [];
  const TOLERANCE = 1e-6;  // mol/s tolerance for mass balance
  
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const ud = scene.runtime.unitData.get(id);
    
    // Skip sources, sinks, and units without mass balance requirement
    if (def.category === UnitCategories.SOURCE.name ||
        def.category === UnitCategories.SINK.name ||
        def.category === UnitCategories.POWER_SOURCE.name ||
        def.category === UnitCategories.POWER_MANAGEMENT.name ||
        def.category === UnitCategories.POWER_CONVERSION.name) {
      continue;
    }
    
    // Collect inlet and outlet material streams
    const inletStreams = [];
    const outletStreams = [];
    
    for (const p of def.ports) {
      const stream = ud.ports[p.portId];
      if (stream && stream.type === StreamType.MATERIAL && stream.n) {
        if (p.dir === PortDir.IN) {
          inletStreams.push(stream);
        } else if (p.dir === PortDir.OUT) {
          outletStreams.push(stream);
        }
      }
    }
    
    // Mass balance check: sum(n_in) = sum(n_out) for each component
    if (inletStreams.length > 0 && outletStreams.length > 0) {
      const componentsIn = new Set();
      const componentsOut = new Set();
      
      for (const s of inletStreams) {
        for (const comp of Object.keys(s.n)) componentsIn.add(comp);
      }
      for (const s of outletStreams) {
        for (const comp of Object.keys(s.n)) componentsOut.add(comp);
      }
      
      const allComponents = new Set([...componentsIn, ...componentsOut]);
      
      for (const comp of allComponents) {
        let n_in = 0;
        let n_out = 0;
        
        for (const s of inletStreams) {
          n_in += s.n[comp] || 0;
        }
        for (const s of outletStreams) {
          n_out += s.n[comp] || 0;
        }
        
        const imbalance = Math.abs(n_in - n_out);
        if (imbalance > TOLERANCE) {
          balanceErrors.push({
            unitId: id,
            unitName: u.name || def.name,
            component: comp,
            type: 'mass',
            n_in: n_in,
            n_out: n_out,
            imbalance: imbalance
          });
          
          ud.errors.push(`Mass imbalance for ${comp}: ${n_in.toFixed(4)} mol/s in, ${n_out.toFixed(4)} mol/s out`);
        }
      }
    }
    
    // Energy balance check (informational for now)
    // INTERNAL UNITS: J/s for all energy flows
    if (inletStreams.length > 0 && outletStreams.length > 0) {
      let H_in = 0;  // J/s
      let H_out = 0;  // J/s
      
      for (const s of inletStreams) {
        H_in += s.Hdot_J_s || 0;
      }
      for (const s of outletStreams) {
        H_out += s.Hdot_J_s || 0;
      }
      
      // Account for heat and work streams (convert kW â†’ J/s)
      for (const p of def.ports) {
        const stream = ud.ports[p.portId];
        if (!stream) continue;
        
        if (stream.type === StreamType.HEAT) {
          if (p.dir === PortDir.IN) {
            H_in += (stream.available || 0) * 1000;  // kW â†’ J/s
          } else {
            H_out += (stream.demand || 0) * 1000;  // kW â†’ J/s
          }
        } else if (stream.type === StreamType.MECHANICAL || stream.type === StreamType.ELECTRICAL) {
          if (p.dir === PortDir.IN) {
            H_in += (stream.available || 0) * 1000;  // kW â†’ J/s
          }
        }
      }
      
      const energy_imbalance = Math.abs(H_in - H_out);
      if (energy_imbalance > 100) {  // 100 J/s = 0.1 kW tolerance
        // Store as info, not error (many units don't conserve energy perfectly yet)
        if (!ud.last.energyBalance) ud.last.energyBalance = {};
        ud.last.energyBalance.H_in = H_in / 1000;  // Display in kW
        ud.last.energyBalance.H_out = H_out / 1000;  // Display in kW
        ud.last.energyBalance.imbalance = energy_imbalance / 1000;  // Display in kW
      }
    }
  }
  
  // Store balance errors in runtime
  scene.runtime.balanceErrors = balanceErrors;

  // Store solve results
  const ok = !changed || iter < MAX_ITER;
  const warnings = [];
  if (!ok) warnings.push('Max iterations reached - loop may not have converged');
  if (balanceErrors.length > 0) {
    warnings.push(`${balanceErrors.length} mass balance violation(s) detected`);
  }
  
  scene.runtime.lastSolve = { ok, iterations: iter, warnings };
  
  // Diagnose errors and determine overall status
  const diagnostics = diagnoseErrors(scene);
  scene.runtime.diagnostics = diagnostics;
  
  // Determine worst severity level
  let maxSeverity = ErrorSeverity.MINOR.level;
  let hasErrors = diagnostics.length > 0;
  
  if (hasErrors) {
    maxSeverity = Math.max(...diagnostics.map(d => d.severity.level));
  }
  
  return { ok, diagnostics, maxSeverity, hasErrors };
}

// Update status indicator
function updateStatusIndicator(solveResult) {
  const indicator = document.getElementById('statusIndicator');
  const icon = indicator.querySelector('.status-icon');
  const text = indicator.querySelector('.status-text');
  const helpBtn = indicator.querySelector('.status-help');
  
  if (!solveResult) {
    // Not run yet
    indicator.style.display = 'none';
    return;
  }
  
  indicator.style.display = 'flex';
  
  // Remove all status classes
  indicator.className = 'status-indicator';
  
  if (!solveResult.ok) {
    // Convergence failure
    indicator.classList.add('critical');
    icon.textContent = 'ðŸ’¥';
    text.textContent = 'Convergence Failed';
    helpBtn.style.display = 'flex';
  } else if (!solveResult.hasErrors) {
    // Success
    indicator.classList.add('success');
    icon.textContent = 'âœ“';
    text.textContent = 'All Systems Operational';
    helpBtn.style.display = 'none';
  } else {
    // Has errors - determine severity
    const maxLevel = solveResult.maxSeverity;
    
    if (maxLevel >= ErrorSeverity.CATASTROPHIC.level) {
      indicator.classList.add('critical');
      icon.textContent = 'ðŸ’¥';
      text.textContent = 'Catastrophic Failure';
    } else if (maxLevel >= ErrorSeverity.MAJOR.level) {
      indicator.classList.add('error');
      icon.textContent = 'ðŸ”§';
      text.textContent = 'Equipment Damage';
    } else {
      indicator.classList.add('warning');
      icon.textContent = 'âš ï¸';
      text.textContent = 'Configuration Issues';
    }
    
    helpBtn.style.display = 'flex';
  }
}

// Show diagnosis dialog
function showDiagnosisDialog() {
  const diagnostics = scene.runtime.diagnostics || [];
  
  if (diagnostics.length === 0) {
    alert('No issues detected in the current simulation.');
    return;
  }
  
  // Create modal dialog
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: #1a1f2e;
    border: 2px solid #2a2f3a;
    border-radius: 16px;
    max-width: 700px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 24px;
    color: #e7e7e7;
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 20px;
    padding-bottom: 16px;
    border-bottom: 2px solid #2a2f3a;
  `;
  header.textContent = `ðŸ” Diagnosis Report (${diagnostics.length} issue${diagnostics.length > 1 ? 's' : ''})`;
  dialog.appendChild(header);
  
  // Group diagnostics by severity
  const critical = diagnostics.filter(d => d.severity.level === ErrorSeverity.CATASTROPHIC.level);
  const major = diagnostics.filter(d => d.severity.level === ErrorSeverity.MAJOR.level);
  const minor = diagnostics.filter(d => d.severity.level === ErrorSeverity.MINOR.level);
  
  const groups = [
    { name: 'CATASTROPHIC FAILURES', items: critical, color: '#ef4444', icon: 'ðŸ’¥' },
    { name: 'MAJOR DAMAGE', items: major, color: '#f97316', icon: 'ðŸ”§' },
    { name: 'WARNINGS', items: minor, color: '#fbbf24', icon: 'âš ï¸' }
  ];
  
  for (const group of groups) {
    if (group.items.length === 0) continue;
    
    const groupHeader = document.createElement('div');
    groupHeader.style.cssText = `
      font-size: 14px;
      font-weight: 700;
      color: ${group.color};
      margin: 20px 0 12px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    `;
    groupHeader.textContent = `${group.icon} ${group.name}`;
    dialog.appendChild(groupHeader);
    
    for (const diag of group.items) {
      const issueBox = document.createElement('div');
      issueBox.style.cssText = `
        background: ${group.color}11;
        border: 2px solid ${group.color};
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
      `;
      
      // Unit name
      const unitName = document.createElement('div');
      unitName.style.cssText = `
        font-weight: 700;
        font-size: 15px;
        margin-bottom: 8px;
        color: ${group.color};
      `;
      unitName.textContent = `${diag.unitName}`;
      issueBox.appendChild(unitName);
      
      // Title
      const title = document.createElement('div');
      title.style.cssText = `
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 8px;
      `;
      title.textContent = diag.title;
      issueBox.appendChild(title);
      
      // Explanation
      const explanation = document.createElement('div');
      explanation.style.cssText = `
        font-size: 13px;
        line-height: 1.5;
        opacity: 0.9;
        margin-bottom: 12px;
      `;
      explanation.textContent = diag.explanation;
      issueBox.appendChild(explanation);
      
      // Causes
      if (diag.causes && diag.causes.length > 0) {
        const causesTitle = document.createElement('div');
        causesTitle.style.cssText = `
          font-weight: 600;
          font-size: 12px;
          margin: 12px 0 6px 0;
          opacity: 0.8;
        `;
        causesTitle.textContent = 'POSSIBLE CAUSES:';
        issueBox.appendChild(causesTitle);
        
        const causesList = document.createElement('ul');
        causesList.style.cssText = `
          margin: 0;
          padding-left: 20px;
          font-size: 12px;
          line-height: 1.6;
          opacity: 0.8;
        `;
        for (const cause of diag.causes) {
          const li = document.createElement('li');
          li.textContent = cause;
          causesList.appendChild(li);
        }
        issueBox.appendChild(causesList);
      }
      
      // Fixes
      if (diag.fixes && diag.fixes.length > 0) {
        const fixesTitle = document.createElement('div');
        fixesTitle.style.cssText = `
          font-weight: 600;
          font-size: 12px;
          margin: 12px 0 6px 0;
          color: #22c55e;
        `;
        fixesTitle.textContent = 'âœ“ SUGGESTED FIXES:';
        issueBox.appendChild(fixesTitle);
        
        const fixesList = document.createElement('ul');
        fixesList.style.cssText = `
          margin: 0;
          padding-left: 20px;
          font-size: 12px;
          line-height: 1.6;
          color: #4ade80;
        `;
        for (const fix of diag.fixes) {
          const li = document.createElement('li');
          li.textContent = fix;
          fixesList.appendChild(li);
        }
        issueBox.appendChild(fixesList);
      }
      
      dialog.appendChild(issueBox);
    }
  }
  
  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.className = 'btn primary';
  closeBtn.style.cssText = `
    margin-top: 20px;
    width: 100%;
  `;
  closeBtn.onclick = () => modal.remove();
  dialog.appendChild(closeBtn);
  
  modal.appendChild(dialog);
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

/* =========================
   UI STATE
   ========================= */
const ui = {
  view: { x: 0, y: 0, w: 1056, h: 672 }, // Updated dynamically by setViewBox
  selectedUnitId: null,
  selectedConnId: null,
  pendingFrom: null, // Connection mode: {unitId, portId}
  isPanning: false,
  panStart: null,
  isDraggingUnit: false,
  dragUnitId: null,
  dragOffset: null, // {cellX, cellY} offset in grid units
  dragDefId: null,
  isHTML5Dragging: false, // Track HTML5 drag from library
  _mouseWorld: { x: 0, y: 0 }
};

/* =========================
   DOM REFERENCES
   ========================= */
const svg = document.getElementById('svg');
const ioEl = document.getElementById('io');
const propEditor = document.getElementById('propEditor');
const btnRun = document.getElementById('btnRun');
const btnAdd = document.getElementById('btnAdd');
const btnMenu = document.getElementById('btnMenu');
const btnFile = document.getElementById('btnFile');
const menuMain = document.getElementById('menuMain');
const menuFile = document.getElementById('menuFile');
const modalModels = document.getElementById('modalModels');
const modalUnits = document.getElementById('modalUnits');
const modalComponents = document.getElementById('modalComponents');
const modelsPanelEl = document.getElementById('modelsPanel');
const componentsPanelEl = document.getElementById('componentsPanel');

// Status is now managed within propEditor
let statusSection = null;
let statusContent = null;

/* =========================
   STREAM CALCULATIONS
   Helper functions for stream property calculations
   ========================= */
function calculateStreamFlowrates(stream) {
  if (!stream || stream.type !== StreamType.MATERIAL) return null;
  
  // Total molar flowrate
  const nTotal = Object.values(stream.n || {}).reduce((sum, val) => sum + val, 0);
  
  // Mass flowrate (kg/s) using thermo adapter
  const mTotal = thermo.streamMassFlow(stream);
  
  // Volumetric flowrate (mÂ³/s) â€” delegated to thermo adapter
  // (uses package-aware Z factor for vapor, density for liquid)
  const vTotal = thermo.streamVolFlow_m3ps(stream);
  
  return { nTotal, mTotal, vTotal };
}

/* =========================
   UI HELPER FUNCTIONS
   ========================= */
function setStatus(s) {
  // Create status section if it doesn't exist
  if (!statusSection) {
    const result = createCollapsibleSection('STATUS', false);
    statusSection = result.section;
    statusContent = result.content;
    
    // Append after propEditor card in the right panel
    const rightPanel = propEditor.parentNode;
    const controlsEl = rightPanel.querySelector('.controlsSection');
    if (controlsEl) {
      rightPanel.insertBefore(statusSection, controlsEl);
    } else {
      rightPanel.appendChild(statusSection);
    }
  }
  
  // Update status text
  statusContent.innerHTML = `<div class="status" style="padding:8px 0; white-space:pre-wrap; font-size:12px; opacity:0.9;">${s}</div>`;
  
  // Auto-expand on update
  const toggle = statusSection.querySelector('.sectionToggle');
  if (toggle && toggle.classList.contains('collapsed')) {
    toggle.classList.remove('collapsed');
    statusContent.classList.remove('collapsed');
  }
}

function closeMenus() {
  menuMain.classList.remove('open');
  menuFile.classList.remove('open');
}

function toggle(el) {
  el.classList.toggle('open');
}

/* =========================
   SVG HELPERS
   ========================= */
function svgEl(tag, attrs) {
  const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k, v] of Object.entries(attrs)) {
    e.setAttribute(k, String(v));
  }
  return e;
}

function clearSVG() {
  // Remove all children except <defs>
  // Find and preserve the defs element
  const defs = svg.querySelector('defs');
  
  // Remove all children
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }
  
  // Re-add defs if it existed
  if (defs) {
    svg.appendChild(defs);
  }
}

function screenToWorld(sx, sy) {
  const r = svg.getBoundingClientRect();
  const nx = (sx - r.left) / r.width;
  const ny = (sy - r.top) / r.height;
  return {
    x: ui.view.x + nx * ui.view.w,
    y: ui.view.y + ny * ui.view.h
  };
}

function worldToCell(wx, wy) {
  return {
    x: Math.floor(wx / scene.tile),
    y: Math.floor(wy / scene.tile)
  };
}

function setViewBox() {
  const rect = svg.getBoundingClientRect();
  const aspectRatio = rect.width / rect.height;
  
  // Initialize view dimensions if needed
  if (!ui.view.w || !ui.view.h) {
    const baseHeight = 672;
    ui.view.w = baseHeight * aspectRatio;
    ui.view.h = baseHeight;
  }
  
  svg.setAttribute('viewBox', `${ui.view.x} ${ui.view.y} ${ui.view.w} ${ui.view.h}`);
}

/* =========================
   PORT EDGE DETECTION
   Determines which edge of a unit a port is on
   ========================= */
function getPortEdge(port, unitDef) {
  const tolerance = 0.1; // Small tolerance for edge detection
  
  // Check if port is on left edge
  if (port.x <= tolerance) return 'left';
  
  // Check if port is on right edge
  if (port.x >= unitDef.w - tolerance) return 'right';
  
  // Check if port is on top edge
  if (port.y <= tolerance) return 'top';
  
  // Check if port is on bottom edge
  if (port.y >= unitDef.h - tolerance) return 'bottom';
  
  // Fallback: determine by which edge is closest
  const distToLeft = port.x;
  const distToRight = unitDef.w - port.x;
  const distToTop = port.y;
  const distToBottom = unitDef.h - port.y;
  
  const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
  
  if (minDist === distToLeft) return 'left';
  if (minDist === distToRight) return 'right';
  if (minDist === distToTop) return 'top';
  return 'bottom';
}

/* =========================
   RENDERING
   ========================= */
function drawGrid() {
  const g = svgEl('g', { id: 'grid' });
  const x1 = ui.view.x, y1 = ui.view.y;
  const x2 = ui.view.x + ui.view.w, y2 = ui.view.y + ui.view.h;
  const t = scene.tile;
  
  // Calculate visible grid range
  const startX = Math.floor(x1 / t) * t;
  const endX = Math.ceil(x2 / t) * t;
  const startY = Math.floor(y1 / t) * t;
  const endY = Math.ceil(y2 / t) * t;
  
  // Draw vertical lines
  for (let wx = startX; wx <= endX; wx += t) {
    g.appendChild(svgEl('line', {
      x1: wx, y1: startY,
      x2: wx, y2: endY,
      stroke: '#1e293b',
      opacity: 0.4,
      'stroke-width': 1
    }));
  }
  
  // Draw horizontal lines
  for (let wy = startY; wy <= endY; wy += t) {
    g.appendChild(svgEl('line', {
      x1: startX, y1: wy,
      x2: endX, y2: wy,
      stroke: '#1e293b',
      opacity: 0.4,
      'stroke-width': 1
    }));
  }
  
  svg.appendChild(g);
}

function drawConnections() {
  const g = svgEl('g', { id: 'connections' });
  
  // Draw existing connections
  for (const c of scene.connections) {
    const fromU = scene.units.get(c.from.unitId);
    const toU = scene.units.get(c.to.unitId);
    if (!fromU || !toU) continue;

    const fromDef = UnitRegistry.get(fromU.defId);
    const toDef = UnitRegistry.get(toU.defId);
    const fromPort = fromDef.ports.find(p => p.portId === c.from.portId);
    const toPort = toDef.ports.find(p => p.portId === c.to.portId);
    if (!fromPort || !toPort) continue;

    const fx = (fromU.x + fromPort.x) * scene.tile;
    const fy = (fromU.y + fromPort.y) * scene.tile;
    const tx = (toU.x + toPort.x) * scene.tile;
    const ty = (toU.y + toPort.y) * scene.tile;
    
    // Determine port edges for proper curve orientation
    const fromEdge = getPortEdge(fromPort, fromDef);
    const toEdge = getPortEdge(toPort, toDef);
    
    // Calculate control points perpendicular to each port's edge
    const controlOffset = 60; // Distance for control points
    
    let c1x, c1y, c2x, c2y;
    
    // From port control point (perpendicular to its edge)
    if (fromEdge === 'left') {
      c1x = fx - controlOffset;
      c1y = fy;
    } else if (fromEdge === 'right') {
      c1x = fx + controlOffset;
      c1y = fy;
    } else if (fromEdge === 'top') {
      c1x = fx;
      c1y = fy - controlOffset;
    } else { // bottom
      c1x = fx;
      c1y = fy + controlOffset;
    }
    
    // To port control point (perpendicular to its edge)
    if (toEdge === 'left') {
      c2x = tx - controlOffset;
      c2y = ty;
    } else if (toEdge === 'right') {
      c2x = tx + controlOffset;
      c2y = ty;
    } else if (toEdge === 'top') {
      c2x = tx;
      c2y = ty - controlOffset;
    } else { // bottom
      c2x = tx;
      c2y = ty + controlOffset;
    }
    
    const pathD = `M${fx},${fy} C${c1x},${c1y} ${c2x},${c2y} ${tx},${ty}`;

    // Get visual properties for this stream type
    const visuals = StreamVisuals[fromPort.type];
    const isSelected = ui.selectedConnId === c.id;
    
    // Power streams (electrical/mechanical) use dashed lines
    const isPowerStream = fromPort.type === StreamType.ELECTRICAL || 
                          fromPort.type === StreamType.MECHANICAL;

    const path = svgEl('path', {
      d: pathD,
      fill: 'none',
      stroke: isSelected ? '#60a5fa' : visuals.color,
      'stroke-width': isSelected ? 4 : 3,
      'stroke-dasharray': isPowerStream ? '8,4' : 'none',
      cursor: 'pointer'
    });

    path.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      ui.selectedConnId = c.id;
      ui.selectedUnitId = null;
      updatePropertiesPanel();
      render();
    });

    g.appendChild(path);
  }

  // Draw pending connection (during connection mode)
  if (ui.pendingFrom) {
    const u = scene.units.get(ui.pendingFrom.unitId);
    if (u) {
      const def = UnitRegistry.get(u.defId);
      const port = def.ports.find(p => p.portId === ui.pendingFrom.portId);
      if (port) {
        const fx = (u.x + port.x) * scene.tile;
        const fy = (u.y + port.y) * scene.tile;
        const mx = ui._mouseWorld.x;
        const my = ui._mouseWorld.y;
        
        const portEdge = getPortEdge(port, def);
        const controlOffset = 60;
        
        let c1x, c1y;
        if (portEdge === 'left') {
          c1x = fx - controlOffset;
          c1y = fy;
        } else if (portEdge === 'right') {
          c1x = fx + controlOffset;
          c1y = fy;
        } else if (portEdge === 'top') {
          c1x = fx;
          c1y = fy - controlOffset;
        } else { // bottom
          c1x = fx;
          c1y = fy + controlOffset;
        }
        
        const pathD = `M${fx},${fy} C${c1x},${c1y} ${mx},${my} ${mx},${my}`;
        
        const visuals = StreamVisuals[port.type];
        
        g.appendChild(svgEl('path', {
          d: pathD,
          fill: 'none',
          stroke: visuals.color,
          'stroke-width': 3,
          opacity: 0.7
        }));
      }
    }
  }

  svg.appendChild(g);
}

function drawUnits() {
  const g = svgEl('g', { id: 'units' });
  
  for (const [id, u] of scene.units) {
    const def = UnitRegistry.get(u.defId);
    const wx = u.x * scene.tile;
    const wy = u.y * scene.tile;
    const ww = def.w * scene.tile;
    const wh = def.h * scene.tile;
    
    const group = svgEl('g', {});
    
    // Unit rectangle
    const rect = svgEl('rect', {
      x: wx, y: wy,
      width: ww, height: wh,
      rx: 8,
      fill: def.color,
      stroke: ui.selectedUnitId === id ? '#60a5fa' : '#1e293b',
      'stroke-width': 3,
      cursor: 'grab'
    });

    rect.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      if (ui.pendingFrom) return;
      
      // Don't start dragging existing units during HTML5 drag from library
      if (ui.isHTML5Dragging) return;
      
      ui.selectedUnitId = id;
      ui.selectedConnId = null;
      ui.isDraggingUnit = true;
      ui.dragUnitId = id;
      
      const m = screenToWorld(ev.clientX, ev.clientY);
      // Store offset in grid cell units
      ui.dragOffset = {
        cellX: (m.x / scene.tile) - u.x,
        cellY: (m.y / scene.tile) - u.y
      };
      
      
      updatePropertiesPanel();
      render();
    });

    group.appendChild(rect);

    // Unit icon - map defId to icon name with proper precedence
    let iconName = def.defId;
    if (def.defId === 'battery') {
      iconName = 'electrical';
    } else if (def.defId === 'source_mechanical') {
      iconName = 'mechanical';
    } else if (def.defId === 'source') {
      iconName = 'source';
    }
    // Other units use their defId directly (pump, compressor, valve, motor, sink, heater, hex)
    
    const ico = svgEl('use', {
      x: wx + ww / 2 - 16,
      y: wy + wh / 2 - 16,
      width: 32,
      height: 32,
      fill: '#fff',
      opacity: 0.75,
      'pointer-events': 'none'
    });
    
    // Set href with both methods for compatibility
    ico.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#ico-${iconName}`);
    ico.setAttribute('href', `#ico-${iconName}`);
    
    group.appendChild(ico);

    // Unit label (using actual unit name)
    const label = svgEl('text', {
      x: wx + ww / 2,
      y: wy + wh + 14,
      'text-anchor': 'middle',
      'font-size': 10,
      'font-weight': 700,
      fill: '#e7e7e7',
      opacity: 0.9,
      'pointer-events': 'none',
      'data-unit-id': id  // Add data attribute for updates
    });
    label.textContent = u.name || def.name;
    group.appendChild(label);

    // Ports
    for (const p of def.ports) {
      const wp = {
        x: (u.x + p.x) * scene.tile,
        y: (u.y + p.y) * scene.tile
      };
      const portId = p.portId;
      const unitId = u.id;
      
      // Get color for this stream type
      const portVisuals = StreamVisuals[p.type];

      // Port circle with color coding
      const circle = svgEl('circle', {
        cx: wp.x,
        cy: wp.y,
        r: 10,
        fill: p.dir === PortDir.OUT ? portVisuals.portColor : '#1e293b',
        stroke: portVisuals.portColor,
        'stroke-width': 2.5,
        cursor: 'pointer'
      });

      circle.addEventListener('pointerdown', (ev) => {
        ev.stopPropagation();
        const port = p;
        
        if (port.dir === PortDir.OUT && !ui.pendingFrom) {
          // Start connection mode
          ui.selectedUnitId = null;
          ui.pendingFrom = { unitId, portId };
          ui.selectedConnId = null;
          setStatus('Connect: click a compatible IN port.');
          render();
          return;
        }
        
        if (port.dir === PortDir.IN && ui.pendingFrom) {
          // Complete connection
          const id = scene.connect(ui.pendingFrom, { unitId, portId });
          setStatus(id 
            ? 'Connection added.' 
            : 'Connection refused: port already connected or incompatible type.');
          ui.pendingFrom = null;
          updatePropertiesPanel();
          render();
        }
      });

      group.appendChild(circle);

      // Directional arrow - orient based on which edge the port is on
      const portEdge = getPortEdge(p, def);
      
      if (p.dir === PortDir.OUT) {
        // OUT port: arrow points OUTWARD from unit (away from center)
        let arrowPath;
        if (portEdge === 'top') {
          // Points UP (away from unit)
          arrowPath = `M${wp.x - 3},${wp.y + 2} L${wp.x + 3},${wp.y + 2} L${wp.x},${wp.y - 4} Z`;
        } else if (portEdge === 'bottom') {
          // Points DOWN (away from unit)
          arrowPath = `M${wp.x - 3},${wp.y - 2} L${wp.x + 3},${wp.y - 2} L${wp.x},${wp.y + 4} Z`;
        } else if (portEdge === 'right') {
          // Points RIGHT (away from unit) - REVERSED
          arrowPath = `M${wp.x - 2},${wp.y - 3} L${wp.x - 2},${wp.y + 3} L${wp.x + 4},${wp.y} Z`;
        } else { // left
          // Points LEFT (away from unit) - REVERSED
          arrowPath = `M${wp.x + 2},${wp.y - 3} L${wp.x + 2},${wp.y + 3} L${wp.x - 4},${wp.y} Z`;
        }
        const arrow = svgEl('path', {
          d: arrowPath,
          fill: '#0b0e14',
          'pointer-events': 'none'
        });
        group.appendChild(arrow);
      } else {
        // IN port: arrow points INWARD to unit (toward center)
        let arrowPath;
        if (portEdge === 'top') {
          // Points DOWN (into unit)
          arrowPath = `M${wp.x - 3},${wp.y - 2} L${wp.x + 3},${wp.y - 2} L${wp.x},${wp.y + 4} Z`;
        } else if (portEdge === 'bottom') {
          // Points UP (into unit)
          arrowPath = `M${wp.x - 3},${wp.y + 2} L${wp.x + 3},${wp.y + 2} L${wp.x},${wp.y - 4} Z`;
        } else if (portEdge === 'right') {
          // Points LEFT (into unit)
          arrowPath = `M${wp.x - 4},${wp.y} L${wp.x + 2},${wp.y - 3} L${wp.x + 2},${wp.y + 3} Z`;
        } else { // left
          // Points RIGHT (into unit)
          arrowPath = `M${wp.x + 4},${wp.y} L${wp.x - 2},${wp.y - 3} L${wp.x - 2},${wp.y + 3} Z`;
        }
        const arrow = svgEl('path', {
          d: arrowPath,
          fill: portVisuals.portColor,
          'pointer-events': 'none'
        });
        group.appendChild(arrow);
      }
    }

    g.appendChild(group);
  }
  
  svg.appendChild(g);
}

function render() {
  clearSVG();
  setViewBox();
  drawGrid();
  drawConnections();
  drawUnits();
}

/* =========================
   UNIT LIBRARY
   Displayed in right panel when "Add Unit" is clicked
   ========================= */
function showUnitLibrary() {
  propEditor.innerHTML = '';
  
  // Title
  const titleDiv = el('div', { 
    class: 'unitTitle', 
    style: 'cursor:default;',
    html: 'Add Unit' 
  });
  propEditor.appendChild(titleDiv);
  
  // Subtitle
  const subtitleDiv = el('div', { 
    class: 'unitSubtitle', 
    html: 'Drag a unit onto the canvas' 
  });
  propEditor.appendChild(subtitleDiv);
  
  // Organize units by category
  const byCategory = UnitRegistry.listByCategory();
  
  for (const [categoryName, units] of Object.entries(byCategory)) {
    // Category header
    const catHeader = el('div', {
      style: 'margin-top:16px; margin-bottom:8px; font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px; opacity:0.7;'
    });
    catHeader.textContent = categoryName;
    propEditor.appendChild(catHeader);
    
    // Units grid for this category
    const grid = el('div', { 
      class: 'unitLibraryGrid'
    });
    
    for (const def of units) {
      const card = document.createElement('div');
      card.className = 'unitLibraryCard';
      card.draggable = true;
      card.innerHTML = `
        <div class="name">
          <span class="swatch" style="background:${def.color}"></span>${def.name}
        </div>
        <div class="desc">${def.defId}</div>
      `;
      
      card.addEventListener('dragstart', (ev) => {
        ui.dragDefId = def.defId;
        ui.isHTML5Dragging = true;
        ev.dataTransfer.setData('text/plain', def.defId);
        ev.dataTransfer.effectAllowed = 'copy';
      });
      
      grid.appendChild(card);
    }
    
    propEditor.appendChild(grid);
  }
}

/* =========================
   UNITS PANEL
   ========================= */
function buildUnitsPanel() {
  const panel = document.getElementById('unitsPanel');
  panel.innerHTML = '';
  
  const unitsList = models.list('units');
  const activeId = models.active.units;
  
  for (const sys of unitsList) {
    const card = el('div', {
      class: 'modelCard',
      style: `cursor:pointer; padding:12px; margin-bottom:8px; border:1px solid ${sys.id === activeId ? '#3b82f6' : '#2a2f3a'}; border-radius:8px; background:${sys.id === activeId ? '#3b82f611' : 'transparent'};`
    });
    
    card.innerHTML = `
      <div style="font-weight:700; margin-bottom:4px;">${sys.name}</div>
      <div class="small">${sys.desc}</div>
    `;
    
    card.addEventListener('click', () => {
      models.setActive('units', sys.id);
      buildUnitsPanel();
      updatePropertiesPanel();
      render();
    });
    
    panel.appendChild(card);
  }
}

/* =========================
   COMPONENTS PANEL
   ========================= */
function buildComponentsPanel() {
  const panel = document.getElementById('componentsPanel');
  panel.innerHTML = '';
  
  // Create table
  const table = el('table', { 
    style: 'width:100%; border-collapse:collapse; font-size:11px;' 
  });
  
  // Header
  const thead = el('thead', {});
  const headerRow = el('tr', {});
  ['Formula', 'Name', 'MW', 'Tc (K)', 'Pc (bar)', 'Tb (K)'].forEach(text => {
    const th = el('th', { 
      style: 'text-align:left; padding:6px 4px; border-bottom:1px solid #2a2f3a; font-weight:700; opacity:0.8;' 
    });
    th.textContent = text;
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  // Body
  const tbody = el('tbody', {});
  for (const comp of ComponentRegistry.list()) {
    const row = el('tr', { 
      style: 'border-bottom:1px solid #2a2f3a22;' 
    });
    
    const cells = [
      { text: comp.formula, bold: true },
      { text: comp.name },
      { text: comp.MW.toFixed(3) },
      { text: comp.Tc.toFixed(1) },
      { text: (comp.Pc / 100000).toFixed(2) },
      { text: comp.Tb.toFixed(1) }
    ];
    
    cells.forEach(({ text, bold }) => {
      const td = el('td', { 
        style: `padding:6px 4px; ${bold ? 'font-weight:700; font-family:ui-monospace, monospace;' : ''}` 
      });
      td.textContent = text;
      row.appendChild(td);
    });
    
    tbody.appendChild(row);
  }
  table.appendChild(tbody);
  
  panel.appendChild(table);
}

/* =========================
   MODELS PANEL
   ========================= */
function buildModelsPanel() {
  modelsPanelEl.innerHTML = '';
  
  // â”€â”€ Thermo Package Section â”€â”€
  const pkgSection = document.createElement('div');
  pkgSection.className = 'card';
  
  const pkgTitle = document.createElement('div');
  pkgTitle.className = 'models-section-title';
  pkgTitle.textContent = 'Property Package';
  pkgSection.appendChild(pkgTitle);
  
  const packages = models.list('thermo_package');
  const activePkgId = models.active.thermo_package;
  
  for (const pkg of packages) {
    const card = document.createElement('div');
    card.className = 'pkg-card' + (pkg.id === activePkgId ? ' active' : '');
    card.dataset.pkgId = pkg.id;
    
    const radio = document.createElement('div');
    radio.className = 'radio';
    
    const info = document.createElement('div');
    
    const nameRow = document.createElement('div');
    nameRow.className = 'pkg-name';
    nameRow.textContent = pkg.name;
    
    if (pkg.status && pkg.status !== 'stable') {
      const badge = document.createElement('span');
      badge.className = 'pkg-badge ' + pkg.status;
      badge.textContent = pkg.status;
      nameRow.appendChild(badge);
    }
    
    const desc = document.createElement('div');
    desc.className = 'pkg-desc';
    desc.textContent = pkg.description;
    
    info.appendChild(nameRow);
    info.appendChild(desc);
    card.appendChild(radio);
    card.appendChild(info);
    
    card.addEventListener('click', () => {
      // Activate this package
      models.setActive('thermo_package', pkg.id);
      
      // Switch the actual thermo engine
      thermo.setPackage(pkg);
      
      // Update UI
      pkgSection.querySelectorAll('.pkg-card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      
      setStatus(`Thermo package: ${pkg.name}`);
      solveScene(scene);
      updatePropertiesPanel();
      render();
    });
    
    pkgSection.appendChild(card);
  }
  
  modelsPanelEl.appendChild(pkgSection);
  
  // â”€â”€ Auxiliary Models Section â”€â”€
  const auxKinds = [
    { kind: 'hx', label: 'Heat Exchanger' },
    { kind: 'pressure_drop', label: 'Pressure Drop' }
  ];
  
  // Only show auxiliary section if there are models to show
  const hasAux = auxKinds.some(a => models.list(a.kind).length > 0);
  if (hasAux) {
    const auxSection = document.createElement('div');
    auxSection.className = 'card';
    auxSection.style.marginTop = '10px';
    
    const auxTitle = document.createElement('div');
    auxTitle.className = 'models-section-title';
    auxTitle.textContent = 'Auxiliary Models';
    auxSection.appendChild(auxTitle);
    
    for (const { kind, label } of auxKinds) {
      const items = models.list(kind);
      if (items.length === 0) continue;
      
      const row = document.createElement('div');
      row.className = 'row';
      
      const lab = document.createElement('label');
      lab.textContent = label;
      
      const sel = document.createElement('select');
      for (const m of items) {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.name;
        opt.title = m.desc || '';
        sel.appendChild(opt);
      }
      sel.value = models.active[kind];
      
      sel.addEventListener('change', () => {
        models.setActive(kind, sel.value);
        setStatus(`Model changed: ${label} â†’ ${sel.options[sel.selectedIndex].text}`);
        solveScene(scene);
        updatePropertiesPanel();
        render();
      });
      
      row.appendChild(lab);
      row.appendChild(sel);
      auxSection.appendChild(row);
    }
    
    modelsPanelEl.appendChild(auxSection);
  }
}

/* =========================
   COMPONENTS PANEL
   Displays all registered components and their properties
   ========================= */
function buildComponentsPanel() {
  componentsPanelEl.innerHTML = '';
  
  const components = ComponentRegistry.list();
  
  if (components.length === 0) {
    componentsPanelEl.innerHTML = '<div style="padding:20px; opacity:0.6;">No components registered</div>';
    return;
  }
  
  // Validation summary button
  const validationBtn = el('button', {
    class: 'btn',
    style: 'margin-bottom: 12px; width: 100%;',
    html: 'ðŸ” Validate Component Database'
  });
  
  validationBtn.addEventListener('click', () => {
    const results = ComponentRegistry.validateAll();
    showValidationReport(results);
  });
  
  componentsPanelEl.appendChild(validationBtn);
  
  // Create table
  const table = el('table', { 
    style: 'width:100%; border-collapse:collapse; font-size:12px;'
  });
  
  // Header
  const thead = el('thead');
  const headerRow = el('tr', { 
    style: 'background:#1e293b; position:sticky; top:0; z-index:1;'
  });
  
  const headerCells = [
    'Formula',
    'Name',
    'MW',
    'Tc',
    'Pc',
    'Ï‰',
    'Tb',
    'Phase',
    'Details'
  ];
  
  for (const label of headerCells) {
    headerRow.appendChild(el('th', {
      style: 'padding:8px; text-align:left; border-bottom:2px solid #2a2f3a; font-weight:700; font-size:11px; text-transform:uppercase; letter-spacing:0.5px;',
      html: label
    }));
  }
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  // Body
  const tbody = el('tbody');
  
  for (const comp of components) {
    const row = el('tr', {
      style: 'border-bottom:1px solid #2a2f3a; cursor:pointer; transition:background 0.15s;'
    });
    
    row.addEventListener('mouseenter', () => {
      row.style.background = '#1e293b';
    });
    row.addEventListener('mouseleave', () => {
      row.style.background = 'transparent';
    });
    
    // Formula (bold)
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-weight:700; color:#60a5fa;',
      html: comp.formula
    }));
    
    // Name
    row.appendChild(el('td', {
      style: 'padding:10px 8px;',
      html: comp.name
    }));
    
    // MW
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.MW.toFixed(3)
    }));
    
    // Tc
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.Tc.toFixed(1) + ' K'
    }));
    
    // Pc
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: (comp.Pc / 100000).toFixed(2) + ' bar'
    }));
    
    // omega
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.omega.toFixed(3)
    }));
    
    // Tb
    row.appendChild(el('td', {
      style: 'padding:10px 8px; font-family:monospace;',
      html: comp.Tb.toFixed(1) + ' K'
    }));
    
    // Phase at 298K
    row.appendChild(el('td', {
      style: 'padding:10px 8px;',
      html: comp.phase298
    }));
    
    // Details button
    const detailsBtn = el('button', {
      class: 'btn',
      style: 'padding:4px 8px; font-size:11px; margin:0;',
      html: 'View'
    });
    
    detailsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      showComponentDetails(comp);
    });
    
    const td = el('td', { style: 'padding:10px 8px;' });
    td.appendChild(detailsBtn);
    row.appendChild(td);
    
    tbody.appendChild(row);
  }
  
  table.appendChild(tbody);
  componentsPanelEl.appendChild(table);
}

function showComponentDetails(comp) {
  // Create modal dialog
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: #1a1f2e;
    border: 2px solid #2a2f3a;
    border-radius: 16px;
    max-width: 800px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 24px;
    color: #e7e7e7;
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 8px;
    color: #60a5fa;
  `;
  header.textContent = `${comp.formula} â€” ${comp.name}`;
  dialog.appendChild(header);
  
  // CAS number
  if (comp.CAS) {
    const cas = document.createElement('div');
    cas.style.cssText = `
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 20px;
    `;
    cas.textContent = `CAS: ${comp.CAS}`;
    dialog.appendChild(cas);
  }
  
  // Properties grid
  const grid = document.createElement('div');
  grid.style.cssText = `
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 20px;
  `;
  
  function addProperty(label, value, unit = '') {
    if (value === null || value === undefined) return;
    
    const prop = document.createElement('div');
    prop.style.cssText = `
      background: #0f1419;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
    `;
    
    const labelEl = document.createElement('div');
    labelEl.style.cssText = `
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.7;
      margin-bottom: 6px;
    `;
    labelEl.textContent = label;
    prop.appendChild(labelEl);
    
    const valueEl = document.createElement('div');
    valueEl.style.cssText = `
      font-size: 15px;
      font-family: monospace;
    `;
    
    if (typeof value === 'object') {
      valueEl.textContent = JSON.stringify(value, null, 2);
      valueEl.style.fontSize = '12px';
      valueEl.style.whiteSpace = 'pre';
    } else {
      valueEl.textContent = value + (unit ? ' ' + unit : '');
    }
    
    prop.appendChild(valueEl);
    grid.appendChild(prop);
  }
  
  addProperty('Molecular Weight', comp.MW.toFixed(3), 'g/mol');
  addProperty('Critical Temperature', comp.Tc.toFixed(2), 'K');
  addProperty('Critical Pressure', (comp.Pc / 100000).toFixed(3), 'bar');
  addProperty('Acentric Factor', comp.omega.toFixed(3));
  addProperty('Normal Boiling Point', comp.Tb.toFixed(2), 'K');
  addProperty('Phase at 298K', comp.phase298);
  
  if (comp.Tm) addProperty('Melting Point', comp.Tm.toFixed(2), 'K');
  if (comp.Vc) addProperty('Critical Volume', (comp.Vc * 1e6).toFixed(2), 'cmÂ³/mol');
  if (comp.Zc) addProperty('Critical Z-factor', comp.Zc.toFixed(3));
  if (comp.Hv) addProperty('Heat of Vaporization', (comp.Hv / 1000).toFixed(1), 'kJ/mol');
  
  dialog.appendChild(grid);
  
  // Antoine coefficients (if present)
  if (comp.antoine) {
    const antoineSection = document.createElement('div');
    antoineSection.style.cssText = `
      background: #0f1419;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      margin-bottom: 12px;
    `;
    
    const title = document.createElement('div');
    title.style.cssText = `
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 8px;
      color: #fbbf24;
    `;
    title.textContent = 'Antoine Coefficients';
    antoineSection.appendChild(title);
    
    const equation = document.createElement('div');
    equation.style.cssText = `
      font-family: monospace;
      font-size: 12px;
      margin-bottom: 12px;
      padding: 8px;
      background: #1e293b;
      border-radius: 4px;
    `;
    equation.textContent = 'logâ‚â‚€(Psat[mmHg]) = A - B/(C + T[Â°C])';
    antoineSection.appendChild(equation);
    
    // Handle both single-range and multi-range Antoine
    const antoineRanges = Array.isArray(comp.antoine) ? comp.antoine : [comp.antoine];
    
    antoineRanges.forEach((range, idx) => {
      // For multi-range, add range header
      if (antoineRanges.length > 1) {
        const rangeHeader = document.createElement('div');
        rangeHeader.style.cssText = `
          font-size: 11px;
          font-weight: 600;
          margin-top: ${idx > 0 ? '12px' : '0'};
          margin-bottom: 6px;
          color: #94a3b8;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        `;
        rangeHeader.textContent = range.desc || `Range ${idx + 1}`;
        antoineSection.appendChild(rangeHeader);
      }
      
      const coeffs = document.createElement('div');
      coeffs.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        font-family: monospace;
        font-size: 12px;
      `;
      
      coeffs.innerHTML = `
        <div><strong>A:</strong> ${range.A.toFixed(5)}</div>
        <div><strong>B:</strong> ${range.B.toFixed(2)}</div>
        <div><strong>C:</strong> ${range.C.toFixed(2)}</div>
      `;
      antoineSection.appendChild(coeffs);
      
      if (range.Tmin || range.Tmax) {
        const rangeInfo = document.createElement('div');
        rangeInfo.style.cssText = `
          font-size: 11px;
          opacity: 0.7;
          margin-top: 6px;
        `;
        rangeInfo.textContent = `Valid: ${range.Tmin || '?'} - ${range.Tmax || '?'} K`;
        antoineSection.appendChild(rangeInfo);
      }
    });
    
    dialog.appendChild(antoineSection);
  }
  
  // Cp correlations (if present)
  if (comp.cpig) {
    const cpSection = document.createElement('div');
    cpSection.style.cssText = `
      background: #0f1419;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      margin-bottom: 12px;
    `;
    
    const title = document.createElement('div');
    title.style.cssText = `
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 8px;
      color: #22c55e;
    `;
    title.textContent = 'Ideal Gas Heat Capacity';
    cpSection.appendChild(title);
    
    const equation = document.createElement('div');
    equation.style.cssText = `
      font-family: monospace;
      font-size: 12px;
      margin-bottom: 12px;
      padding: 8px;
      background: #1e293b;
      border-radius: 4px;
    `;
    equation.textContent = 'Cp = A + BÂ·T + CÂ·TÂ² + DÂ·TÂ³ + EÂ·Tâ´  [J/(molÂ·K)]';
    cpSection.appendChild(equation);
    
    const coeffs = document.createElement('div');
    coeffs.style.cssText = `
      font-family: monospace;
      font-size: 12px;
    `;
    
    coeffs.innerHTML = `
      <div><strong>A:</strong> ${comp.cpig.A}</div>
      <div><strong>B:</strong> ${comp.cpig.B}</div>
      <div><strong>C:</strong> ${comp.cpig.C}</div>
      <div><strong>D:</strong> ${comp.cpig.D}</div>
      ${comp.cpig.E !== undefined ? `<div><strong>E:</strong> ${comp.cpig.E}</div>` : ''}
    `;
    cpSection.appendChild(coeffs);
    
    dialog.appendChild(cpSection);
  }
  
  if (comp.cpLiq) {
    const cpLiqSection = document.createElement('div');
    cpLiqSection.style.cssText = `
      background: #0f1419;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      margin-bottom: 12px;
      font-family: monospace;
      font-size: 12px;
    `;
    cpLiqSection.innerHTML = `<strong>Liquid Cp:</strong> ${typeof comp.cpLiq === 'number' ? comp.cpLiq.toFixed(1) + ' J/(molÂ·K)' : JSON.stringify(comp.cpLiq)}`;
    dialog.appendChild(cpLiqSection);
  }
  
  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.className = 'btn primary';
  closeBtn.style.cssText = `
    margin-top: 20px;
    width: 100%;
  `;
  closeBtn.onclick = () => modal.remove();
  dialog.appendChild(closeBtn);
  
  modal.appendChild(dialog);
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

function showValidationReport(results) {
  // Create modal dialog
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: #1a1f2e;
    border: 2px solid #2a2f3a;
    border-radius: 16px;
    max-width: 800px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 24px;
    color: #e7e7e7;
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 20px;
    color: #60a5fa;
  `;
  header.textContent = 'Component Database Validation Report';
  dialog.appendChild(header);
  
  // Summary
  let totalErrors = 0;
  let totalWarnings = 0;
  let validComponents = 0;
  
  for (const [formula, result] of Object.entries(results)) {
    if (result.valid) validComponents++;
    totalErrors += result.errors.length;
    totalWarnings += result.warnings.length;
  }
  
  const summary = document.createElement('div');
  summary.style.cssText = `
    background: ${totalErrors === 0 ? '#0f2d1a' : '#2d1a0f'};
    border: 2px solid ${totalErrors === 0 ? '#22c55e' : '#ef4444'};
    padding: 16px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-weight: 700;
  `;
  
  summary.innerHTML = `
    <div style="font-size: 16px; margin-bottom: 8px;">
      ${totalErrors === 0 ? 'âœ… All Components Valid' : 'âš ï¸ Validation Issues Found'}
    </div>
    <div style="font-size: 13px; opacity: 0.9;">
      ${validComponents}/${Object.keys(results).length} components valid â€¢ 
      ${totalErrors} errors â€¢ 
      ${totalWarnings} warnings
    </div>
  `;
  dialog.appendChild(summary);
  
  // Per-component results
  for (const [formula, result] of Object.entries(results)) {
    const compSection = document.createElement('div');
    compSection.style.cssText = `
      background: #0f1419;
      border: 1px solid ${result.valid ? '#2a2f3a' : '#ef4444'};
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 12px;
    `;
    
    const compHeader = document.createElement('div');
    compHeader.style.cssText = `
      font-weight: 700;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    `;
    compHeader.innerHTML = `
      <span style="color: ${result.valid ? '#22c55e' : '#ef4444'};">
        ${result.valid ? 'âœ“' : 'âœ—'}
      </span>
      <span style="color: #60a5fa;">${formula}</span>
      <span style="opacity: 0.7;">â€” ${ComponentRegistry.get(formula).name}</span>
    `;
    compSection.appendChild(compHeader);
    
    // Errors
    if (result.errors.length > 0) {
      const errorsDiv = document.createElement('div');
      errorsDiv.style.cssText = `
        margin-top: 8px;
        padding: 8px;
        background: #2d1a0f;
        border-radius: 4px;
      `;
      
      const errorsHeader = document.createElement('div');
      errorsHeader.style.cssText = `
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        color: #ef4444;
        margin-bottom: 6px;
      `;
      errorsHeader.textContent = `Errors (${result.errors.length})`;
      errorsDiv.appendChild(errorsHeader);
      
      const errorsList = document.createElement('ul');
      errorsList.style.cssText = `
        margin: 0;
        padding-left: 20px;
        font-size: 12px;
      `;
      for (const error of result.errors) {
        const li = document.createElement('li');
        li.textContent = error;
        li.style.marginBottom = '4px';
        errorsList.appendChild(li);
      }
      errorsDiv.appendChild(errorsList);
      compSection.appendChild(errorsDiv);
    }
    
    // Warnings
    if (result.warnings.length > 0) {
      const warningsDiv = document.createElement('div');
      warningsDiv.style.cssText = `
        margin-top: 8px;
        padding: 8px;
        background: #1e1a0f;
        border-radius: 4px;
      `;
      
      const warningsHeader = document.createElement('div');
      warningsHeader.style.cssText = `
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        color: #fbbf24;
        margin-bottom: 6px;
      `;
      warningsHeader.textContent = `Warnings (${result.warnings.length})`;
      warningsDiv.appendChild(warningsHeader);
      
      const warningsList = document.createElement('ul');
      warningsList.style.cssText = `
        margin: 0;
        padding-left: 20px;
        font-size: 12px;
      `;
      for (const warning of result.warnings) {
        const li = document.createElement('li');
        li.textContent = warning;
        li.style.marginBottom = '4px';
        warningsList.appendChild(li);
      }
      warningsDiv.appendChild(warningsList);
      compSection.appendChild(warningsDiv);
    }
    
    // Success message if no issues
    if (result.errors.length === 0 && result.warnings.length === 0) {
      const successMsg = document.createElement('div');
      successMsg.style.cssText = `
        font-size: 12px;
        color: #22c55e;
        margin-top: 8px;
      `;
      successMsg.textContent = 'All required properties present';
      compSection.appendChild(successMsg);
    }
    
    dialog.appendChild(compSection);
  }
  
  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.className = 'btn primary';
  closeBtn.style.cssText = `
    margin-top: 20px;
    width: 100%;
  `;
  closeBtn.onclick = () => modal.remove();
  dialog.appendChild(closeBtn);
  
  modal.appendChild(dialog);
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

/* =========================
   PROPERTIES PANEL
   ========================= */
function el(tag, attrs = {}, children = []) {
  const e = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs)) {
    if (k === 'class') e.className = v;
    else if (k === 'html') e.innerHTML = v;
    else e.setAttribute(k, v);
  }
  for (const c of children) e.appendChild(c);
  return e;
}

function addNumberEditor(container, label, get, set, step = 0.1) {
  const row = el('div', { class: 'row' });
  row.appendChild(el('label', { html: label }));
  
  const inp = el('input', { type: 'number', step: String(step) });
  inp.value = String(get() ?? '');
  inp.addEventListener('input', () => { set(Number(inp.value)); });
  
  row.appendChild(inp);
  container.appendChild(row);
}

function addSelectEditor(container, label, get, set, options) {
  const row = el('div', { class: 'row' });
  row.appendChild(el('label', { html: label }));
  
  const sel = el('select', {});
  for (const [val, txt] of options) {
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = txt;
    sel.appendChild(opt);
  }
  sel.value = get();
  sel.addEventListener('change', () => {
    set(sel.value);
    updatePropertiesPanel();
  });
  
  row.appendChild(sel);
  container.appendChild(row);
}

function createCollapsibleSection(title, isOpen = true) {
  const section = el('div', { class: 'borderedSection' });
  
  const header = el('div', { class: 'sectionHeader' });
  header.innerHTML = `
    <span>${title}</span>
    <span class="sectionToggle ${isOpen ? '' : 'collapsed'}">â–¼</span>
  `;
  
  const content = el('div', { 
    class: `sectionContent ${isOpen ? '' : 'collapsed'}` 
  });
  
  header.addEventListener('click', () => {
    const toggle = header.querySelector('.sectionToggle');
    toggle.classList.toggle('collapsed');
    content.classList.toggle('collapsed');
  });
  
  section.appendChild(header);
  section.appendChild(content);
  
  return { section, content };
}

function createCollapsibleSubSection(title, isOpen = true) {
  const section = el('div', { class: 'subSection' });
  
  const header = el('div', { class: 'subSectionHeader' });
  header.innerHTML = `
    <span>${title}</span>
    <span class="subSectionToggle ${isOpen ? '' : 'collapsed'}">â–¼</span>
  `;
  
  const content = el('div', { 
    class: `subSectionContent ${isOpen ? '' : 'collapsed'}` 
  });
  
  header.addEventListener('click', () => {
    const toggle = header.querySelector('.subSectionToggle');
    toggle.classList.toggle('collapsed');
    content.classList.toggle('collapsed');
  });
  
  section.appendChild(header);
  section.appendChild(content);
  
  return { section, content };
}

function renderStreamProperties(container, s) {
  if (!s) {
    container.appendChild(el('div', { 
      class: 'small', 
      html: 'No data available' 
    }));
    return;
  }

  const unitSys = models.getActive('units');
  const propGrid = el('div', { class: 'propGrid' });
  
  if (s.type === StreamType.MATERIAL) {
    // GROUP 1: Temperature & Pressure
    propGrid.appendChild(el('div', { 
      style: 'grid-column:1/-1; margin-top:4px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
      html: 'Conditions'
    }));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Temperature' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.temperature.from(s.T).toFixed(unitSys.temperature.decimals)}<span class="propUnit">${unitSys.temperature.symbol}</span>` 
      })
    ]));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Pressure' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.pressure.from(s.P).toFixed(unitSys.pressure.decimals)}<span class="propUnit">${unitSys.pressure.symbol}</span>` 
      })
    ]));
    
    // GROUP 2: Phase & Composition
    propGrid.appendChild(el('div', { 
      style: 'grid-column:1/-1; margin-top:12px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
      html: 'Phase & Composition'
    }));
    
    const phaseText = s.phase === 'V' ? 'Vapor' : 
                      s.phase === 'L' ? 'Liquid' : 
                      s.phase === 'VL' ? `Two-Phase (Î²=${s.vaporFraction.toFixed(3)})` : 
                      'Unknown';
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Phase' }),
      el('div', { 
        class: 'propValue', 
        style: 'font-size:12px;',
        html: phaseText
      })
    ]));
    
    // Calculate flowrates
    const flowrates = calculateStreamFlowrates(s);
    
    // Composition
    const components = Object.keys(s.n || {})
      .filter(k => s.n[k] > 1e-9)
      .sort((a, b) => s.n[b] - s.n[a]);
      
    if (components.length) {
      const compSection = el('div', { style: 'grid-column:1/-1; margin-top:6px;' });
      compSection.appendChild(el('div', { 
        class: 'propLabel', 
        html: 'Components', 
        style: 'margin-bottom:6px;' 
      }));
      
      const compWrap = el('div', { style: 'display:flex; flex-wrap:wrap; gap:4px;' });
      for (const comp of components) {
        const n = s.n[comp];
        const molFrac = flowrates.nTotal > 0 ? (n / flowrates.nTotal) : 0;
        const badge = el('div', { class: 'compBadge' });
        badge.innerHTML = `<span class="spec">${comp}</span><span class="pct">${(100 * molFrac).toFixed(1)}%</span>`;
        compWrap.appendChild(badge);
      }
      compSection.appendChild(compWrap);
      propGrid.appendChild(compSection);
    }
    
    // GROUP 3: Flowrates
    propGrid.appendChild(el('div', { 
      style: 'grid-column:1/-1; margin-top:12px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
      html: 'Flowrates'
    }));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Molar' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.molarFlow.from(flowrates.nTotal).toFixed(unitSys.molarFlow.decimals)}<span class="propUnit">${unitSys.molarFlow.symbol}</span>` 
      })
    ]));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Mass' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.massFlow.from(flowrates.mTotal).toFixed(unitSys.massFlow.decimals)}<span class="propUnit">${unitSys.massFlow.symbol}</span>` 
      })
    ]));
    
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Volumetric' }),
      el('div', { 
        class: 'propValue', 
        html: `${unitSys.volumeFlow.from(flowrates.vTotal).toFixed(unitSys.volumeFlow.decimals)}<span class="propUnit">${unitSys.volumeFlow.symbol}</span>` 
      })
    ]));
    
    // GROUP 4: Enthalpy (Energy Balance)
    if (s.hMolarMix !== undefined || s.Hdot_J_s !== undefined) {
      propGrid.appendChild(el('div', { 
        style: 'grid-column:1/-1; margin-top:12px; margin-bottom:6px; font-size:11px; font-weight:700; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px;',
        html: 'Energy (Enthalpy)'
      }));
      
      if (s.hMolarMix !== undefined) {
        propGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Molar Enthalpy' }),
          el('div', { 
            class: 'propValue', 
            html: `${formatEnthalpy_kJmol(s.hMolarMix)}<span class="propUnit">kJ/mol</span>` 
          })
        ]));
      }
      
      if (s.Hdot_J_s !== undefined) {
        propGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Enthalpy Flow' }),
          el('div', { 
            class: 'propValue', 
            html: `${formatPower_kW(s.Hdot_J_s)}<span class="propUnit">kW</span>` 
          })
        ]));
      }
    }
    
  } else if (s.type === StreamType.ELECTRICAL || s.type === StreamType.MECHANICAL) {
    // Power streams show available capacity and current demand (internal W â†’ display kW)
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Available' }),
      el('div', { 
        class: 'propValue', 
        html: `${((s.available || 0)/1000).toFixed(1)}<span class="propUnit">kW</span>` 
      })
    ]));
    
    if (s.demand !== undefined) {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Demand' }),
        el('div', { 
          class: 'propValue', 
          html: `${(s.demand/1000).toFixed(1)}<span class="propUnit">kW</span>` 
        })
      ]));
      
      // Utilization bar (ratio is dimensionless â€” same units cancel)
      const util = s.available > 0 ? (s.demand / s.available) : 0;
      const bar = el('div', { class: 'bar', style: 'margin-top:8px;' });
      const fill = el('div', {});
      fill.style.width = `${clamp(util, 0, 1) * 100}%`;
      fill.style.background = util > 1.0 ? '#ef4444' : util > 0.8 ? '#f97316' : '#22c55e';
      bar.appendChild(fill);
      propGrid.appendChild(bar);
      propGrid.appendChild(el('div', { 
        class: 'kv', 
        style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
        html: `<span>0%</span><span>${(util * 100).toFixed(0)}%</span><span>100%</span>` 
      }));
    }
  } else if (s.type === StreamType.HEAT) {
    // Heat streams: show available and demand (internal W â†’ display kW)
    propGrid.appendChild(el('div', { class: 'propItem' }, [
      el('div', { class: 'propLabel', html: 'Available' }),
      el('div', { 
        class: 'propValue', 
        html: `${((s.available || 0)/1000).toFixed(1)}<span class="propUnit">kW</span>` 
      })
    ]));
    
    if (s.demand !== undefined && s.demand > 0) {
      propGrid.appendChild(el('div', { class: 'propItem' }, [
        el('div', { class: 'propLabel', html: 'Demand' }),
        el('div', { 
          class: 'propValue', 
          html: `${(s.demand/1000).toFixed(1)}<span class="propUnit">kW</span>` 
        })
      ]));
      
      // Utilization bar
      const util = s.available > 0 ? (s.demand / s.available) : 0;
      const bar = el('div', { class: 'bar', style: 'margin-top:8px;' });
      const fill = el('div', {});
      fill.style.width = `${clamp(util, 0, 1) * 100}%`;
      fill.style.background = util > 1.0 ? '#ef4444' : util > 0.8 ? '#f97316' : '#22c55e';
      bar.appendChild(fill);
      propGrid.appendChild(bar);
      propGrid.appendChild(el('div', { 
        class: 'kv', 
        style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
        html: `<span>0%</span><span>${(util * 100).toFixed(0)}%</span><span>100%</span>` 
      }));
    }
  }
  
  container.appendChild(propGrid);
}

function updatePropertiesPanel() {
  propEditor.innerHTML = '';
  
  // UNIT SELECTED
  if (ui.selectedUnitId) {
    const u = scene.units.get(ui.selectedUnitId);
    if (!u) {
      ui.selectedUnitId = null;
      return updatePropertiesPanel();
    }
    
    const def = UnitRegistry.get(u.defId);
    
    // Header (no border): Unit name + type + category
    const headerDiv = el('div', { class: 'unitHeader' });
    
    const titleDiv = el('div', { class: 'unitTitle' });
    const nameInput = el('input', { 
      type: 'text', 
      value: u.name || `${def.name} ${u.id.slice(-2)}` 
    });
    nameInput.addEventListener('input', () => {
      u.name = nameInput.value;
      // Update label on canvas immediately
      const label = svg.querySelector(`[data-unit-id="${u.id}"]`);
      if (label) label.textContent = u.name;
    });
    nameInput.addEventListener('blur', () => {
      if (!nameInput.value.trim()) {
        u.name = `${def.name} ${u.id.slice(-2)}`;
        nameInput.value = u.name;
      }
    });
    titleDiv.appendChild(nameInput);
    headerDiv.appendChild(titleDiv);
    
    const subtitleDiv = el('div', { 
      class: 'unitSubtitle', 
      html: `${def.defId} Â· <span style="color:${def.color}">${def.category}</span>` 
    });
    headerDiv.appendChild(subtitleDiv);
    
    propEditor.appendChild(headerDiv);

    // Bordered Section 1: Parameters (only for units with editable parameters)
    if (u.defId === 'source') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      // Build species dropdown from ComponentRegistry
      const speciesOptions = ComponentRegistry.list().map(comp => 
        [comp.formula, comp.formula]  // Display formula, value is formula
      );
      
      addSelectEditor(paramsSection.content, 'Species', 
        () => u.params.species, 
        v => u.params.species = v, 
        speciesOptions
      );
      
      // Pressure with unit conversion
      addNumberEditor(paramsSection.content, `P (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.P), 
        v => u.params.P = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      // Temperature with unit conversion
      addNumberEditor(paramsSection.content, `T (${unitSys.temperature.symbol})`, 
        () => unitSys.temperature.from(u.params.T + 273.15), 
        v => u.params.T = unitSys.temperature.to(v) - 273.15, 
        1
      );
      
      // Molar flow with unit conversion
      addNumberEditor(paramsSection.content, `á¹… (${unitSys.molarFlow.symbol})`, 
        () => unitSys.molarFlow.from(u.params.nDot), 
        v => u.params.nDot = unitSys.molarFlow.to(v), 
        0.1
      );
      
      // Phase constraint
      if (!u.params.phaseConstraint) u.params.phaseConstraint = 'VL';
      addSelectEditor(paramsSection.content, 'Phase', 
        () => u.params.phaseConstraint, 
        v => u.params.phaseConstraint = v, 
        [['V', 'Vapor only'], ['L', 'Liquid only'], ['VL', 'Vapor-Liquid (flash)']]
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'battery' || u.defId === 'source_mechanical') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (!u.params.maxPower) u.params.maxPower = 1000;
      addNumberEditor(paramsSection.content, 'Max Power (kW)', 
        () => u.params.maxPower, 
        v => u.params.maxPower = v, 
        10
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'motor') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (!u.params.eta) u.params.eta = 0.92;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'electric_heater') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (!u.params.eta) u.params.eta = 0.99;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'valve') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 101325;
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'pump') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 500000;
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      if (!u.params.eta) u.params.eta = 0.70;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'compressor') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (!u.params.Pout) u.params.Pout = 200000;
      addNumberEditor(paramsSection.content, `P outlet (${unitSys.pressure.symbol})`, 
        () => unitSys.pressure.from(u.params.Pout), 
        v => u.params.Pout = unitSys.pressure.to(v), 
        unitSys.pressure.decimals === 0 ? 1000 : 0.1
      );
      
      if (!u.params.eta) u.params.eta = 0.75;
      addNumberEditor(paramsSection.content, 'Efficiency (-)', 
        () => u.params.eta, 
        v => u.params.eta = v, 
        0.01
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    // Heater parameters
    if (u.defId === 'heater') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      if (u.params.T_out === undefined) u.params.T_out = 150;  // Default 150Â°C
      addNumberEditor(paramsSection.content, `T outlet setpoint (${unitSys.temperature.symbol})`, 
        () => unitSys.temperature.from(u.params.T_out + 273.15), 
        v => { u.params.T_out = unitSys.temperature.to(v) - 273.15; },
        1
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    // Two-Stream Heat Exchanger parameters
    if (u.defId === 'hex') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      const unitSys = models.getActive('units');
      
      const modeLabel = el('div', { 
        class: 'small', 
        style: 'margin-bottom:8px; opacity:0.8;',
        html: 'Specify approach temp OR one outlet temperature:'
      });
      paramsSection.content.appendChild(modeLabel);
      
      if (u.params.T_approach === undefined) u.params.T_approach = 10;
      addNumberEditor(paramsSection.content, 'Approach Î”T (K)', 
        () => u.params.T_approach, 
        v => { u.params.T_approach = v; u.params.T_hot_out = undefined; u.params.T_cold_out = undefined; },
        1
      );
      
      addNumberEditor(paramsSection.content, `T hot out (${unitSys.temperature.symbol})`, 
        () => u.params.T_hot_out !== undefined ? unitSys.temperature.from(u.params.T_hot_out + 273.15) : '', 
        v => { u.params.T_hot_out = unitSys.temperature.to(v) - 273.15; u.params.T_approach = 0; u.params.T_cold_out = undefined; },
        1
      );
      
      addNumberEditor(paramsSection.content, `T cold out (${unitSys.temperature.symbol})`, 
        () => u.params.T_cold_out !== undefined ? unitSys.temperature.from(u.params.T_cold_out + 273.15) : '', 
        v => { u.params.T_cold_out = unitSys.temperature.to(v) - 273.15; u.params.T_approach = 0; u.params.T_hot_out = undefined; },
        1
      );
      
      propEditor.appendChild(paramsSection.section);
    }
    
    if (u.defId === 'splitter') {
      const paramsSection = createCollapsibleSection('Parameters', true);
      
      if (u.params.splitPct === undefined) u.params.splitPct = 50;
      addNumberEditor(paramsSection.content, 'Split to out1 (%)', 
        () => u.params.splitPct, 
        v => u.params.splitPct = Math.max(0, Math.min(100, v)), 
        1
      );
      
      propEditor.appendChild(paramsSection.section);
    }

    // Bordered Section 2: Properties
    const ud = scene.runtime.unitData.get(u.id);
    const propsSection = createCollapsibleSection('Properties', true);

    if (!ud) {
      propsSection.content.appendChild(el('div', { 
        class: 'small', 
        style: 'padding: 8px 0; opacity:0.6;',
        html: 'Not computed yet â€” press Run' 
      }));
    } else if (u.defId === 'sink') {
      // For sink, show incoming stream properties in Properties section
      if (ud.last && ud.last.stream) {
        renderStreamProperties(propsSection.content, ud.last.stream);
      } else {
        propsSection.content.appendChild(el('div', { 
          class: 'small', 
          style: 'padding: 8px 0; opacity:0.6;',
          html: 'No incoming stream' 
        }));
      }
    } else {
      // Check for unit-level errors first (like phase violations)
      if (ud.last && ud.last.error) {
        const err = ud.last.error;
        const sev = err.severity || ErrorSeverity.MINOR;
        
        propsSection.content.appendChild(el('div', { 
          style: `padding:12px; margin-bottom:12px; background:${sev.color}22; border:2px solid ${sev.color}; border-radius:8px;`, 
        }, [
          el('div', { 
            style: `font-size:14px; font-weight:700; color:${sev.color}; margin-bottom:4px;`,
            html: `${sev.icon} ${sev.prefix}`
          }),
          el('div', { 
            style: 'font-size:13px; opacity:0.9;',
            html: err.message
          })
        ]));
      }
      
      // Special display for power-consuming equipment
      if ((u.defId === 'compressor' || u.defId === 'pump') && ud.last && ud.last.W_shaft !== undefined) {
        const powerBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        
        const titleDiv = el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power Consumption' 
        });
        powerBox.appendChild(titleDiv);
        
        const dataGrid = el('div', { class: 'propGrid' });
        
        // Shaft power (required)
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Shaft Power' }),
          el('div', { 
            class: 'propValue', 
            html: `${ud.last.W_shaft.toFixed(2)}<span class="propUnit">kW</span>` 
          })
        ]));
        
        // Hydraulic/Isentropic power
        if (ud.last.W_hydraulic !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Hydraulic' }),
            el('div', { 
              class: 'propValue', 
              html: `${ud.last.W_hydraulic.toFixed(2)}<span class="propUnit">kW</span>` 
            })
          ]));
        } else if (ud.last.W_isentropic !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Isentropic' }),
            el('div', { 
              class: 'propValue', 
              html: `${ud.last.W_isentropic.toFixed(2)}<span class="propUnit">kW</span>` 
            })
          ]));
        }
        
        // Efficiency
        if (ud.last.eta !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Efficiency' }),
            el('div', { 
              class: 'propValue', 
              html: `${(ud.last.eta * 100).toFixed(0)}<span class="propUnit">%</span>` 
            })
          ]));
        }
        
        powerBox.appendChild(dataGrid);
        propsSection.content.appendChild(powerBox);
      }
      
      // Special display for heater (setpoint vs actual)
      if (u.defId === 'heater' && ud.last && ud.last.T_setpoint_C !== undefined) {
        const unitSys = models.getActive('units');
        const heatBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        heatBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”¥ Heat Duty' 
        }));
        
        const dataGrid = el('div', { class: 'propGrid' });
        
        // T setpoint
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'T setpoint' }),
          el('div', { class: 'propValue', 
            html: `${unitSys.temperature.from(ud.last.T_setpoint_C + 273.15).toFixed(1)}<span class="propUnit">${unitSys.temperature.symbol}</span>` 
          })
        ]));
        
        // T actual (from PH flash)
        const matOut = ud.ports?.mat_out;
        if (matOut && matOut.T) {
          const T_actual_disp = unitSys.temperature.from(matOut.T);
          const T_set_disp = unitSys.temperature.from(ud.last.T_setpoint_C + 273.15);
          const deviation = Math.abs(T_actual_disp - T_set_disp);
          const devColor = deviation > 1 ? '#f97316' : '#22c55e';
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'T actual' }),
            el('div', { class: 'propValue', style: `color:${devColor};`,
              html: `${T_actual_disp.toFixed(1)}<span class="propUnit">${unitSys.temperature.symbol}</span>` 
            })
          ]));
        }
        
        // Q demand vs actual (internal W â†’ display kW)
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Q demand' }),
          el('div', { class: 'propValue', 
            html: `${(ud.last.Q_demand_W/1000).toFixed(2)}<span class="propUnit">kW</span>` 
          })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Q actual' }),
          el('div', { class: 'propValue', 
            style: ud.last.supplyLimited ? 'color:#f97316;' : '',
            html: `${(ud.last.Q_actual_W/1000).toFixed(2)}<span class="propUnit">kW</span>` 
          })
        ]));
        
        heatBox.appendChild(dataGrid);
        propsSection.content.appendChild(heatBox);
      }
      
      // Special display for motor (actual power, not capacity)
      if (u.defId === 'motor' && ud.last && ud.last.W_elec_W !== undefined) {
        const convBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        convBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power Conversion' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Electrical in' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_elec_W/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Mechanical out' }),
          el('div', { class: 'propValue', html: `${(ud.last.W_mech_W/1000).toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Efficiency' }),
          el('div', { class: 'propValue', html: `${ud.last.efficiency_pct}<span class="propUnit">%</span>` })
        ]));
        convBox.appendChild(dataGrid);
        propsSection.content.appendChild(convBox);
      }
      
      // Special display for electric heater (actual power, not capacity)
      if (u.defId === 'electric_heater' && ud.last) {
        const convBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        convBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'âš¡ Power â†’ Heat' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        const Welec = (ud.last.W_elec_available_W || 0) / 1000;
        const Qheat = (ud.last.Q_available_W || 0) / 1000;
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Electrical in' }),
          el('div', { class: 'propValue', html: `${Welec.toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Heat out' }),
          el('div', { class: 'propValue', html: `${Qheat.toFixed(2)}<span class="propUnit">kW</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Efficiency' }),
          el('div', { class: 'propValue', html: `${ud.last.efficiency_pct}<span class="propUnit">%</span>` })
        ]));
        convBox.appendChild(dataGrid);
        propsSection.content.appendChild(convBox);
      }
      
      // Special display for LV separator (phase split)
      if (u.defId === 'flash_drum' && ud.last && ud.last.nTotal > 0) {
        const unitSys = models.getActive('units');
        const sepBox = el('div', { style: 'margin-bottom:16px; padding:12px; background:#1e293b; border-radius:8px;' });
        sepBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:8px; opacity:0.8; text-transform:uppercase;', 
          html: 'ðŸ”¬ Phase Split' 
        }));
        const dataGrid = el('div', { class: 'propGrid' });
        
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Inlet phase' }),
          el('div', { class: 'propValue', html: ud.last.phase === 'VL' ? 'Two-Phase' : ud.last.phase === 'V' ? 'Vapor' : 'Liquid' })
        ]));
        
        if (ud.last.beta !== null && ud.last.beta !== undefined) {
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: 'Vapor fraction' }),
            el('div', { class: 'propValue', html: `${(ud.last.beta * 100).toFixed(1)}<span class="propUnit">%</span>` })
          ]));
        }
        
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Vapor flow' }),
          el('div', { class: 'propValue', html: `${ud.last.nV_total.toFixed(3)}<span class="propUnit">mol/s</span>` })
        ]));
        dataGrid.appendChild(el('div', { class: 'propItem' }, [
          el('div', { class: 'propLabel', html: 'Liquid flow' }),
          el('div', { class: 'propValue', html: `${ud.last.nL_total.toFixed(3)}<span class="propUnit">mol/s</span>` })
        ]));
        
        // V/L split bar
        const vPct = ud.last.vap_pct || 0;
        const bar = el('div', { class: 'bar', style: 'margin-top:8px; display:flex; border-radius:4px; overflow:hidden;' });
        if (vPct > 0.1) {
          const vFill = el('div', { style: `width:${vPct}%; background:#60a5fa; height:8px;` });
          bar.appendChild(vFill);
        }
        if (vPct < 99.9) {
          const lFill = el('div', { style: `width:${100-vPct}%; background:#f472b6; height:8px;` });
          bar.appendChild(lFill);
        }
        dataGrid.appendChild(bar);
        dataGrid.appendChild(el('div', { 
          class: 'kv', 
          style: 'font-size:10px; opacity:0.6; margin-top:4px;', 
          html: `<span style="color:#60a5fa">V ${vPct.toFixed(1)}%</span><span style="color:#f472b6">L ${(100-vPct).toFixed(1)}%</span>` 
        }));
        
        sepBox.appendChild(dataGrid);
        propsSection.content.appendChild(sepBox);
      }
      
      // Output ports
      for (const p of def.ports) {
        if (p.dir !== PortDir.OUT) continue;
        const s = ud.ports[p.portId];
        const portBox = el('div', { style: 'margin-bottom:12px;' });
        portBox.appendChild(el('div', { 
          class: 'small', 
          style: 'font-weight:700; margin-bottom:6px; opacity:0.8;', 
          html: `${p.portId}` 
        }));
        renderStreamProperties(portBox, s);
        propsSection.content.appendChild(portBox);
      }
      
      // General errors from solver
      if (ud.errors?.length) {
        propsSection.content.appendChild(el('div', { 
          class: 'small', 
          style: 'color:#ef4444; margin-top:8px; padding:8px; background:#7f1d1d22; border-radius:8px;', 
          html: `âš  ${ud.errors.join('; ')}` 
        }));
      }
      
      // Subsection: Details (inside Properties, closed by default)
      if (ud.last && Object.keys(ud.last).length) {
        const detailsSubSection = createCollapsibleSubSection('Details', false);
        
        const dataGrid = el('div', { class: 'propGrid' });
        for (const [key, value] of Object.entries(ud.last)) {
          // Skip error object (already displayed above)
          if (key === 'error') continue;
          
          dataGrid.appendChild(el('div', { class: 'propItem' }, [
            el('div', { class: 'propLabel', html: key }),
            el('div', { 
              class: 'propValue', 
              style: 'font-size:12px;', 
              html: typeof value === 'number' ? value.toFixed(3) : String(value) 
            })
          ]));
        }
        detailsSubSection.content.appendChild(dataGrid);
        propsSection.content.appendChild(detailsSubSection.section);
      }
    }

    propEditor.appendChild(propsSection.section);
    return;
  }

  // STREAM SELECTED
  if (ui.selectedConnId) {
    const c = scene.connections.find(x => x.id === ui.selectedConnId);
    if (!c) {
      ui.selectedConnId = null;
      return updatePropertiesPanel();
    }
    
    const fromU = scene.units.get(c.from.unitId);
    const toU = scene.units.get(c.to.unitId);
    
    // Header (no border): Stream title
    const headerDiv = el('div', { class: 'unitHeader' });
    
    const titleDiv = el('div', { 
      class: 'unitTitle', 
      style: 'cursor:default;',
      html: 'Stream' 
    });
    headerDiv.appendChild(titleDiv);
    
    const subtitleDiv = el('div', { 
      class: 'unitSubtitle', 
      html: `${fromU?.name || '?'} â†’ ${toU?.name || '?'}` 
    });
    headerDiv.appendChild(subtitleDiv);
    
    propEditor.appendChild(headerDiv);
    
    // Bordered Section: Properties
    const propsSection = createCollapsibleSection('Properties', true);
    
    const fromUD = scene.runtime.unitData.get(c.from.unitId);
    const s = fromUD?.ports?.[c.from.portId] || null;
    renderStreamProperties(propsSection.content, s);
    
    propEditor.appendChild(propsSection.section);
    return;
  }

  // NOTHING SELECTED
  const emptyDiv = el('div', { 
    class: 'small', 
    style: 'padding:40px 20px; text-align:center; opacity:0.5;',
    html: 'Click a unit or stream to inspect' 
  });
  propEditor.appendChild(emptyDiv);
}

function describeSolve() {
  const ls = scene.runtime.lastSolve;
  if (!scene.units.size) return 'Empty scene.';
  
  let txt = ls.ok 
    ? `âœ… Converged in ${ls.iterations} iteration(s)\n` 
    : `âš  ${ls.warnings.join(' | ')}\n`;
  txt += `Units: ${scene.units.size} Â· Connections: ${scene.connections.length}\n`;
  txt += `Models: ` + Object.entries(models.active)
    .map(([k, v]) => `${k}:${v}`)
    .join(' Â· ');
  return txt;
}

/* =========================
   EVENT HANDLERS
   ========================= */
function deselectAll() {
  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  updatePropertiesPanel();
  render();
}

function rotateSelected() {
  if (!ui.selectedUnitId) return;
  scene.rotateUnit(ui.selectedUnitId);
  render();
  updatePropertiesPanel();
}

function deleteSelected() {
  if (ui.selectedUnitId) {
    scene.deleteUnit(ui.selectedUnitId);
    ui.selectedUnitId = null;
    updatePropertiesPanel();
    render();
  } else if (ui.selectedConnId) {
    // Delete stream
    scene.connections = scene.connections.filter(c => c.id !== ui.selectedConnId);
    ui.selectedConnId = null;
    updatePropertiesPanel();
    render();
  }
}

// SVG Events
svg.addEventListener('pointerdown', (ev) => {
  closeMenus();
  
  // Pan mode: Shift+click OR middle mouse button
  if (ev.shiftKey || ev.button === 1) {
    ev.preventDefault(); // Prevent default middle-click behavior
    ui.isPanning = true;
    ui.panStart = { 
      x: ev.clientX, 
      y: ev.clientY, 
      view: { ...ui.view } 
    };
    svg.setPointerCapture(ev.pointerId);
    return;
  }

  const w = screenToWorld(ev.clientX, ev.clientY);
  const cell = worldToCell(w.x, w.y);
  const existing = scene.unitAt(cell.x, cell.y);
  
  if (!existing) {
    if (ui.pendingFrom) {
      ui.pendingFrom = null;
      setStatus('Connect cancelled.');
      
      render();
      return;
    }
    ui.selectedUnitId = null;
    ui.selectedConnId = null;
    
    updatePropertiesPanel();
    render();
  }
});

svg.addEventListener('pointermove', (ev) => {
  ui._mouseWorld = screenToWorld(ev.clientX, ev.clientY);

  // Panning
  if (ui.isPanning && ui.panStart) {
    const dx = ev.clientX - ui.panStart.x;
    const dy = ev.clientY - ui.panStart.y;
    const rect = svg.getBoundingClientRect();
    const wx = dx / rect.width * ui.panStart.view.w;
    const wy = dy / rect.height * ui.panStart.view.h;
    ui.view.x = ui.panStart.view.x - wx;
    ui.view.y = ui.panStart.view.y - wy;
    render();
    return;
  }

  // Unit dragging
  if (ui.isDraggingUnit && ui.dragUnitId && ui.dragOffset) {
    const u = scene.units.get(ui.dragUnitId);
    if (u) {
      const wpos = ui._mouseWorld;
      const cellX = (wpos.x / scene.tile) - ui.dragOffset.cellX;
      const cellY = (wpos.y / scene.tile) - ui.dragOffset.cellY;
      const nx = Math.round(cellX);
      const ny = Math.round(cellY);
      scene.moveUnit(u.id, nx, ny);
      render();
    }
    return;
  }

  // Redraw pending connection
  if (ui.pendingFrom) render();
});

svg.addEventListener('pointerup', () => {
  ui.isPanning = false;
  ui.panStart = null;

  if (ui.isDraggingUnit) {
    ui.isDraggingUnit = false;
    ui.dragUnitId = null;
    ui.dragOffset = null;
    
    updatePropertiesPanel();
    render();
  }
});

svg.addEventListener('wheel', (ev) => {
  ev.preventDefault();
  const z = (ev.deltaY < 0) ? 0.9 : 1.1;
  const m = screenToWorld(ev.clientX, ev.clientY);
  const v = ui.view;
  const newW = v.w * z;
  const newH = v.h * z;
  const rx = (m.x - v.x) / v.w;
  const ry = (m.y - v.y) / v.h;
  v.x = m.x - rx * newW;
  v.y = m.y - ry * newH;
  v.w = newW;
  v.h = newH;
  render();
}, { passive: false });

// Drag & drop from unit library
svg.addEventListener('dragover', (ev) => {
  ev.preventDefault();
  ev.dataTransfer.dropEffect = 'copy';
});

svg.addEventListener('dragleave', (ev) => {
  // Clear flag if drag leaves the canvas without dropping
  if (ev.target === svg) {
    ui.isHTML5Dragging = false;
  }
});

svg.addEventListener('drop', (ev) => {
  ev.preventDefault();
  const defId = ev.dataTransfer.getData('text/plain') || ui.dragDefId;
  if (!defId) return;
  
  const w = screenToWorld(ev.clientX, ev.clientY);
  const cell = worldToCell(w.x, w.y);
  const id = scene.placeUnit(defId, cell.x, cell.y);
  
  if (!id) {
    setStatus('Cannot place here (collision).');
    ui.dragDefId = null;
    ui.isHTML5Dragging = false;
    return;
  }
  
  ui.selectedUnitId = id;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  ui.dragDefId = null;
  ui.isHTML5Dragging = false;
  setStatus(`Placed: ${UnitRegistry.get(defId).name}`);
  
  updatePropertiesPanel();
  render();
});

// Keyboard shortcuts
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'Escape') {
    ui.pendingFrom = null;
    closeMenus();
    setStatus('Cancelled.');
    
    render();
  }
  if (ev.key.toLowerCase() === 'r') rotateSelected();
  if (ev.key === 'Delete') deleteSelected();
});

/* =========================
   BUTTONS & MENUS
   ========================= */
btnRun.addEventListener('click', () => {
  const solveResult = solveScene(scene);
  setStatus(describeSolve());
  updateStatusIndicator(solveResult);
  updatePropertiesPanel();
  render();
});

// Status indicator help button
const statusHelp = document.querySelector('.status-help');
if (statusHelp) {
  statusHelp.addEventListener('click', (ev) => {
    ev.stopPropagation();
    showDiagnosisDialog();
  });
}

btnAdd.addEventListener('click', () => {
  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  showUnitLibrary();
  
  render();
});

// Status card toggle
btnMenu.addEventListener('click', (ev) => {
  ev.stopPropagation();
  menuFile.classList.remove('open');
  toggle(menuMain);
});

btnFile.addEventListener('click', (ev) => {
  ev.stopPropagation();
  menuMain.classList.remove('open');
  toggle(menuFile);
});

document.addEventListener('pointerdown', (ev) => {
  const t = ev.target;
  if (!(t.closest && (t.closest('.menuWrap') || t.closest('.menu')))) {
    closeMenus();
  }
});

document.getElementById('mComponents').addEventListener('click', () => {
  buildComponentsPanel();
  modalComponents.classList.add('open');
  closeMenus();
});

document.getElementById('mModels').addEventListener('click', () => {
  buildModelsPanel();  // Rebuild to reflect current state
  modalModels.classList.add('open');
  closeMenus();
});

document.getElementById('mUnits').addEventListener('click', () => {
  buildUnitsPanel();
  modalUnits.classList.add('open');
  closeMenus();
});

// Close modals when clicking outside
modalModels.addEventListener('click', (ev) => {
  if (ev.target === modalModels) {
    modalModels.classList.remove('open');
  }
});

modalUnits.addEventListener('click', (ev) => {
  if (ev.target === modalUnits) {
    modalUnits.classList.remove('open');
  }
});

modalComponents.addEventListener('click', (ev) => {
  if (ev.target === modalComponents) {
    modalComponents.classList.remove('open');
  }
});

document.getElementById('mLoadDemo').addEventListener('click', () => {
  if (confirm('Load demo? This will replace the current scene.')) {
    loadDemo();
  }
  closeMenus();
});

document.getElementById('mClear').addEventListener('click', () => {
  if (confirm('Clear the entire scene? This cannot be undone.')) {
    scene.importJSON(JSON.stringify({
      version: 8,
      grid: { w: 22, h: 14, tile: 48 },
      units: [],
      connections: [],
      modelsActive: models.active
    }));
    deselectAll();
    setStatus('Scene cleared.');
  }
  closeMenus();
});

document.getElementById('mExport').addEventListener('click', () => {
  ioEl.value = scene.exportJSON();
  navigator.clipboard.writeText(ioEl.value)
    .then(() => {
      setStatus('Export copied to clipboard!');
    })
    .catch(() => {
      setStatus('Export: ' + ioEl.value);
    });
  closeMenus();
});

document.getElementById('mImport').addEventListener('click', () => {
  const jsonStr = prompt('Paste JSON data:');
  if (!jsonStr) return;
  
  try {
    scene.importJSON(jsonStr);
    buildModelsPanel();
    deselectAll();
    setStatus('Import OK.');
  } catch (e) {
    setStatus('Import failed: ' + e.message);
  }
  closeMenus();
});

/* =========================
   DEMO
   ========================= */
function loadDemo() {
  scene.importJSON(JSON.stringify({
    version: 9,
    grid: { w: 22, h: 14, tile: 48 },
    units: [
      // â”€â”€ Construct A: Electric Heater Chain â”€â”€
      // ElecSource â†’ ElecHeater â†’ Heater â† N2 Source â†’ Sink
      { id: 'elec-a', defId: 'battery', name: 'Grid A', x: 1, y: 1, rot: 0, 
        params: { maxPower: 100 } },
      { id: 'eh-a', defId: 'electric_heater', name: 'E.Heater', x: 5, y: 1, rot: 0, 
        params: { eta: 0.99 } },
      { id: 'src-a', defId: 'source', name: 'N2 Feed', x: 5, y: 5, rot: 0, 
        params: { species: 'N2', P: 200000, T: 27, nDot: 10.0, phaseConstraint: 'V' } },
      { id: 'htr-a', defId: 'heater', name: 'Heater', x: 9, y: 3, rot: 0, 
        params: { T_out: 200 } },
      { id: 'snk-a', defId: 'sink', name: 'Hot N2', x: 13, y: 3, rot: 0, 
        params: {} },
      
      // â”€â”€ Construct B: Motor + Compressor Chain â”€â”€
      // ElecSource â†’ Motor â†’ Compressor â† H2O Source â†’ Sink
      { id: 'elec-b', defId: 'battery', name: 'Grid B', x: 1, y: 8, rot: 0, 
        params: { maxPower: 100 } },
      { id: 'motor-b', defId: 'motor', name: 'Motor', x: 5, y: 8, rot: 0, 
        params: { eta: 0.92 } },
      { id: 'src-b', defId: 'source', name: 'H2O Feed', x: 5, y: 12, rot: 0, 
        params: { species: 'H2O', P: 100000, T: 125, nDot: 1.0, phaseConstraint: 'VL' } },
      { id: 'comp-b', defId: 'compressor', name: 'Compressor', x: 9, y: 10, rot: 0, 
        params: { Pout: 500000, eta: 0.75 } },
      { id: 'snk-b', defId: 'sink', name: 'Product', x: 13, y: 10, rot: 0, 
        params: {} },
    ],
    connections: [
      // Construct A connections
      { id: 'a1', from: { unitId: 'elec-a', portId: 'out' }, 
        to: { unitId: 'eh-a', portId: 'elec_in' } },
      { id: 'a2', from: { unitId: 'eh-a', portId: 'heat_out' }, 
        to: { unitId: 'htr-a', portId: 'heat_in' } },
      { id: 'a3', from: { unitId: 'src-a', portId: 'out' }, 
        to: { unitId: 'htr-a', portId: 'mat_in' } },
      { id: 'a4', from: { unitId: 'htr-a', portId: 'mat_out' }, 
        to: { unitId: 'snk-a', portId: 'in' } },
      
      // Construct B connections
      { id: 'b1', from: { unitId: 'elec-b', portId: 'out' }, 
        to: { unitId: 'motor-b', portId: 'elec_in' } },
      { id: 'b2', from: { unitId: 'motor-b', portId: 'mech_out' }, 
        to: { unitId: 'comp-b', portId: 'power_in' } },
      { id: 'b3', from: { unitId: 'src-b', portId: 'out' }, 
        to: { unitId: 'comp-b', portId: 'mat_in' } },
      { id: 'b4', from: { unitId: 'comp-b', portId: 'mat_out' }, 
        to: { unitId: 'snk-b', portId: 'in' } },
    ],
    modelsActive: models.active
  }));

  ui.selectedUnitId = null;
  ui.selectedConnId = null;
  ui.pendingFrom = null;
  const solveResult = solveScene(scene);
  setStatus(describeSolve() + "\nDemo: Electric heater (top) + Compressor (bottom).");
  updateStatusIndicator(solveResult);
  
  updatePropertiesPanel();
  render();
}

/* =========================
   INITIALIZATION
   ========================= */
buildModelsPanel();
buildComponentsPanel();

// Initialize viewport and handle window resize
window.addEventListener('resize', () => {
  setViewBox();
  render();
});

setViewBox();

updatePropertiesPanel();
render();
loadDemo();

/* =========================
   COMPREHENSIVE END-TO-END TEST SUITE
   
   Builds actual flowsheets, runs solver, validates results.
   Tests validate complete integration: units â†’ solver â†’ flash â†’ energy balance.
   
   To add a new test:
   1. Increment testCount
   2. Create test name variable: const testXName = 'Test Name';
   3. Build topology with scene.placeUnit()
   4. Set unit parameters (match unit contract!)
   5. Create connections with proper structure: {from: {unitId, portId}, to: {unitId, portId}}
   6. Run solveScene(scene)
   7. Extract results from scene.runtime.unitData.get(unitId).ports
   8. Use checkTolerance() for numerical validation
   9. Track results: testResults.push({name, passed, failed, success})
   10. Wrap in try/catch/finally with restoreScene()
   
   Run: runPHFlashTests()
   Debug mode: Set DEBUG_MODE = true for detailed logging
   ========================= */
function runPHFlashTests() {
  // DEBUG MODE: Set to false for clean output, true for detailed debugging
  const DEBUG_MODE = false;
  
  function debugLog(...args) {
    if (DEBUG_MODE) console.log(...args);
  }
  
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('   END-TO-END PH FLASH TEST SUITE');
  console.log('   Builds flowsheets, runs solver, validates thermodynamics');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  let passCount = 0;
  let failCount = 0;
  let testCount = 0;
  const testResults = [];  // Track results for summary
  
  // Helper: Record test result
  function recordTestResult(testName, testPassed, testFailed, testNum) {
    const success = testFailed.length === 0;
    testResults.push({
      name: testName,
      passed: testPassed.length,
      failed: testFailed.length,
      success: success
    });
    console.log(`\n${success ? 'âœ“' : 'âœ—'} TEST ${testNum}: ${success ? 'PASS' : 'FAIL'} (${testPassed.length}/${testPassed.length + testFailed.length} checks)\n`);
    return success;
  }
  
  // Helper: Record test error
  function recordTestError(testName, errorMsg, expectedChecks, testNum) {
    failCount += expectedChecks;
    testResults.push({
      name: testName,
      passed: 0,
      failed: expectedChecks,
      success: false,
      error: errorMsg
    });
    console.log(`\nâœ— TEST ${testNum} FAILED WITH ERROR: ${errorMsg}\n`);
  }
  
  // Helper: tolerance check - returns result object for tabular display
  function checkTolerance(actual, expected, tolerance, name, testPassedArr, testFailedArr) {
    // Check if actual value exists
    if (actual === undefined || actual === null || isNaN(actual)) {
      failCount++;
      testFailedArr.push(name);
      return { name, calc: 'N/A', ref: expected, delta: 'N/A', tol: tolerance, status: 'âœ—', pass: false };
    }
    
    const diff = Math.abs(actual - expected);
    const pass = diff <= tolerance;
    
    if (pass) {
      passCount++;
      testPassedArr.push(name);
    } else {
      failCount++;
      testFailedArr.push(name);
    }
    
    return {
      name,
      calc: actual,
      ref: expected,
      delta: diff,
      tol: tolerance,
      status: pass ? 'âœ“' : 'âœ—',
      pass
    };
  }
  
  // Helper: Print results table
  function printResultsTable(results, title = null) {
    if (title) console.log(`\n  ${title}:`);
    console.log(`  â”Œ${'â”€'.repeat(78)}â”`);
    console.log(`  â”‚ Parameter          Calculated    Reference     Delta       Tolerance  Status â”‚`);
    console.log(`  â”œ${'â”€'.repeat(78)}â”¤`);
    
    for (const r of results) {
      const name = r.name.padEnd(18);
      const calc = (typeof r.calc === 'number' ? r.calc.toFixed(4) : r.calc).padEnd(13);
      const ref = (typeof r.ref === 'number' ? r.ref.toFixed(4) : r.ref).padEnd(13);
      const delta = (typeof r.delta === 'number' ? r.delta.toFixed(4) : r.delta).padEnd(11);
      const tol = (typeof r.tol === 'number' ? `Â±${r.tol.toFixed(4)}` : r.tol).padEnd(10);
      const status = r.status.padEnd(6);
      console.log(`  â”‚ ${name} ${calc} ${ref} ${delta} ${tol} ${status} â”‚`);
    }
    
    console.log(`  â””${'â”€'.repeat(78)}â”˜`);
  }
  
  // Helper: save current scene
  debugLog('[DEBUG] Saving scene...');
  debugLog('[DEBUG] scene.units type:', scene.units.constructor.name);
  debugLog('[DEBUG] scene.units size:', scene.units instanceof Map ? scene.units.size : 'not a Map');
  
  const savedScene = {
    units: scene.units instanceof Map ? Array.from(scene.units.entries()) : [],
    connections: Array.isArray(scene.connections) ? [...scene.connections] : [],
    idCounter: scene._idCounter || 0
  };
  
  debugLog('[DEBUG] Scene saved. Units:', savedScene.units.length, 'Connections:', savedScene.connections.length);
  
  // Helper: restore scene
  function restoreScene() {
    debugLog('[DEBUG] Restoring scene...');
    
    if (scene.units instanceof Map) {
      scene.units.clear();
      for (const [id, unit] of savedScene.units) {
        scene.units.set(id, unit);
      }
    }
    
    scene.connections = [...savedScene.connections];
    scene._idCounter = savedScene.idCounter;
    
    debugLog('[DEBUG] Scene restored. Units:', scene.units.size, 'Connections:', scene.connections.length);
  }
  
  // Helper: clear scene for test
  function clearScene() {
    if (scene.units instanceof Map) {
      scene.units.clear();
    } else {
      scene.units = new Map();
    }
    
    scene.connections = [];
    scene._idCounter = 0;
    
    debugLog('[DEBUG] Scene cleared. Units:', scene.units.size);
  }
  
  // =================================================================
  // END-TO-END TEST SUITE
  // =================================================================
  console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('  END-TO-END TEST SUITE');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
  
  // =================================================================
  // TEST 1: Water Throttling Flash
  // =================================================================
  testCount++;
  const test1Name = 'Water Throttling Flash';
  console.log(`Test ${testCount}: ${test1Name}`);
  console.log(`  Topology: Source (H2O) â†’ Valve â†’ Sink`);
  console.log(`  Scenario: Liquid at 200Â°C, 20 bar â†’ 2 bar`);
  
  debugLog('[DEBUG] Starting TEST 1 execution...');
  
  try {
    debugLog('[DEBUG] Clearing scene...');
    clearScene();
    debugLog('[DEBUG] Scene cleared. Units:', scene.units.size);
    
    // Build topology
    const sourceId = scene.placeUnit('source', 0, 0);
    const valveId = scene.placeUnit('valve', 3, 0);
    const sinkId = scene.placeUnit('sink', 6, 0);
    
    if (!sourceId || !valveId || !sinkId) {
      throw new Error('Failed to create units');
    }
    
    debugLog(`[DEBUG] Created units: source=${sourceId}, valve=${valveId}, sink=${sinkId}`);
    
    // Set parameters
    const source = scene.units.get(sourceId);
    source.params = {
      species: 'H2O',      // âœ“ Correct key (was 'component')
      nDot: 10,            // âœ“ Correct key (was 'molarFlow')
      T: 200,              // âœ“ Â°C (Source converts to K)
      P: 2000000,          // âœ“ Pa (was 'P_bar: 20')
      phaseConstraint: 'L' // âœ“ Force subcooled liquid
    };
    
    const valve = scene.units.get(valveId);
    valve.params = {
      Pout: 200000  // 2 bar = 200,000 Pa
    };
    
    // Create connections
    scene.connections.push({
      id: 'conn1',
      from: { unitId: sourceId, portId: 'out' },
      to: { unitId: valveId, portId: 'in' }
    });
    scene.connections.push({
      id: 'conn2',
      from: { unitId: valveId, portId: 'out' },
      to: { unitId: sinkId, portId: 'in' }
    });
    
    debugLog('[DEBUG] Connections created:', scene.connections.length);
    debugLog('[DEBUG] Connection 1:', scene.connections[scene.connections.length - 2]);
    debugLog('[DEBUG] Connection 2:', scene.connections[scene.connections.length - 1]);
    
    // Run solver
    const solveResult = solveScene(scene);
    debugLog('[DEBUG] Solver returned:', solveResult);
    debugLog('[DEBUG] Runtime lastSolve:', scene.runtime.lastSolve);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    // Solver converged
    
    // PREFLIGHT: Verify source stream
    debugLog('[DEBUG] Preflight: Checking source stream validity...');
    const sourceRuntimeData = scene.runtime.unitData.get(sourceId);
    const sourceStream = sourceRuntimeData?.ports?.out;
    
    if (!sourceStream || !sourceStream.T || !sourceStream.P || !sourceStream.n) {
      throw new Error(`Preflight failed: Invalid source stream. ${JSON.stringify(sourceStream)}`);
    }
    
    debugLog('[DEBUG] Preflight passed:', sourceStream);
    
    // Extract valve results
    const valveRuntimeData = scene.runtime.unitData.get(valveId);
    const valveOutlet = valveRuntimeData?.ports?.out;
    
    if (!valveOutlet) {
      throw new Error('No valve outlet stream');
    }
    
    // Validation
    const test1Passed = [];
    const test1Failed = [];
    const results = [];
    
    // Temperature
    results.push(checkTolerance(valveOutlet.T, 393.475, 0.2, 'T [K]', test1Passed, test1Failed));
    
    // Beta (vapor fraction)
    results.push(checkTolerance(valveOutlet.beta || 0, 0.150650, 0.002, 'beta', test1Passed, test1Failed));
    
    // Vapor flow
    results.push(checkTolerance(valveOutlet.nV?.H2O || 0, 1.506502, 0.02, 'nV[H2O] [mol/s]', test1Passed, test1Failed));
    
    // Liquid flow
    results.push(checkTolerance(valveOutlet.nL?.H2O || 0, 8.493498, 0.02, 'nL[H2O] [mol/s]', test1Passed, test1Failed));
    
    // Phase (categorical check)
    const phasePass = valveOutlet.phase === 'VL';
    results.push({
      name: 'Phase',
      calc: valveOutlet.phase,
      ref: 'VL',
      delta: phasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: phasePass ? 'âœ“' : 'âœ—',
      pass: phasePass
    });
    if (phasePass) {
      passCount++;
      test1Passed.push('Phase');
    } else {
      failCount++;
      test1Failed.push('Phase');
    }
    
    // Energy balance (internal units: J/s)
    const sourceOutlet = sourceStream;
    if (sourceOutlet?.Hdot_J_s !== undefined && valveOutlet.Hdot_J_s !== undefined) {
      const H_diff_J_s = Math.abs(valveOutlet.Hdot_J_s - sourceOutlet.Hdot_J_s);
      const energyPass = H_diff_J_s <= 10;  // 10 J/s = 0.01 kW
      results.push({
        name: 'Î”H [J/s]',
        calc: valveOutlet.Hdot_J_s,
        ref: sourceOutlet.Hdot_J_s,
        delta: H_diff_J_s,
        tol: 10,
        status: energyPass ? 'âœ“' : 'âœ—',
        pass: energyPass
      });
      if (energyPass) {
        passCount++;
        test1Passed.push('Energy');
      } else {
        failCount++;
        test1Failed.push('Energy');
      }
    }
    
    printResultsTable(results, null);
    
    const test1Success = test1Failed.length === 0;
    recordTestResult(test1Name, test1Passed, test1Failed, 1);
    
  } catch (err) {
    recordTestError(test1Name, err.message, 6, 1);
    debugLog('Stack trace:', err.stack);
  } finally {
    debugLog('[DEBUG] Restoring scene...');
    restoreScene();
  }
  
  // =================================================================
  // TEST 2: Nitrogen Compressor
  // =================================================================
  testCount++;
  const test2Name = 'Nitrogen Compressor';
  console.log(`\nTest ${testCount}: ${test2Name}`);
  console.log(`  Topology: Source (N2) â†’ Compressor â†’ Sink + Mech Source`);
  console.log(`  Scenario: N2 at 300K, 1 bar â†’ 10 bar (eta=0.75)`);
  
  debugLog('[DEBUG] Starting TEST 2 execution...');
  
  try {
    clearScene();
    
    // Build topology
    const sourceId = scene.placeUnit('source', 0, 0);
    const compId = scene.placeUnit('compressor', 3, 0);
    const sinkId = scene.placeUnit('sink', 6, 0);
    const mechSourceId = scene.placeUnit('source_mechanical', 3, -3);
    
    if (!sourceId || !compId || !sinkId || !mechSourceId) {
      throw new Error('Failed to create units');
    }
    
    debugLog(`[DEBUG] Created units: source=${sourceId}, comp=${compId}, sink=${sinkId}, mechSrc=${mechSourceId}`);
    
    // Set parameters
    const source = scene.units.get(sourceId);
    source.params = {
      species: 'N2',
      nDot: 10,        // mol/s
      T: 27,           // Â°C (300K)
      P: 100000,       // Pa (1 bar)
      phaseConstraint: 'V'
    };
    
    const comp = scene.units.get(compId);
    comp.params = {
      Pout: 1000000,   // Pa (10 bar)
      eta: 0.75        // 75% efficiency
    };
    
    const mechSource = scene.units.get(mechSourceId);
    mechSource.params = {
      maxPower: 200    // kW (more than enough)
    };
    
    // Create connections
    scene.connections.push({
      id: 'conn1',
      from: { unitId: sourceId, portId: 'out' },
      to: { unitId: compId, portId: 'mat_in' }
    });
    scene.connections.push({
      id: 'conn2',
      from: { unitId: compId, portId: 'mat_out' },
      to: { unitId: sinkId, portId: 'in' }
    });
    scene.connections.push({
      id: 'conn3',
      from: { unitId: mechSourceId, portId: 'out' },
      to: { unitId: compId, portId: 'power_in' }
    });
    
    debugLog('[DEBUG] Connections created:', scene.connections.length);
    
    // Run solver
    const solveResult = solveScene(scene);
    debugLog('[DEBUG] Solver returned:', solveResult);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    // Solver converged
    
    // PREFLIGHT: Verify source stream
    debugLog('[DEBUG] Preflight: Checking source stream...');
    const sourceRuntimeData = scene.runtime.unitData.get(sourceId);
    const sourceStream = sourceRuntimeData?.ports?.out;
    
    if (!sourceStream || !sourceStream.T || !sourceStream.P || !sourceStream.n) {
      throw new Error(`Preflight failed: Invalid source stream. ${JSON.stringify(sourceStream)}`);
    }
    
    debugLog('[DEBUG] Preflight passed:', sourceStream);
    
    // Extract compressor results
    const compRuntimeData = scene.runtime.unitData.get(compId);
    const compOutlet = compRuntimeData?.ports?.mat_out;
    
    if (!compOutlet) {
      throw new Error('No compressor outlet stream');
    }
    
    // Get compressor unit for power demand (internal W, convert to kW for comparison)
    const compUnit = scene.units.get(compId);
    const powerDemand = (compUnit.powerDemand || 0) / 1000;  // Wâ†’kW
    
    // Calculate enthalpy change (internal units: J/s)
    const H_in = sourceStream.Hdot_J_s || 0;
    const H_out = compOutlet.Hdot_J_s || 0;
    const deltaH_J_s = H_out - H_in;  // J/s
    
    // Validation
    const test2Passed = [];
    const test2Failed = [];
    const results = [];
    
    // Temperature (actual outlet after efficiency loss)
    results.push(checkTolerance(compOutlet.T, 676.698576, 5.0, 'T_out [K]', test2Passed, test2Failed));
    
    // Power demand
    results.push(checkTolerance(powerDemand, 108.6729, 1.08673, 'Power [kW]', test2Passed, test2Failed));
    
    // Phase (categorical check)
    const phasePass = compOutlet.phase === 'V';
    results.push({
      name: 'Phase',
      calc: compOutlet.phase,
      ref: 'V',
      delta: phasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: phasePass ? 'âœ“' : 'âœ—',
      pass: phasePass
    });
    if (phasePass) {
      passCount++;
      test2Passed.push('Phase');
    } else {
      failCount++;
      test2Failed.push('Phase');
    }
    
    // Enthalpy change consistency (compare in J/s)
    const powerDemand_J_s = powerDemand * 1000;  // kW â†’ J/s for comparison
    const powerConsistency = Math.abs(deltaH_J_s - powerDemand_J_s);
    const consistencyPass = powerConsistency <= 100;  // 100 J/s = 0.1 kW
    results.push({
      name: 'Power=Î”H [J/s]',
      calc: powerDemand_J_s,
      ref: deltaH_J_s,
      delta: powerConsistency,
      tol: 100,
      status: consistencyPass ? 'âœ“' : 'âœ—',
      pass: consistencyPass
    });
    if (consistencyPass) {
      passCount++;
      test2Passed.push('Power=Î”H');
    } else {
      failCount++;
      test2Failed.push('Power=Î”H');
    }
    
    printResultsTable(results, null);
    
    const test2Success = test2Failed.length === 0;
    recordTestResult(test2Name, test2Passed, test2Failed, 2);
    
  } catch (err) {
    recordTestError(test2Name, err.message, 4, 2);
    debugLog('Stack trace:', err.stack);
  } finally {
    debugLog('[DEBUG] Restoring scene...');
    restoreScene();
  }
  
  // =================================================================
  // TEST 3: Methane Valve (Ideal Gas)
  // =================================================================
  testCount++;
  const test3Name = 'Methane Valve (Ideal Gas)';
  console.log(`\nTest ${testCount}: ${test3Name}`);
  console.log(`  Topology: Source (CH4) â†’ Valve â†’ Sink`);
  console.log(`  Scenario: CH4 gas at 300K, 50 bar â†’ 1 bar`);
  
  debugLog('[DEBUG] Starting TEST 3 execution...');
  
  try {
    clearScene();
    
    // Build topology
    const sourceId = scene.placeUnit('source', 0, 0);
    const valveId = scene.placeUnit('valve', 3, 0);
    const sinkId = scene.placeUnit('sink', 6, 0);
    
    if (!sourceId || !valveId || !sinkId) {
      throw new Error('Failed to create units');
    }
    
    debugLog(`[DEBUG] Created units: source=${sourceId}, valve=${valveId}, sink=${sinkId}`);
    
    // Set parameters
    const source = scene.units.get(sourceId);
    source.params = {
      species: 'CH4',
      nDot: 10,           // mol/s
      T: 27,              // Â°C (300K)
      P: 5000000,         // Pa (50 bar)
      phaseConstraint: 'V'  // Force vapor (well above boiling point)
    };
    
    const valve = scene.units.get(valveId);
    valve.params = {
      Pout: 100000        // Pa (1 bar)
    };
    
    // Create connections
    scene.connections.push({
      id: 'conn1',
      from: { unitId: sourceId, portId: 'out' },
      to: { unitId: valveId, portId: 'in' }
    });
    scene.connections.push({
      id: 'conn2',
      from: { unitId: valveId, portId: 'out' },
      to: { unitId: sinkId, portId: 'in' }
    });
    
    debugLog('[DEBUG] Connections created:', scene.connections.length);
    
    // Run solver
    const solveResult = solveScene(scene);
    debugLog('[DEBUG] Solver returned:', solveResult);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    // Solver converged
    
    // PREFLIGHT: Verify source stream
    debugLog('[DEBUG] Preflight: Checking source stream...');
    const sourceRuntimeData = scene.runtime.unitData.get(sourceId);
    const sourceStream = sourceRuntimeData?.ports?.out;
    
    if (!sourceStream || !sourceStream.T || !sourceStream.P || !sourceStream.n) {
      throw new Error(`Preflight failed: Invalid source stream. ${JSON.stringify(sourceStream)}`);
    }
    
    debugLog('[DEBUG] Preflight passed:', sourceStream);
    
    // Extract valve results
    const valveRuntimeData = scene.runtime.unitData.get(valveId);
    const valveOutlet = valveRuntimeData?.ports?.out;
    
    if (!valveOutlet) {
      throw new Error('No valve outlet stream');
    }
    
    // Validation
    const test3Passed = [];
    const test3Failed = [];
    const results = [];
    
    // Temperature (should remain constant for ideal gas)
    results.push(checkTolerance(valveOutlet.T, 300.0, 0.2, 'T_out [K]', test3Passed, test3Failed));
    
    // Beta (should be 1.0 for pure vapor)
    results.push(checkTolerance(valveOutlet.beta || 0, 1.0, 0.001, 'beta', test3Passed, test3Failed));
    
    // Vapor flow (should be all flow)
    results.push(checkTolerance(valveOutlet.nV?.CH4 || 0, 10.0, 0.01, 'nV[CH4] [mol/s]', test3Passed, test3Failed));
    
    // Liquid flow (should be zero)
    const nL_CH4 = valveOutlet.nL?.CH4 || 0;
    const nLpass = nL_CH4 <= 0.01;
    results.push({
      name: 'nL[CH4] [mol/s]',
      calc: nL_CH4,
      ref: 0.0,
      delta: nL_CH4,
      tol: 0.01,
      status: nLpass ? 'âœ“' : 'âœ—',
      pass: nLpass
    });
    if (nLpass) {
      passCount++;
      test3Passed.push('nL=0');
    } else {
      failCount++;
      test3Failed.push('nL=0');
    }
    
    // Phase (categorical check)
    const phasePass = valveOutlet.phase === 'V';
    results.push({
      name: 'Phase',
      calc: valveOutlet.phase,
      ref: 'V',
      delta: phasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: phasePass ? 'âœ“' : 'âœ—',
      pass: phasePass
    });
    if (phasePass) {
      passCount++;
      test3Passed.push('Phase');
    } else {
      failCount++;
      test3Failed.push('Phase');
    }
    
    printResultsTable(results, null);
    
    const test3Success = test3Failed.length === 0;
    recordTestResult(test3Name, test3Passed, test3Failed, 3);
    
  } catch (err) {
    recordTestError(test3Name, err.message, 5, 3);
    debugLog('Stack trace:', err.stack);
  } finally {
    debugLog('[DEBUG] Restoring scene...');
    restoreScene();
  }
  
  // =================================================================
  // TEST 4: Water Pump
  // =================================================================
  testCount++;
  const test4Name = 'Water Pump (Hydraulic Work)';
  console.log(`\nTest ${testCount}: ${test4Name}`);
  console.log(`  Topology: Source (H2O) â†’ Pump â†’ Sink + Mech Source`);
  console.log(`  Scenario: Liquid water at 25Â°C, 1 bar â†’ 50 bar`);
  
  debugLog('[DEBUG] Starting TEST 4 execution...');
  
  try {
    clearScene();
    
    // Build topology
    const sourceId = scene.placeUnit('source', 0, 0);
    const pumpId = scene.placeUnit('pump', 3, 0);
    const sinkId = scene.placeUnit('sink', 6, 0);
    const mechSourceId = scene.placeUnit('source_mechanical', 3, -3);
    
    if (!sourceId || !pumpId || !sinkId || !mechSourceId) {
      throw new Error('Failed to create units');
    }
    
    debugLog(`[DEBUG] Created units: source=${sourceId}, pump=${pumpId}, sink=${sinkId}, mechSrc=${mechSourceId}`);
    
    // Set parameters
    const source = scene.units.get(sourceId);
    source.params = {
      species: 'H2O',
      nDot: 10,           // mol/s
      T: 25,              // Â°C (298.15K)
      P: 100000,          // Pa (1 bar)
      phaseConstraint: 'L'  // Subcooled liquid
    };
    
    const pump = scene.units.get(pumpId);
    pump.params = {
      Pout: 5000000,      // Pa (50 bar)
      eta: 0.70           // 70% efficiency
    };
    
    const mechSource = scene.units.get(mechSourceId);
    mechSource.params = {
      maxPower: 5         // kW (more than enough)
    };
    
    // Create connections
    scene.connections.push({
      id: 'conn1',
      from: { unitId: sourceId, portId: 'out' },
      to: { unitId: pumpId, portId: 'mat_in' }
    });
    scene.connections.push({
      id: 'conn2',
      from: { unitId: pumpId, portId: 'mat_out' },
      to: { unitId: sinkId, portId: 'in' }
    });
    scene.connections.push({
      id: 'conn3',
      from: { unitId: mechSourceId, portId: 'out' },
      to: { unitId: pumpId, portId: 'power_in' }
    });
    
    debugLog('[DEBUG] Connections created:', scene.connections.length);
    
    // Run solver
    const solveResult = solveScene(scene);
    debugLog('[DEBUG] Solver returned:', solveResult);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    // Solver converged
    
    // PREFLIGHT: Verify source stream
    debugLog('[DEBUG] Preflight: Checking source stream...');
    const sourceRuntimeData = scene.runtime.unitData.get(sourceId);
    const sourceStream = sourceRuntimeData?.ports?.out;
    
    if (!sourceStream || !sourceStream.T || !sourceStream.P || !sourceStream.n) {
      throw new Error(`Preflight failed: Invalid source stream. ${JSON.stringify(sourceStream)}`);
    }
    
    debugLog('[DEBUG] Preflight passed:', sourceStream);
    
    // Extract pump results
    const pumpRuntimeData = scene.runtime.unitData.get(pumpId);
    const pumpOutlet = pumpRuntimeData?.ports?.mat_out;
    
    if (!pumpOutlet) {
      throw new Error('No pump outlet stream');
    }
    
    // Get pump unit for diagnostics
    const pumpUnit = scene.units.get(pumpId);
    const pumpDiag = pumpUnit.last || {};
    
    // Calculate expected values
    // Mass flow: 10 mol/s * 18.015 g/mol = 180.15 g/s = 0.18015 kg/s
    // Volume flow (Ïâ‰ˆ1000 kg/mÂ³): VÌ‡ = 0.18015/1000 = 0.00018015 mÂ³/s
    // Î”P = 5,000,000 - 100,000 = 4,900,000 Pa
    // W_hydraulic = VÌ‡*Î”P = 0.00018015 * 4,900,000 = 882.735 W = 0.882735 kW
    // W_shaft = W_hydraulic/eta = 0.882735/0.70 = 1.261 kW
    const W_hydraulic_expected = 0.882735;  // kW
    const W_shaft_expected = 1.261;         // kW
    
    // Temperature rise: pump adds W_shaft to enthalpy
    // Î”H = 1261 J/s, per mol = 126.1 J/mol
    // Î”T â‰ˆ 126.1 / 75.3 (cp_liq H2O) â‰ˆ 1.675 K
    // T_out â‰ˆ 298.15 + 1.675 â‰ˆ 299.825 K
    const T_out_expected = 299.825;  // K (from PH flash with work added)
    
    // Validation
    const test4Passed = [];
    const test4Failed = [];
    const results = [];
    
    // Hydraulic work (Â±2%) â€” pumpDiag values now in W, expected in kW
    const W_hyd_tolerance = W_hydraulic_expected * 0.02;
    results.push(checkTolerance((pumpDiag.W_hydraulic || 0) / 1000, W_hydraulic_expected, W_hyd_tolerance, 'W_hyd [kW]', test4Passed, test4Failed));
    
    // Shaft power (should be W_hydraulic/eta)
    const W_shaft_tolerance = W_shaft_expected * 0.02;
    results.push(checkTolerance((pumpDiag.W_shaft || 0) / 1000, W_shaft_expected, W_shaft_tolerance, 'W_shaft [kW]', test4Passed, test4Failed));
    
    // Temperature (PH flash should give temperature rise)
    results.push(checkTolerance(pumpOutlet.T, T_out_expected, 0.5, 'T_out [K]', test4Passed, test4Failed));
    
    // Pressure
    results.push(checkTolerance(pumpOutlet.P, 5000000, 1000, 'P_out [Pa]', test4Passed, test4Failed));
    
    // Phase (categorical check)
    const phasePass = pumpOutlet.phase === 'L';
    results.push({
      name: 'Phase',
      calc: pumpOutlet.phase,
      ref: 'L',
      delta: phasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: phasePass ? 'âœ“' : 'âœ—',
      pass: phasePass
    });
    if (phasePass) {
      passCount++;
      test4Passed.push('Phase');
    } else {
      failCount++;
      test4Failed.push('Phase');
    }
    
    // Power demand consistency (both in W now)
    const powerDemand = pumpUnit.powerDemand || 0;
    const powerConsistency = Math.abs(powerDemand - pumpDiag.W_shaft);
    const powerPass = powerConsistency <= 10;  // 10 W tolerance
    results.push({
      name: 'Demand=W_shaft',
      calc: powerDemand,
      ref: pumpDiag.W_shaft,
      delta: powerConsistency,
      tol: 0.01,
      status: powerPass ? 'âœ“' : 'âœ—',
      pass: powerPass
    });
    if (powerPass) {
      passCount++;
      test4Passed.push('Power');
    } else {
      failCount++;
      test4Failed.push('Power');
    }
    
    printResultsTable(results, null);
    
    const test4Success = test4Failed.length === 0;
    recordTestResult(test4Name, test4Passed, test4Failed, 4);
    
  } catch (err) {
    recordTestError(test4Name, err.message, 6, 4);
    debugLog('Stack trace:', err.stack);
  } finally {
    debugLog('[DEBUG] Restoring scene...');
    restoreScene();
  }
  
  // =================================================================
  // TEST 5: Oxygen Compressor (Low Temperature + Antoine Range)
  // =================================================================
  testCount++;
  const test5Name = 'Oxygen Compressor (Low T)';
  console.log(`\nTest ${testCount}: ${test5Name}`);
  console.log(`  Topology: Source (O2) â†’ Compressor â†’ Sink + Mech Source`);
  console.log(`  Scenario: O2 gas at 120K, 2 bar â†’ 10 bar`);
  
  debugLog('[DEBUG] Starting TEST 5 execution...');
  
  try {
    clearScene();
    
    // Build topology
    const sourceId = scene.placeUnit('source', 0, 0);
    const compId = scene.placeUnit('compressor', 3, 0);
    const sinkId = scene.placeUnit('sink', 6, 0);
    const mechSourceId = scene.placeUnit('source_mechanical', 3, -3);
    
    if (!sourceId || !compId || !sinkId || !mechSourceId) {
      throw new Error('Failed to create units');
    }
    
    debugLog(`[DEBUG] Created units: source=${sourceId}, comp=${compId}, sink=${sinkId}, mechSrc=${mechSourceId}`);
    
    // Set parameters
    const source = scene.units.get(sourceId);
    source.params = {
      species: 'O2',
      nDot: 10,           // mol/s
      T: -153.15,         // Â°C (120K)
      P: 200000,          // Pa (2 bar)
      phaseConstraint: 'V'  // Force vapor (well above saturation)
    };
    
    const comp = scene.units.get(compId);
    comp.params = {
      Pout: 1000000,      // Pa (10 bar)
      eta: 0.80           // 80% efficiency
    };
    
    const mechSource = scene.units.get(mechSourceId);
    mechSource.params = {
      maxPower: 50        // kW (sufficient)
    };
    
    // Create connections
    scene.connections.push({
      id: 'conn1',
      from: { unitId: sourceId, portId: 'out' },
      to: { unitId: compId, portId: 'mat_in' }
    });
    scene.connections.push({
      id: 'conn2',
      from: { unitId: compId, portId: 'mat_out' },
      to: { unitId: sinkId, portId: 'in' }
    });
    scene.connections.push({
      id: 'conn3',
      from: { unitId: mechSourceId, portId: 'out' },
      to: { unitId: compId, portId: 'power_in' }
    });
    
    debugLog('[DEBUG] Connections created:', scene.connections.length);
    
    // Run solver
    const solveResult = solveScene(scene);
    debugLog('[DEBUG] Solver returned:', solveResult);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    // Solver converged
    
    // PREFLIGHT: Verify source stream
    debugLog('[DEBUG] Preflight: Checking source stream...');
    const sourceRuntimeData = scene.runtime.unitData.get(sourceId);
    const sourceStream = sourceRuntimeData?.ports?.out;
    
    if (!sourceStream || !sourceStream.T || !sourceStream.P || !sourceStream.n) {
      throw new Error(`Preflight failed: Invalid source stream. ${JSON.stringify(sourceStream)}`);
    }
    
    debugLog('[DEBUG] Preflight passed:', sourceStream);
    
    // Extract compressor results
    const compRuntimeData = scene.runtime.unitData.get(compId);
    const compOutlet = compRuntimeData?.ports?.mat_out;
    
    if (!compOutlet) {
      throw new Error('No compressor outlet stream');
    }
    
    // Get compressor unit for diagnostics (internal W, convert to kW)
    const compUnit = scene.units.get(compId);
    const powerDemand = (compUnit.powerDemand || 0) / 1000;  // Wâ†’kW
    
    // Expected values from user
    const T_out_expected = 208.142143;  // K
    const W_expected = 25.5157;         // kW
    
    // Validation
    const test5Passed = [];
    const test5Failed = [];
    const results = [];
    
    // Temperature
    results.push(checkTolerance(compOutlet.T, T_out_expected, 1.0, 'T_out [K]', test5Passed, test5Failed));
    
    // Power
    const W_tolerance = W_expected * 0.02;
    results.push(checkTolerance(powerDemand, W_expected, W_tolerance, 'Power [kW]', test5Passed, test5Failed));
    
    // Inlet temperature (verify low-T setup)
    results.push(checkTolerance(sourceStream.T, 120.0, 0.1, 'T_in [K]', test5Passed, test5Failed));
    
    // Phase outlet (categorical check)
    const phasePass = compOutlet.phase === 'V';
    results.push({
      name: 'Phase (out)',
      calc: compOutlet.phase,
      ref: 'V',
      delta: phasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: phasePass ? 'âœ“' : 'âœ—',
      pass: phasePass
    });
    if (phasePass) {
      passCount++;
      test5Passed.push('Phase');
    } else {
      failCount++;
      test5Failed.push('Phase');
    }
    
    // Inlet phase (categorical check)
    const inletPhasePass = sourceStream.phase === 'V';
    results.push({
      name: 'Phase (in)',
      calc: sourceStream.phase,
      ref: 'V',
      delta: inletPhasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: inletPhasePass ? 'âœ“' : 'âœ—',
      pass: inletPhasePass
    });
    if (inletPhasePass) {
      passCount++;
      test5Passed.push('Inlet-V');
    } else {
      failCount++;
      test5Failed.push('Inlet-V');
    }
    
    printResultsTable(results, null);
    
    const test5Success = test5Failed.length === 0;
    recordTestResult(test5Name, test5Passed, test5Failed, 5);
    
  } catch (err) {
    recordTestError(test5Name, err.message, 5, 5);
    debugLog('Stack trace:', err.stack);
  } finally {
    debugLog('[DEBUG] Restoring scene...');
    restoreScene();
  }
  
  // =================================================================
  // TEST 6: Antoine Range Selection (Water High-T Range)
  // =================================================================
  testCount++;
  const test6Name = 'Antoine Range Selection';
  console.log(`\nTest ${testCount}: ${test6Name}`);
  console.log(`  Purpose: Verify correct Antoine range selection`);
  console.log(`  Scenario: Water at 400K (high-T range 372-647K)`);
  
  debugLog('[DEBUG] Starting TEST 6 execution...');
  
  try {
    // Test saturationPressure at T in second range
    const T_test = 400;  // K (in high-T range: 372-647K)
    const comp_test = 'H2O';
    
    const Psat = thermo.saturationPressure(comp_test, T_test);
    
    // Expected: Should use high-T range (372-647K)
    // High-T range: A=8.14019, B=1810.94, C=244.485
    // log10(Psat[mmHg]) = 8.14019 - 1810.94/(244.485 + (400-273.15))
    // log10(Psat[mmHg]) = 8.14019 - 1810.94/371.335 = 8.14019 - 4.8758 = 3.2644
    // Psat[mmHg] = 10^3.2644 = 1837.5 mmHg = 245036 Pa
    const Psat_expected = 245036;  // Pa
    
    console.log(`  Results:`);
    console.log(`    T = ${T_test} K`);
    console.log(`    Psat = ${Psat.toFixed(0)} Pa`);
    console.log(`    Expected = ${Psat_expected.toFixed(0)} Pa`);
    
    const test6Passed = [];
    const test6Failed = [];
    const results = [];
    
    // Psat check (5% tolerance for Antoine approximation)
    const Psat_tolerance = Psat_expected * 0.05;
    results.push(checkTolerance(Psat, Psat_expected, Psat_tolerance, 'Psat [Pa]', test6Passed, test6Failed));
    
    // Non-null check
    const nonNullPass = Psat !== null && !isNaN(Psat);
    results.push({
      name: 'Psat valid',
      calc: Psat !== null ? 'valid' : 'null',
      ref: 'valid',
      delta: nonNullPass ? 'match' : 'mismatch',
      tol: 'exact',
      status: nonNullPass ? 'âœ“' : 'âœ—',
      pass: nonNullPass
    });
    if (nonNullPass) {
      passCount++;
      test6Passed.push('Valid');
    } else {
      failCount++;
      test6Failed.push('Valid');
    }
    
    printResultsTable(results, null);
    
    const test6Success = test6Failed.length === 0;
    recordTestResult(test6Name, test6Passed, test6Failed, 6);
    
  } catch (err) {
    recordTestError(test6Name, err.message, 2, 6);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 7: Antoine Out-of-Range Handling
  // =================================================================
  testCount++;
  const test7Name = 'Antoine Out-of-Range';
  console.log(`\nTest ${testCount}: ${test7Name}`);
  console.log(`  Purpose: Verify out-of-range warning and fallback`);
  console.log(`  Scenario: Water below Tmin and above Tmax`);
  
  debugLog('[DEBUG] Starting TEST 7 execution...');
  
  try {
    // Clear warning cache to test warning emission
    const originalCache = new Set(thermo._warnedRanges);
    thermo._warnedRanges.clear();
    
    // Test below Tmin (should use low-T range and warn)
    const T_low = 200;  // K (below 274K minimum)
    const Psat_low = thermo.saturationPressure('H2O', T_low);
    
    // Test above Tmax (should use high-T range and warn)
    const T_high = 700;  // K (above 647K maximum)
    const Psat_high = thermo.saturationPressure('H2O', T_high);
    
    // Test deduplication - call again with same component+side
    const Psat_low2 = thermo.saturationPressure('H2O', 250);  // Also below Tmin
    const Psat_high2 = thermo.saturationPressure('H2O', 750);  // Also above Tmax
    
    console.log(`  Results:`);
    console.log(`    T_low = ${T_low} K, Psat = ${Psat_low?.toFixed(0) || 'null'} Pa`);
    console.log(`    T_high = ${T_high} K, Psat = ${Psat_high?.toFixed(0) || 'null'} Pa`);
    console.log(`    Warnings cached: ${thermo._warnedRanges.size}`);
    
    const test7Passed = [];
    const test7Failed = [];
    const results = [];
    
    // Check low-T Psat is valid (not null/NaN)
    const lowValidPass = Psat_low !== null && !isNaN(Psat_low) && Psat_low > 0;
    results.push({
      name: 'Psat_low valid',
      calc: lowValidPass ? 'valid' : 'invalid',
      ref: 'valid',
      delta: lowValidPass ? 'match' : 'mismatch',
      tol: 'exact',
      status: lowValidPass ? 'âœ“' : 'âœ—',
      pass: lowValidPass
    });
    if (lowValidPass) {
      passCount++;
      test7Passed.push('Low-valid');
    } else {
      failCount++;
      test7Failed.push('Low-valid');
    }
    
    // Check high-T Psat is valid
    const highValidPass = Psat_high !== null && !isNaN(Psat_high) && Psat_high > 0;
    results.push({
      name: 'Psat_high valid',
      calc: highValidPass ? 'valid' : 'invalid',
      ref: 'valid',
      delta: highValidPass ? 'match' : 'mismatch',
      tol: 'exact',
      status: highValidPass ? 'âœ“' : 'âœ—',
      pass: highValidPass
    });
    if (highValidPass) {
      passCount++;
      test7Passed.push('High-valid');
    } else {
      failCount++;
      test7Failed.push('High-valid');
    }
    
    // Check warning deduplication (should have exactly 2 warnings: below and above)
    const dedupPass = thermo._warnedRanges.size === 2;
    results.push({
      name: 'Warnings dedup',
      calc: thermo._warnedRanges.size,
      ref: 2,
      delta: Math.abs(thermo._warnedRanges.size - 2),
      tol: 0,
      status: dedupPass ? 'âœ“' : 'âœ—',
      pass: dedupPass
    });
    if (dedupPass) {
      passCount++;
      test7Passed.push('Dedup');
    } else {
      failCount++;
      test7Failed.push('Dedup');
    }
    
    printResultsTable(results, null);
    
    // Restore original cache
    thermo._warnedRanges = originalCache;
    
    const test7Success = test7Failed.length === 0;
    recordTestResult(test7Name, test7Passed, test7Failed, 7);
    
  } catch (err) {
    recordTestError(test7Name, err.message, 3, 7);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 8: ComponentRegistry Validation (Multi-Range Antoine)
  // =================================================================
  testCount++;
  const test8Name = 'ComponentRegistry Validation';
  console.log(`\nTest ${testCount}: ${test8Name}`);
  console.log(`  Purpose: Verify validation accepts multi-range Antoine`);
  console.log(`  Scenario: Validate existing components + malformed data`);
  
  debugLog('[DEBUG] Starting TEST 8 execution...');
  
  try {
    const test8Passed = [];
    const test8Failed = [];
    const results = [];
    
    // Test 1: Validate all existing components (should pass)
    const validationResults = ComponentRegistry.validateAll();
    let allValid = true;
    let invalidComps = [];
    
    for (const [formula, result] of Object.entries(validationResults)) {
      if (!result.valid) {
        allValid = false;
        invalidComps.push(`${formula}: ${result.errors.join(', ')}`);
      }
    }
    
    results.push({
      name: 'Existing comps',
      calc: allValid ? 'all valid' : 'some invalid',
      ref: 'all valid',
      delta: allValid ? 'match' : 'mismatch',
      tol: 'exact',
      status: allValid ? 'âœ“' : 'âœ—',
      pass: allValid
    });
    if (allValid) {
      passCount++;
      test8Passed.push('Existing');
    } else {
      failCount++;
      test8Failed.push('Existing');
      console.log(`    Invalid components: ${invalidComps.join('; ')}`);
    }
    
    // Test 2: Multi-range Antoine validation (H2O should pass)
    const h2oValidation = ComponentRegistry.validate('H2O');
    const h2oPass = h2oValidation.valid;
    
    results.push({
      name: 'H2O multi-range',
      calc: h2oPass ? 'valid' : 'invalid',
      ref: 'valid',
      delta: h2oPass ? 'match' : 'mismatch',
      tol: 'exact',
      status: h2oPass ? 'âœ“' : 'âœ—',
      pass: h2oPass
    });
    if (h2oPass) {
      passCount++;
      test8Passed.push('H2O');
    } else {
      failCount++;
      test8Failed.push('H2O');
      console.log(`    H2O validation errors: ${h2oValidation.errors.join(', ')}`);
    }
    
    // Test 3: Register malformed component and verify rejection
    let malformedCaught = false;
    try {
      // Temporarily register a bad component
      ComponentRegistry.register('TEST_BAD', {
        name: 'Bad Test Component',
        MW: 18.0,
        Tc: 647.1,
        Pc: 22064000,
        omega: 0.344,
        Tb: 373.15,
        phase298: 'liquid',
        antoine: [
          // Missing Tmin/Tmax (should error)
          { A: 8.0, B: 1730, C: 233 }
        ],
        cpig: { A: 33.933, B: -0.008418, C: 2.9906e-5, D: -1.7825e-8, E: 3.6934e-12, Tmin: 273, Tmax: 1500 },
        cpLiq: 75.3
      });
      
      const badValidation = ComponentRegistry.validate('TEST_BAD');
      if (!badValidation.valid && badValidation.errors.some(e => e.includes('Tmin') || e.includes('Tmax'))) {
        malformedCaught = true;
      }
      
      // Clean up test component
      ComponentRegistry._components.delete('TEST_BAD');
      
    } catch (err) {
      // If registration itself throws, that's also acceptable
      malformedCaught = true;
    }
    
    results.push({
      name: 'Malformed reject',
      calc: malformedCaught ? 'rejected' : 'accepted',
      ref: 'rejected',
      delta: malformedCaught ? 'match' : 'mismatch',
      tol: 'exact',
      status: malformedCaught ? 'âœ“' : 'âœ—',
      pass: malformedCaught
    });
    if (malformedCaught) {
      passCount++;
      test8Passed.push('Malformed');
    } else {
      failCount++;
      test8Failed.push('Malformed');
    }
    
    // Test 4: Range ordering validation
    let orderingCaught = false;
    try {
      ComponentRegistry.register('TEST_ORDER', {
        name: 'Bad Ordering Test',
        MW: 18.0,
        Tc: 647.1,
        Pc: 22064000,
        omega: 0.344,
        Tb: 373.15,
        phase298: 'liquid',
        antoine: [
          { A: 8.0, B: 1730, C: 233, Tmin: 400, Tmax: 300 }  // Tmin > Tmax (error!)
        ],
        cpig: { A: 33.933, B: -0.008418, C: 2.9906e-5, D: -1.7825e-8, E: 3.6934e-12, Tmin: 273, Tmax: 1500 },
        cpLiq: 75.3
      });
      
      const orderValidation = ComponentRegistry.validate('TEST_ORDER');
      if (!orderValidation.valid && orderValidation.errors.some(e => e.includes('must be less than'))) {
        orderingCaught = true;
      }
      
      ComponentRegistry._components.delete('TEST_ORDER');
      
    } catch (err) {
      orderingCaught = true;
    }
    
    results.push({
      name: 'Range ordering',
      calc: orderingCaught ? 'rejected' : 'accepted',
      ref: 'rejected',
      delta: orderingCaught ? 'match' : 'mismatch',
      tol: 'exact',
      status: orderingCaught ? 'âœ“' : 'âœ—',
      pass: orderingCaught
    });
    if (orderingCaught) {
      passCount++;
      test8Passed.push('Ordering');
    } else {
      failCount++;
      test8Failed.push('Ordering');
    }
    
    console.log(`  Results:`);
    console.log(`    Registered components: ${ComponentRegistry.list().length}`);
    console.log(`    H2O validation: ${h2oValidation.valid ? 'PASS' : 'FAIL'}`);
    
    printResultsTable(results, null);
    
    const test8Success = test8Failed.length === 0;
    recordTestResult(test8Name, test8Passed, test8Failed, 8);
    
  } catch (err) {
    recordTestError(test8Name, err.message, 4, 8);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 9: Gamma Mixture Calculation (Thermodynamic Correctness)
  // =================================================================
  testCount++;
  const test9Name = 'Gamma Mixture Calculation';
  console.log(`\nTest ${testCount}: ${test9Name}`);
  console.log(`  Purpose: Verify gamma is computed from Cp_mix, not averaged`);
  console.log(`  Scenario: He+CO2 mixture (extreme gamma difference)`);
  
  debugLog('[DEBUG] Starting TEST 9 execution...');
  
  try {
    // Use extreme case: Helium (gamma=1.667) + CO2 (gamma=1.289)
    // This maximizes the error from incorrect averaging
    
    const T_test = 300;  // K
    const P_test = 101325;  // Pa
    
    // Get pure component properties
    const Cp_He = thermo.cpMolar('He', T_test, P_test, 'V');   // ~20.8 J/mol/K
    const Cp_CO2 = thermo.cpMolar('CO2', T_test, P_test, 'V'); // ~37.1 J/mol/K
    
    const R = 8.314;
    const gamma_He = Cp_He / (Cp_He - R);    // ~1.667 (monatomic)
    const gamma_CO2 = Cp_CO2 / (Cp_CO2 - R); // ~1.289 (polyatomic)
    
    // 50/50 mole fraction mixture
    const xi_He = 0.5;
    const xi_CO2 = 0.5;
    
    // WRONG approach (molar average of gamma)
    const gamma_wrong = xi_He * gamma_He + xi_CO2 * gamma_CO2;
    
    // CORRECT approach (gamma from mixture Cp)
    const Cp_mix = xi_He * Cp_He + xi_CO2 * Cp_CO2;
    const Cv_mix = Cp_mix - R;
    const gamma_correct = Cp_mix / Cv_mix;
    
    // Expected values (based on typical Cp values)
    // He: Cp â‰ˆ 20.8, gamma â‰ˆ 1.667
    // CO2: Cp â‰ˆ 37.1, gamma â‰ˆ 1.289
    // Mixture: Cp â‰ˆ 28.95, gamma â‰ˆ 1.404
    // Wrong: gamma â‰ˆ 1.478
    // Difference: ~5%
    
    const gamma_expected = 1.404;  // From Cp_mix calculation
    const error_tolerance = 0.01;  // Â±0.01 (tight tolerance)
    
    console.log(`  Results:`);
    console.log(`    He: Cp=${Cp_He.toFixed(1)}, gamma=${gamma_He.toFixed(3)}`);
    console.log(`    CO2: Cp=${Cp_CO2.toFixed(1)}, gamma=${gamma_CO2.toFixed(3)}`);
    console.log(`    Mixture (WRONG avg): gamma=${gamma_wrong.toFixed(3)}`);
    console.log(`    Mixture (CORRECT Cp): gamma=${gamma_correct.toFixed(3)}`);
    console.log(`    Error if averaged: ${((gamma_wrong - gamma_correct) / gamma_correct * 100).toFixed(1)}%`);
    
    const test9Passed = [];
    const test9Failed = [];
    const results = [];
    
    // Check gamma is computed correctly (not averaged)
    const gammaPass = Math.abs(gamma_correct - gamma_expected) < error_tolerance;
    results.push({
      name: 'gamma_mix',
      calc: gamma_correct,
      ref: gamma_expected,
      delta: Math.abs(gamma_correct - gamma_expected),
      tol: error_tolerance,
      status: gammaPass ? 'âœ“' : 'âœ—',
      pass: gammaPass
    });
    if (gammaPass) {
      passCount++;
      test9Passed.push('Gamma-correct');
    } else {
      failCount++;
      test9Failed.push('Gamma-correct');
    }
    
    // Check that averaging would give WRONG answer
    const avgWouldBeWrong = Math.abs(gamma_wrong - gamma_expected) > 0.03;  // >2% error
    results.push({
      name: 'Avg â‰  Correct',
      calc: avgWouldBeWrong ? 'different' : 'same',
      ref: 'different',
      delta: avgWouldBeWrong ? 'match' : 'mismatch',
      tol: '>2% error',
      status: avgWouldBeWrong ? 'âœ“' : 'âœ—',
      pass: avgWouldBeWrong
    });
    if (avgWouldBeWrong) {
      passCount++;
      test9Passed.push('Avg-wrong');
    } else {
      failCount++;
      test9Failed.push('Avg-wrong');
    }
    
    // Check Cp is computed correctly (molar average is OK for Cp)
    const Cp_expected = xi_He * Cp_He + xi_CO2 * Cp_CO2;
    const cpPass = Math.abs(Cp_mix - Cp_expected) < 0.01;
    results.push({
      name: 'Cp_mix',
      calc: Cp_mix,
      ref: Cp_expected,
      delta: Math.abs(Cp_mix - Cp_expected),
      tol: 0.01,
      status: cpPass ? 'âœ“' : 'âœ—',
      pass: cpPass
    });
    if (cpPass) {
      passCount++;
      test9Passed.push('Cp-mix');
    } else {
      failCount++;
      test9Failed.push('Cp-mix');
    }
    
    printResultsTable(results, null);
    
    const test9Success = test9Failed.length === 0;
    recordTestResult(test9Name, test9Passed, test9Failed, 9);
    
  } catch (err) {
    recordTestError(test9Name, err.message, 3, 9);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 10: VL Fallback Phase Normalization
  // =================================================================
  testCount++;
  const test10Name = 'VL Fallback Phase Normalization';
  console.log(`\nTest ${testCount}: ${test10Name}`);
  console.log(`  Purpose: Verify VL phaseConstraint never passed to single-phase functions`);
  console.log(`  Scenario: VL stream with undefined quality, phaseConstraint='VL'`);
  
  debugLog('[DEBUG] Starting TEST 10 execution...');
  
  try {
    const test10Passed = [];
    const test10Failed = [];
    const results = [];
    
    // Test normalizeSinglePhaseHint helper
    const normalizeTests = [
      { input: 'V', default: 'L', expected: 'V' },
      { input: 'L', default: 'V', expected: 'L' },
      { input: 'VL', default: 'L', expected: 'L' },  // CRITICAL: VL â†’ L
      { input: 'VL', default: 'V', expected: 'V' },  // CRITICAL: VL â†’ V
      { input: null, default: 'L', expected: 'L' },
      { input: undefined, default: 'V', expected: 'V' },
      { input: '', default: 'L', expected: 'L' },
    ];
    
    let normalizePass = true;
    for (const test of normalizeTests) {
      const result = thermo.normalizeSinglePhaseHint(test.input, test.default);
      if (result !== test.expected) {
        console.error(`  normalizeSinglePhaseHint('${test.input}', '${test.default}') = '${result}', expected '${test.expected}'`);
        normalizePass = false;
      }
    }
    
    results.push({
      name: 'Normalize helper',
      calc: normalizePass ? 'all correct' : 'some wrong',
      ref: 'all correct',
      delta: normalizePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: normalizePass ? 'âœ“' : 'âœ—',
      pass: normalizePass
    });
    if (normalizePass) {
      passCount++;
      test10Passed.push('Normalize');
    } else {
      failCount++;
      test10Failed.push('Normalize');
    }
    
    // Test streamCp with VL undefined quality
    // Create a VL stream with undefined split but phaseConstraint='VL'
    const testStream = {
      type: StreamType.MATERIAL,
      phase: 'VL',           // Two-phase
      phaseConstraint: 'VL', // CRITICAL: This should NOT be passed to cpMolar
      T: 300,                // K
      P: 101325,             // Pa
      n: { N2: 1.0 },        // mol/s
      // No nV, nL â†’ undefined quality
    };
    
    // This should NOT crash and should use liquid as fallback
    let cpResult = null;
    let cpError = null;
    try {
      cpResult = thermo.streamCp(testStream);
    } catch (err) {
      cpError = err.message;
    }
    
    const cpPass = cpResult !== null && !isNaN(cpResult) && cpResult > 0 && !cpError;
    results.push({
      name: 'streamCp VL',
      calc: cpPass ? 'valid Cp' : (cpError || 'invalid'),
      ref: 'valid Cp',
      delta: cpPass ? 'match' : 'mismatch',
      tol: 'exact',
      status: cpPass ? 'âœ“' : 'âœ—',
      pass: cpPass
    });
    if (cpPass) {
      passCount++;
      test10Passed.push('StreamCp');
    } else {
      failCount++;
      test10Failed.push('StreamCp');
    }
    
    // Test computeStreamEnthalpy with VL undefined quality
    let hResult = null;
    let hError = null;
    try {
      thermo.computeStreamEnthalpy(testStream);
      hResult = testStream.Hdot_J_s;
    } catch (err) {
      hError = err.message;
    }
    
    const hPass = hResult !== null && hResult !== undefined && !isNaN(hResult) && !hError;
    results.push({
      name: 'computeH VL',
      calc: hPass ? 'valid H' : (hError || 'invalid'),
      ref: 'valid H',
      delta: hPass ? 'match' : 'mismatch',
      tol: 'exact',
      status: hPass ? 'âœ“' : 'âœ—',
      pass: hPass
    });
    if (hPass) {
      passCount++;
      test10Passed.push('ComputeH');
    } else {
      failCount++;
      test10Failed.push('ComputeH');
    }
    
    console.log(`  Results:`);
    console.log(`    Normalize tests: ${normalizePass ? 'PASS' : 'FAIL'}`);
    console.log(`    streamCp result: ${cpResult?.toFixed(2) || 'ERROR'} J/s/K`);
    console.log(`    Hdot result: ${hResult?.toFixed(0) || 'ERROR'} J/s`);
    
    printResultsTable(results, null);
    
    const test10Success = test10Failed.length === 0;
    recordTestResult(test10Name, test10Passed, test10Failed, 10);
    
  } catch (err) {
    recordTestError(test10Name, err.message, 3, 10);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 11: PH Flash Unachievable Target (Robustness)
  // =================================================================
  testCount++;
  const test11Name = 'PH Flash Unachievable Target';
  console.log(`\nTest ${testCount}: ${test11Name}`);
  console.log(`  Purpose: Verify PH flash handles targets outside achievable range`);
  console.log(`  Scenario: Extremely negative and positive enthalpy targets`);
  
  debugLog('[DEBUG] Starting TEST 11 execution...');
  
  try {
    const test11Passed = [];
    const test11Failed = [];
    const results = [];
    
    const P_test = 101325;  // Pa
    const n_test = { N2: 1.0 };  // mol/s
    
    // Test 1: Extremely negative target (far below Tmin=100K enthalpy)
    const H_min_achievable = thermo.hMolar('N2', 100, P_test, 'V') * 1.0;  // J/s (at Tmin)
    const H_target_low = H_min_achievable - 10000;  // 10 kW below achievable minimum
    
    const result_low = thermo.phFlash({
      P: P_test,
      n: n_test,
      H_target_Jps: H_target_low
    });
    
    console.log(`  Low target test:`);
    console.log(`    Target H: ${(H_target_low/1000).toFixed(1)} kW`);
    console.log(`    Min achievable: ${(H_min_achievable/1000).toFixed(1)} kW`);
    console.log(`    Converged: ${result_low.converged}`);
    console.log(`    Bracketed: ${result_low.bracketed}`);
    console.log(`    T_solution: ${result_low.T_K.toFixed(1)} K`);
    console.log(`    Residual: ${(result_low.residual_Jps/1000).toFixed(1)} kW`);
    
    // Check 1: converged=false for unachievable target
    const lowNotConverged = result_low.converged === false;
    results.push({
      name: 'Low: !converged',
      calc: result_low.converged ? 'true' : 'false',
      ref: 'false',
      delta: lowNotConverged ? 'match' : 'mismatch',
      tol: 'exact',
      status: lowNotConverged ? 'âœ“' : 'âœ—',
      pass: lowNotConverged
    });
    if (lowNotConverged) {
      passCount++;
      test11Passed.push('Low-!conv');
    } else {
      failCount++;
      test11Failed.push('Low-!conv');
    }
    
    // Check 2: warning present
    const lowHasWarning = result_low.warning !== undefined && result_low.warning !== null;
    results.push({
      name: 'Low: warning',
      calc: lowHasWarning ? 'present' : 'missing',
      ref: 'present',
      delta: lowHasWarning ? 'match' : 'mismatch',
      tol: 'exact',
      status: lowHasWarning ? 'âœ“' : 'âœ—',
      pass: lowHasWarning
    });
    if (lowHasWarning) {
      passCount++;
      test11Passed.push('Low-warn');
    } else {
      failCount++;
      test11Failed.push('Low-warn');
    }
    
    // Check 3: T is finite (not NaN)
    const lowTFinite = isFinite(result_low.T_K) && !isNaN(result_low.T_K);
    results.push({
      name: 'Low: T finite',
      calc: lowTFinite ? 'finite' : 'NaN/Inf',
      ref: 'finite',
      delta: lowTFinite ? 'match' : 'mismatch',
      tol: 'exact',
      status: lowTFinite ? 'âœ“' : 'âœ—',
      pass: lowTFinite
    });
    if (lowTFinite) {
      passCount++;
      test11Passed.push('Low-finite');
    } else {
      failCount++;
      test11Failed.push('Low-finite');
    }
    
    // Check 4: residual_Jps present
    const lowHasResidual = result_low.residual_Jps !== undefined && isFinite(result_low.residual_Jps);
    results.push({
      name: 'Low: residual',
      calc: lowHasResidual ? 'present' : 'missing',
      ref: 'present',
      delta: lowHasResidual ? 'match' : 'mismatch',
      tol: 'exact',
      status: lowHasResidual ? 'âœ“' : 'âœ—',
      pass: lowHasResidual
    });
    if (lowHasResidual) {
      passCount++;
      test11Passed.push('Low-resid');
    } else {
      failCount++;
      test11Failed.push('Low-resid');
    }
    
    // Test 2: Extremely high target (far above Tmax=3000K enthalpy)
    const H_max_achievable = thermo.hMolar('N2', 3000, P_test, 'V') * 1.0;  // J/s (at Tmax)
    const H_target_high = H_max_achievable + 10000;  // 10 kW above achievable maximum
    
    const result_high = thermo.phFlash({
      P: P_test,
      n: n_test,
      H_target_Jps: H_target_high
    });
    
    console.log(`  High target test:`);
    console.log(`    Target H: ${(H_target_high/1000).toFixed(1)} kW`);
    console.log(`    Max achievable: ${(H_max_achievable/1000).toFixed(1)} kW`);
    console.log(`    Converged: ${result_high.converged}`);
    console.log(`    T_solution: ${result_high.T_K.toFixed(1)} K`);
    
    // Check 5: converged=false for high target
    const highNotConverged = result_high.converged === false;
    results.push({
      name: 'High: !converged',
      calc: result_high.converged ? 'true' : 'false',
      ref: 'false',
      delta: highNotConverged ? 'match' : 'mismatch',
      tol: 'exact',
      status: highNotConverged ? 'âœ“' : 'âœ—',
      pass: highNotConverged
    });
    if (highNotConverged) {
      passCount++;
      test11Passed.push('High-!conv');
    } else {
      failCount++;
      test11Failed.push('High-!conv');
    }
    
    // Check 6: T is finite
    const highTFinite = isFinite(result_high.T_K) && !isNaN(result_high.T_K);
    results.push({
      name: 'High: T finite',
      calc: highTFinite ? 'finite' : 'NaN/Inf',
      ref: 'finite',
      delta: highTFinite ? 'match' : 'mismatch',
      tol: 'exact',
      status: highTFinite ? 'âœ“' : 'âœ—',
      pass: highTFinite
    });
    if (highTFinite) {
      passCount++;
      test11Passed.push('High-finite');
    } else {
      failCount++;
      test11Failed.push('High-finite');
    }
    
    printResultsTable(results, null);
    
    const test11Success = test11Failed.length === 0;
    recordTestResult(test11Name, test11Passed, test11Failed, 11);
    
  } catch (err) {
    recordTestError(test11Name, err.message, 6, 11);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 12: PH Flash Near-Zero Denominator (Robustness)
  // =================================================================
  testCount++;
  const test12Name = 'PH Flash Near-Zero Denominator';
  console.log(`\nTest ${testCount}: ${test12Name}`);
  console.log(`  Purpose: Verify PH flash handles Hmin â‰ˆ Hmax gracefully`);
  console.log(`  Scenario: Monatomic gas with nearly constant enthalpy`);
  
  debugLog('[DEBUG] Starting TEST 12 execution...');
  
  try {
    const test12Passed = [];
    const test12Failed = [];
    const results = [];
    
    // Use Helium (monatomic, constant Cp) at conditions where H changes very slowly
    const P_test = 101325;  // Pa
    const n_test = { He: 0.01 };  // Very small flow â†’ very small H range
    
    // Compute enthalpy at two temperatures
    const T1 = 300;  // K
    const T2 = 305;  // K (small difference)
    const H1 = thermo.hMolar('He', T1, P_test, 'V') * 0.01;  // J/s
    const H2 = thermo.hMolar('He', T2, P_test, 'V') * 0.01;  // J/s
    
    // Target near midpoint
    const H_target = (H1 + H2) / 2;
    
    console.log(`  Setup:`);
    console.log(`    T1=${T1}K, H1=${H1.toFixed(3)} J/s`);
    console.log(`    T2=${T2}K, H2=${H2.toFixed(3)} J/s`);
    console.log(`    H_target=${H_target.toFixed(3)} J/s`);
    console.log(`    Range: ${(H2-H1).toFixed(6)} J/s (very small)`);
    
    const result = thermo.phFlash({
      P: P_test,
      n: n_test,
      H_target_Jps: H_target
    });
    
    console.log(`  Result:`);
    console.log(`    T_solution: ${result.T_K.toFixed(2)} K`);
    console.log(`    Converged: ${result.converged}`);
    console.log(`    Iterations: ${result.iterations}`);
    console.log(`    Residual: ${result.residual_Jps?.toFixed(6) || 'N/A'} J/s`);
    
    // Check 1: T is finite (not NaN)
    const tFinite = isFinite(result.T_K) && !isNaN(result.T_K);
    results.push({
      name: 'T finite',
      calc: tFinite ? 'finite' : 'NaN/Inf',
      ref: 'finite',
      delta: tFinite ? 'match' : 'mismatch',
      tol: 'exact',
      status: tFinite ? 'âœ“' : 'âœ—',
      pass: tFinite
    });
    if (tFinite) {
      passCount++;
      test12Passed.push('T-finite');
    } else {
      failCount++;
      test12Failed.push('T-finite');
    }
    
    // Check 2: T is reasonable (between 200-400K for this case)
    const tReasonable = result.T_K > 200 && result.T_K < 400;
    results.push({
      name: 'T reasonable',
      calc: `${result.T_K.toFixed(1)}K`,
      ref: '200-400K',
      delta: tReasonable ? 'in range' : 'out of range',
      tol: 'range',
      status: tReasonable ? 'âœ“' : 'âœ—',
      pass: tReasonable
    });
    if (tReasonable) {
      passCount++;
      test12Passed.push('T-range');
    } else {
      failCount++;
      test12Failed.push('T-range');
    }
    
    // Check 3: Metadata present
    const hasMetadata = result.residual_Jps !== undefined && 
                       result.iterations !== undefined &&
                       result.converged !== undefined;
    results.push({
      name: 'Metadata',
      calc: hasMetadata ? 'complete' : 'incomplete',
      ref: 'complete',
      delta: hasMetadata ? 'match' : 'mismatch',
      tol: 'exact',
      status: hasMetadata ? 'âœ“' : 'âœ—',
      pass: hasMetadata
    });
    if (hasMetadata) {
      passCount++;
      test12Passed.push('Metadata');
    } else {
      failCount++;
      test12Failed.push('Metadata');
    }
    
    printResultsTable(results, null);
    
    const test12Success = test12Failed.length === 0;
    recordTestResult(test12Name, test12Passed, test12Failed, 12);
    
  } catch (err) {
    recordTestError(test12Name, err.message, 3, 12);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 13: Density from ComponentRegistry (Item 5)
  // =================================================================
  testCount++;
  const test13Name = 'Density from ComponentRegistry';
  console.log(`\nTest ${testCount}: ${test13Name}`);
  console.log(`  Purpose: Verify liquid density reads from ComponentRegistry, not hardcoded map`);
  console.log(`  Scenario: All registered components should have rhoLiq property`);
  
  try {
    const test13Passed = [];
    const test13Failed = [];
    const results = [];
    
    // Check 1: All components have rhoLiq in registry
    const compsToCheck = ['H2O', 'O2', 'H2', 'N2', 'Ar', 'CH4', 'He', 'CO2'];
    const expectedRhoLiq = { H2O: 1000, O2: 1141, H2: 71, N2: 807, Ar: 1394, CH4: 423, He: 125, CO2: 1101 };
    let allHaveRhoLiq = true;
    for (const comp of compsToCheck) {
      const data = ComponentRegistry.get(comp);
      if (!data || data.rhoLiq === undefined || data.rhoLiq === null) {
        allHaveRhoLiq = false;
        debugLog(`Missing rhoLiq for ${comp}`);
      }
    }
    results.push({
      name: 'All rhoLiq present',
      calc: allHaveRhoLiq ? '8/8' : 'incomplete',
      ref: '8/8',
      delta: allHaveRhoLiq ? 'match' : 'mismatch',
      tol: 'exact',
      status: allHaveRhoLiq ? 'âœ“' : 'âœ—',
      pass: allHaveRhoLiq
    });
    if (allHaveRhoLiq) { passCount++; test13Passed.push('rhoLiq-present'); }
    else { failCount++; test13Failed.push('rhoLiq-present'); }
    
    // Check 2: density() returns correct values from registry
    let allDensitiesMatch = true;
    for (const comp of compsToCheck) {
      const rhoL = thermo.density(comp, 298, 101325, 'L');
      if (rhoL !== expectedRhoLiq[comp]) {
        allDensitiesMatch = false;
        debugLog(`density('${comp}', L) = ${rhoL}, expected ${expectedRhoLiq[comp]}`);
      }
    }
    results.push({
      name: 'density(L) correct',
      calc: allDensitiesMatch ? '8/8' : 'mismatch',
      ref: '8/8',
      delta: allDensitiesMatch ? 'match' : 'mismatch',
      tol: 'exact',
      status: allDensitiesMatch ? 'âœ“' : 'âœ—',
      pass: allDensitiesMatch
    });
    if (allDensitiesMatch) { passCount++; test13Passed.push('density-L'); }
    else { failCount++; test13Failed.push('density-L'); }
    
    // Check 3: Vapor density still uses ideal gas law (Ï = P*MW/(R*T))
    const rhoV_N2 = thermo.density('N2', 300, 101325, 'V');
    const expected_rhoV = (101325 * 28.014 / 1000) / (8.314 * 300);
    const vaporPass = Math.abs(rhoV_N2 - expected_rhoV) < 0.01;
    results.push(checkTolerance(rhoV_N2, expected_rhoV, 0.01, 'density(V) ideal', test13Passed, test13Failed));
    
    printResultsTable(results, null);
    recordTestResult(test13Name, test13Passed, test13Failed, 13);
    
  } catch (err) {
    recordTestError(test13Name, err.message, 3, 13);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 14: Cp Polynomial Clamping (Item 7)
  // =================================================================
  testCount++;
  const test14Name = 'Cp Polynomial Clamping';
  console.log(`\nTest ${testCount}: ${test14Name}`);
  console.log(`  Purpose: Verify Cp is clamped at valid-range boundaries, not extrapolated`);
  console.log(`  Scenario: N2 (Tmin=100K, Tmax=2000K) evaluated outside range`);
  
  try {
    const test14Passed = [];
    const test14Failed = [];
    const results = [];
    
    // N2: cpig.Tmin = 100, cpig.Tmax = 2000
    const Cp_at_100 = thermo.cpMolar('N2', 100, 101325, 'V');
    const Cp_at_50 = thermo.cpMolar('N2', 50, 101325, 'V');
    const Cp_at_2000 = thermo.cpMolar('N2', 2000, 101325, 'V');
    const Cp_at_5000 = thermo.cpMolar('N2', 5000, 101325, 'V');
    
    // Check 1: Cp(below Tmin) clamped to Cp(Tmin)
    results.push(checkTolerance(Cp_at_50, Cp_at_100, 0.001, 'Cp clamp low', test14Passed, test14Failed));
    
    // Check 2: Cp(above Tmax) clamped to Cp(Tmax)
    results.push(checkTolerance(Cp_at_5000, Cp_at_2000, 0.001, 'Cp clamp high', test14Passed, test14Failed));
    
    // Check 3: Enthalpy monotonically increasing beyond valid range
    const h_2000 = thermo.hMolar('N2', 2000, 101325, 'V');
    const h_3000 = thermo.hMolar('N2', 3000, 101325, 'V');
    const h_5000 = thermo.hMolar('N2', 5000, 101325, 'V');
    const monotonic = (h_2000 < h_3000) && (h_3000 < h_5000);
    results.push({
      name: 'h monotonic',
      calc: monotonic ? 'yes' : 'no',
      ref: 'yes',
      delta: monotonic ? 'match' : 'mismatch',
      tol: 'exact',
      status: monotonic ? 'âœ“' : 'âœ—',
      pass: monotonic
    });
    if (monotonic) { passCount++; test14Passed.push('h-monotonic'); }
    else { failCount++; test14Failed.push('h-monotonic'); }
    
    // Check 4: Enthalpy extrapolation is linear (dh scales with dT)
    const dh_1k = h_3000 - h_2000;  // 1000K span
    const dh_2k = h_5000 - h_3000;  // 2000K span
    const linearRatio = dh_2k / dh_1k;  // Should be 2.0 for linear extrapolation
    results.push(checkTolerance(linearRatio, 2.0, 0.01, 'h linear extrap', test14Passed, test14Failed));
    
    printResultsTable(results, null);
    recordTestResult(test14Name, test14Passed, test14Failed, 14);
    
  } catch (err) {
    recordTestError(test14Name, err.message, 4, 14);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 15: Canonical FlashResult Fields (Item 6)
  // =================================================================
  testCount++;
  const test15Name = 'Canonical FlashResult Fields';
  console.log(`\nTest ${testCount}: ${test15Name}`);
  console.log(`  Purpose: Verify all phFlash return paths include mandatory metadata`);
  console.log(`  Scenario: Test normal, empty, unachievable, and two-phase paths`);
  
  try {
    const test15Passed = [];
    const test15Failed = [];
    const results = [];
    
    const mandatoryPH = ['phase', 'beta', 'vaporFraction', 'x', 'y', 'nL', 'nV',
                         'iterations', 'converged', 'T_K', 'bracketed', 'residual_Jps'];
    
    function checkFields(label, result, fields) {
      let missing = [];
      for (const f of fields) {
        if (result[f] === undefined) missing.push(f);
      }
      const allPresent = missing.length === 0;
      return {
        name: label,
        calc: allPresent ? `${fields.length}/${fields.length}` : `missing: ${missing.join(',')}`,
        ref: `${fields.length}/${fields.length}`,
        delta: allPresent ? 'match' : 'mismatch',
        tol: 'exact',
        status: allPresent ? 'âœ“' : 'âœ—',
        pass: allPresent
      };
    }
    
    // Check 1: Normal single-component vapor flash
    const r_normal = thermo.phFlash({ P: 101325, n: { H2O: 1.0 }, H_target_Jps: 50000 });
    const normalResult = checkFields('Normal vapor', r_normal, mandatoryPH);
    results.push(normalResult);
    if (normalResult.pass) { passCount++; test15Passed.push('Normal'); }
    else { failCount++; test15Failed.push('Normal'); }
    
    // Check 2: Empty stream
    const r_empty = thermo.phFlash({ P: 101325, n: { H2O: 0 }, H_target_Jps: 0 });
    const emptyResult = checkFields('Empty stream', r_empty, mandatoryPH);
    results.push(emptyResult);
    if (emptyResult.pass) { passCount++; test15Passed.push('Empty'); }
    else { failCount++; test15Failed.push('Empty'); }
    
    // Check 3: Unachievable target (must include warning)
    const r_unach = thermo.phFlash({ P: 101325, n: { N2: 1.0 }, H_target_Jps: -999999 });
    const unachFields = [...mandatoryPH, 'warning'];
    const unachResult = checkFields('Unachievable', r_unach, unachFields);
    results.push(unachResult);
    if (unachResult.pass) { passCount++; test15Passed.push('Unachievable'); }
    else { failCount++; test15Failed.push('Unachievable'); }
    
    // Check 4: Two-phase lever rule (residual should be exactly 0)
    const Tsat_w = thermo._findSaturationTemperature('H2O', 101325);
    const hf_w = thermo.hMolar('H2O', Tsat_w, 101325, 'L');
    const hg_w = thermo.hMolar('H2O', Tsat_w, 101325, 'V');
    const r_2ph = thermo.phFlash({ P: 101325, n: { H2O: 1.0 }, H_target_Jps: (hf_w + hg_w) / 2 });
    const twophasePass = r_2ph.phase === 'VL' && r_2ph.residual_Jps === 0 && r_2ph.bracketed === true;
    results.push({
      name: 'Two-phase exact',
      calc: `${r_2ph.phase}, res=${r_2ph.residual_Jps}`,
      ref: 'VL, res=0',
      delta: twophasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: twophasePass ? 'âœ“' : 'âœ—',
      pass: twophasePass
    });
    if (twophasePass) { passCount++; test15Passed.push('TwoPhase'); }
    else { failCount++; test15Failed.push('TwoPhase'); }
    
    printResultsTable(results, null);
    recordTestResult(test15Name, test15Passed, test15Failed, 15);
    
  } catch (err) {
    recordTestError(test15Name, err.message, 4, 15);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 16: Heater Enthalpy-Based Energy Balance (Item 8)
  // =================================================================
  testCount++;
  const test16Name = 'Heater Enthalpy Energy Balance';
  console.log(`\nTest ${testCount}: ${test16Name}`);
  console.log(`  Purpose: Verify heater target-temp mode uses exact enthalpy (latent heat captured)`);
  console.log(`  Scenario: H2O heated through boiling point (90Â°C â†’ 110Â°C at 1 atm)`);
  
  try {
    const test16Passed = [];
    const test16Failed = [];
    const results = [];
    
    // Build a heater scenario: liquid H2O at 90Â°C â†’ 110Â°C (crosses boiling point at ~100Â°C)
    // The exact enthalpy method should capture the full latent heat of vaporization (~40.7 kJ/mol)
    // while the old Cp*Î”T method would have given only ~20K * 75.3 J/(molÂ·K) = 1.506 kJ/mol
    
    const T_in_K = 363.15;   // 90Â°C
    const T_out_K = 383.15;  // 110Â°C
    const P_Pa = 101325;
    
    // Compute exact enthalpies at inlet and outlet
    const inStream = { type: StreamType.MATERIAL, T: T_in_K, P: P_Pa, n: { H2O: 1.0 } };
    const H_in = thermo.getHdot_Jps(inStream);
    
    const outStream = { type: StreamType.MATERIAL, T: T_out_K, P: P_Pa, n: { H2O: 1.0 } };
    const H_out = thermo.getHdot_Jps(outStream);
    
    const Q_exact_kW = (H_out - H_in) / 1000;
    
    // What the old Cp*Î”T method would have computed
    const Cp_stream = thermo.streamCp(inStream);  // J/s/K
    const Q_Cp_kW = Cp_stream * (T_out_K - T_in_K) / 1000;
    
    console.log(`  H_in: ${(H_in/1000).toFixed(2)} kW, H_out: ${(H_out/1000).toFixed(2)} kW`);
    console.log(`  Q_exact: ${Q_exact_kW.toFixed(2)} kW, Q_Cp*Î”T: ${Q_Cp_kW.toFixed(2)} kW`);
    
    // Check 1: Exact duty captures latent heat (should be >> Cp*Î”T)
    // Water Hv â‰ˆ 40.7 kJ/mol, so Q_exact should be ~42 kW for 1 mol/s
    const latentCaptured = Q_exact_kW > 30;  // Must be >30 kW (Hv alone is ~40.7)
    results.push({
      name: 'Latent captured',
      calc: `${Q_exact_kW.toFixed(1)} kW`,
      ref: '>30 kW',
      delta: latentCaptured ? 'yes' : 'no',
      tol: 'min 30',
      status: latentCaptured ? 'âœ“' : 'âœ—',
      pass: latentCaptured
    });
    if (latentCaptured) { passCount++; test16Passed.push('Latent'); }
    else { failCount++; test16Failed.push('Latent'); }
    
    // Check 2: Exact >> Cp*Î”T (at least 5Ã— larger when crossing phase change)
    const ratioQs = Q_exact_kW / Q_Cp_kW;
    const ratioPass = ratioQs > 5;
    results.push({
      name: 'Q_exact/Q_Cp ratio',
      calc: ratioQs.toFixed(1),
      ref: '>5',
      delta: ratioPass ? 'pass' : 'fail',
      tol: 'min 5',
      status: ratioPass ? 'âœ“' : 'âœ—',
      pass: ratioPass
    });
    if (ratioPass) { passCount++; test16Passed.push('Ratio'); }
    else { failCount++; test16Failed.push('Ratio'); }
    
    // Check 3: Integration (heater tick): build a full heater and verify it uses H_target_Jps
    clearScene();
    const srcId = scene.placeUnit('source', 0, 0);
    const htrId = scene.placeUnit('heater', 3, 0);
    const snkId = scene.placeUnit('sink', 6, 0);
    
    const srcUnit = scene.units.get(srcId);
    srcUnit.params = { species: 'H2O', nDot: 1, T: 90, P: 101325, phaseConstraint: 'VL' };
    
    const htrUnit = scene.units.get(htrId);
    htrUnit.params = { T_out: 110 };  // Target 110Â°C
    
    scene.connections.push({ id: 'tc1', from: { unitId: srcId, portId: 'out' }, to: { unitId: htrId, portId: 'mat_in' } });
    scene.connections.push({ id: 'tc2', from: { unitId: htrId, portId: 'mat_out' }, to: { unitId: snkId, portId: 'in' } });
    
    const solveResult = solveScene(scene);
    
    // Check that heater output has H_target_Jps set (not bare T)
    const htrData = scene.runtime.unitData.get(htrId);
    const matOut = htrData?.ports?.mat_out;
    const hasHTarget = matOut && matOut.H_target_Jps !== undefined;
    results.push({
      name: 'H_target_Jps set',
      calc: hasHTarget ? 'present' : 'missing',
      ref: 'present',
      delta: hasHTarget ? 'match' : 'mismatch',
      tol: 'exact',
      status: hasHTarget ? 'âœ“' : 'âœ—',
      pass: hasHTarget
    });
    if (hasHTarget) { passCount++; test16Passed.push('H_target'); }
    else { failCount++; test16Failed.push('H_target'); }
    
    printResultsTable(results, null);
    recordTestResult(test16Name, test16Passed, test16Failed, 16);
    
  } catch (err) {
    recordTestError(test16Name, err.message, 3, 16);
    debugLog('Stack trace:', err.stack);
  }
  

  // =================================================================
  // TEST 17: Thermo Package System
  // =================================================================
  testCount++;
  const test17Name = 'Thermo Package System';
  console.log(`\nTest ${testCount}: ${test17Name}`);
  console.log(`  Purpose: Verify package switching infrastructure and cache invalidation`);
  console.log(`  Scenario: Switch packages, verify delegation and cache clearing`);
  
  try {
    const test17Passed = [];
    const test17Failed = [];
    const results = [];
    
    // Check 1: Active package is IdealRaoult by default
    const activePkg = thermo.getPackage();
    const isIdeal = activePkg.id === 'ideal_raoult';
    results.push({
      name: 'Default pkg',
      calc: activePkg.id,
      ref: 'ideal_raoult',
      delta: isIdeal ? 'match' : 'mismatch',
      tol: 'exact',
      status: isIdeal ? 'âœ“' : 'âœ—',
      pass: isIdeal
    });
    if (isIdeal) { passCount++; test17Passed.push('default-pkg'); }
    else { failCount++; test17Failed.push('default-pkg'); }
    
    // Check 2: Package produces correct Cp (delegates properly)
    const Cp_H2O = thermo.cpMolar('H2O', 400, 101325, 'V');
    const Cp_direct = idealRaoultPkg.cpMolar('H2O', 400, 101325, 'V');
    const cpMatch = Math.abs(Cp_H2O - Cp_direct) < 0.001;
    results.push(checkTolerance(Cp_H2O, Cp_direct, 0.001, 'Delegation Cp', test17Passed, test17Failed));
    
    // Check 3: Switch to PR stub (inherits from IdealRaoult, so results should be identical)
    thermo.setPackage(pengRobinsonPkg);
    const Cp_PR = thermo.cpMolar('H2O', 400, 101325, 'V');
    const prMatch = Math.abs(Cp_PR - Cp_direct) < 0.001;
    results.push(checkTolerance(Cp_PR, Cp_direct, 0.001, 'PR stub Cp', test17Passed, test17Failed));
    
    // Check 4: getPackage reflects the switch
    const nowPR = thermo.getPackage().id === 'peng_robinson';
    results.push({
      name: 'Switched to PR',
      calc: thermo.getPackage().id,
      ref: 'peng_robinson',
      delta: nowPR ? 'match' : 'mismatch',
      tol: 'exact',
      status: nowPR ? 'âœ“' : 'âœ—',
      pass: nowPR
    });
    if (nowPR) { passCount++; test17Passed.push('switch-PR'); }
    else { failCount++; test17Failed.push('switch-PR'); }
    
    // Check 5: Switch back to IdealRaoult and verify clean state
    thermo.setPackage(idealRaoultPkg);
    const Cp_back = thermo.cpMolar('H2O', 400, 101325, 'V');
    results.push(checkTolerance(Cp_back, Cp_direct, 0.001, 'Switch back Cp', test17Passed, test17Failed));
    
    // Check 6: ModelRegistry has both packages registered
    const pkgList = models.list('thermo_package');
    const hasBoth = pkgList.length >= 2 && pkgList.some(p => p.id === 'ideal_raoult') && pkgList.some(p => p.id === 'peng_robinson');
    results.push({
      name: 'Registry has both',
      calc: pkgList.map(p => p.id).join(', '),
      ref: 'ideal_raoult, peng_robinson',
      delta: hasBoth ? 'match' : 'mismatch',
      tol: 'exact',
      status: hasBoth ? 'âœ“' : 'âœ—',
      pass: hasBoth
    });
    if (hasBoth) { passCount++; test17Passed.push('registry'); }
    else { failCount++; test17Failed.push('registry'); }
    
    printResultsTable(results, null);
    recordTestResult(test17Name, test17Passed, test17Failed, 17);
    
  } catch (err) {
    recordTestError(test17Name, err.message, 6, 17);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 18: Mixer â€” Same-Component Sensible Mixing (N2 Vapor)
  // =================================================================
  testCount++;
  const test18Name = 'Mixer: N2 Sensible Mixing';
  console.log(`\nTest ${testCount}: ${test18Name}`);
  console.log(`  Topology: Source(N2,300K,200kPa) + Source(N2,500K,100kPa) â†’ Mixer â†’ Sink`);
  console.log(`  Scenario: Adiabatic mixing of two N2 vapor streams`);
  
  try {
    clearScene();
    const test18Passed = [];
    const test18Failed = [];
    const results = [];
    
    // Build topology
    const src1Id = scene.placeUnit('source', 0, 0);
    const src2Id = scene.placeUnit('source', 0, 3);
    const mixId = scene.placeUnit('mixer', 4, 1);
    const snkId = scene.placeUnit('sink', 8, 1);
    
    // Configure sources
    const src1 = scene.units.get(src1Id);
    src1.params = { species: 'N2', nDot: 10, T: 27, P: 200000, phaseConstraint: 'V' };  // 300K
    
    const src2 = scene.units.get(src2Id);
    src2.params = { species: 'N2', nDot: 10, T: 227, P: 100000, phaseConstraint: 'V' }; // 500K
    
    // Connect: src1â†’mixer.in1, src2â†’mixer.in2, mixer.outâ†’sink
    scene.connections.push({ id: 'c1', from: { unitId: src1Id, portId: 'out' }, to: { unitId: mixId, portId: 'in1' } });
    scene.connections.push({ id: 'c2', from: { unitId: src2Id, portId: 'out' }, to: { unitId: mixId, portId: 'in2' } });
    scene.connections.push({ id: 'c3', from: { unitId: mixId, portId: 'out' }, to: { unitId: snkId, portId: 'in' } });
    
    const solveResult = solveScene(scene);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    // Extract mixer outlet
    const mixUD = scene.runtime.unitData.get(mixId);
    const outStream = mixUD?.ports?.out;
    
    if (!outStream) throw new Error('No mixer outlet stream');
    
    // Check 1: P_out = min(200000, 100000) = 100000 Pa
    results.push(checkTolerance(outStream.P, 100000, 1, 'P_out [Pa]', test18Passed, test18Failed));
    
    // Check 2: Total flow = 10 + 10 = 20 mol/s
    const nTotal = Object.values(outStream.n).reduce((a, b) => a + b, 0);
    results.push(checkTolerance(nTotal, 20, 0.001, 'n_total [mol/s]', test18Passed, test18Failed));
    
    // Check 3: Phase should be V
    const phasePass = outStream.phase === 'V';
    results.push({
      name: 'Phase',
      calc: outStream.phase,
      ref: 'V',
      delta: phasePass ? 'match' : 'mismatch',
      tol: 'exact',
      status: phasePass ? 'âœ“' : 'âœ—',
      pass: phasePass
    });
    if (phasePass) { passCount++; test18Passed.push('Phase'); }
    else { failCount++; test18Failed.push('Phase'); }
    
    // Check 4: Enthalpy balance â€” H_out should equal H_in1 + H_in2
    // Compute reference H from the sources
    const H_in1 = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 300, P: 200000, n: { N2: 10 } });
    const H_in2 = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 500, P: 100000, n: { N2: 10 } });
    const H_ref = H_in1 + H_in2;
    const H_out = outStream.Hdot_J_s || thermo.getHdot_Jps(outStream);
    const hBalErr = Math.abs(H_out - H_ref);
    const hBalTol = Math.max(Math.abs(H_ref) * 5e-3, 1);  // 0.5% relative tolerance (accounts for PH flash convergence)
    results.push(checkTolerance(hBalErr, 0, hBalTol, 'H balance [J/s]', test18Passed, test18Failed));
    
    // Check 5: Temperature â€” compute reference by PH flash and compare
    const refFlash = thermo.phFlash({ P: 100000, n: { N2: 20 }, H_target_Jps: H_ref });
    results.push(checkTolerance(outStream.T, refFlash.T_K, 0.5, 'T_out [K]', test18Passed, test18Failed));
    
    // Check 6: T should be between 300K and 500K (sanity)
    const tSanity = outStream.T > 300 && outStream.T < 500;
    results.push({
      name: 'T in range',
      calc: outStream.T.toFixed(1),
      ref: '300-500 K',
      delta: tSanity ? 'in range' : 'OUT OF RANGE',
      tol: 'range',
      status: tSanity ? 'âœ“' : 'âœ—',
      pass: tSanity
    });
    if (tSanity) { passCount++; test18Passed.push('T-range'); }
    else { failCount++; test18Failed.push('T-range'); }
    
    console.log(`  T_out: ${outStream.T.toFixed(2)} K, T_ref: ${refFlash.T_K.toFixed(2)} K`);
    
    printResultsTable(results, null);
    recordTestResult(test18Name, test18Passed, test18Failed, 18);
    
  } catch (err) {
    recordTestError(test18Name, err.message, 6, 18);
    debugLog('Stack trace:', err.stack);
  }
  
  // =================================================================
  // TEST 19: Mixer â€” Multi-Component Composition Mixing (CO2 + N2)
  // =================================================================
  testCount++;
  const test19Name = 'Mixer: CO2+N2 Composition';
  console.log(`\nTest ${testCount}: ${test19Name}`);
  console.log(`  Topology: Source(CO2,350K,300kPa) + Source(N2,350K,100kPa) â†’ Mixer â†’ Sink`);
  console.log(`  Scenario: Mixing two species at same T, verifying composition merge`);
  
  try {
    clearScene();
    const test19Passed = [];
    const test19Failed = [];
    const results = [];
    
    // Build topology
    const src1Id = scene.placeUnit('source', 0, 0);
    const src2Id = scene.placeUnit('source', 0, 3);
    const mixId = scene.placeUnit('mixer', 4, 1);
    const snkId = scene.placeUnit('sink', 8, 1);
    
    const src1 = scene.units.get(src1Id);
    src1.params = { species: 'CO2', nDot: 10, T: 77, P: 300000, phaseConstraint: 'V' };  // 350K
    
    const src2 = scene.units.get(src2Id);
    src2.params = { species: 'N2', nDot: 30, T: 77, P: 100000, phaseConstraint: 'V' };   // 350K
    
    scene.connections.push({ id: 'c1', from: { unitId: src1Id, portId: 'out' }, to: { unitId: mixId, portId: 'in1' } });
    scene.connections.push({ id: 'c2', from: { unitId: src2Id, portId: 'out' }, to: { unitId: mixId, portId: 'in2' } });
    scene.connections.push({ id: 'c3', from: { unitId: mixId, portId: 'out' }, to: { unitId: snkId, portId: 'in' } });
    
    const solveResult = solveScene(scene);
    
    if (!solveResult.ok) {
      throw new Error(`Solver failed. Diagnostics: ${JSON.stringify(solveResult.diagnostics)}`);
    }
    
    const mixUD = scene.runtime.unitData.get(mixId);
    const outStream = mixUD?.ports?.out;
    
    if (!outStream) throw new Error('No mixer outlet stream');
    
    // Check 1: P_out = min(300000, 100000) = 100000 Pa
    results.push(checkTolerance(outStream.P, 100000, 1, 'P_out [Pa]', test19Passed, test19Failed));
    
    // Check 2: n_out[CO2] = 10 mol/s
    results.push(checkTolerance(outStream.n.CO2 || 0, 10, 0.001, 'n_CO2 [mol/s]', test19Passed, test19Failed));
    
    // Check 3: n_out[N2] = 30 mol/s
    results.push(checkTolerance(outStream.n.N2 || 0, 30, 0.001, 'n_N2 [mol/s]', test19Passed, test19Failed));
    
    // Check 4: Enthalpy balance
    const H_in1 = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 350, P: 300000, n: { CO2: 10 } });
    const H_in2 = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 350, P: 100000, n: { N2: 30 } });
    const H_ref = H_in1 + H_in2;
    const H_out = outStream.Hdot_J_s || thermo.getHdot_Jps(outStream);
    const hBalErr = Math.abs(H_out - H_ref);
    const hBalTol = Math.max(Math.abs(H_ref) * 5e-3, 1);  // 0.5% relative tolerance (accounts for PH flash convergence)
    results.push(checkTolerance(hBalErr, 0, hBalTol, 'H balance [J/s]', test19Passed, test19Failed));
    
    // Check 5: Temperature â€” same inlet T â†’ outlet T â‰ˆ 350 K (ideal gas at same T)
    // Use PH flash reference for exact comparison
    const refFlash = thermo.phFlash({ P: 100000, n: { CO2: 10, N2: 30 }, H_target_Jps: H_ref });
    results.push(checkTolerance(outStream.T, refFlash.T_K, 0.5, 'T_out [K]', test19Passed, test19Failed));
    
    // Check 6: Mole fractions in flash result
    const nTotal = (outStream.n.CO2 || 0) + (outStream.n.N2 || 0);
    const yCO2 = (outStream.n.CO2 || 0) / nTotal;
    results.push(checkTolerance(yCO2, 0.25, 0.001, 'y_CO2', test19Passed, test19Failed));
    
    console.log(`  T_out: ${outStream.T.toFixed(2)} K, T_ref: ${refFlash.T_K.toFixed(2)} K`);
    console.log(`  Composition: CO2=${(yCO2*100).toFixed(1)}%, N2=${((1-yCO2)*100).toFixed(1)}%`);
    
    printResultsTable(results, null);
    recordTestResult(test19Name, test19Passed, test19Failed, 19);
    
  } catch (err) {
    recordTestError(test19Name, err.message, 6, 19);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 20: Splitter â€” Single Component 50/50 (N2 Vapor)
  // =================================================================
  testCount++;
  const test20Name = 'Splitter: N2 50/50 Split';
  console.log(`\nTest ${testCount}: ${test20Name}`);
  console.log(`  Topology: Source(N2,400K,200kPa,10mol/s) â†’ Splitter(50%) â†’ Sink1 + Sink2`);
  console.log(`  Scenario: Equal split of single-component vapor stream`);
  
  try {
    clearScene();
    const test20Passed = [];
    const test20Failed = [];
    const results = [];
    
    const srcId = scene.placeUnit('source', 0, 1);
    const splId = scene.placeUnit('splitter', 4, 1);
    const snk1Id = scene.placeUnit('sink', 8, 0);
    const snk2Id = scene.placeUnit('sink', 8, 3);
    
    scene.units.get(srcId).params = { species: 'N2', nDot: 10, T: 127, P: 200000, phaseConstraint: 'V' };  // 400K
    scene.units.get(splId).params = { splitPct: 50 };
    
    scene.connections.push({ id: 'c1', from: { unitId: srcId, portId: 'out' }, to: { unitId: splId, portId: 'in' } });
    scene.connections.push({ id: 'c2', from: { unitId: splId, portId: 'out1' }, to: { unitId: snk1Id, portId: 'in' } });
    scene.connections.push({ id: 'c3', from: { unitId: splId, portId: 'out2' }, to: { unitId: snk2Id, portId: 'in' } });
    
    solveScene(scene);
    
    const splUD = scene.runtime.unitData.get(splId);
    const out1 = splUD?.ports?.out1;
    const out2 = splUD?.ports?.out2;
    if (!out1 || !out2) throw new Error('Missing splitter output streams');
    
    // Check 1: n_out1 = 5 mol/s
    results.push(checkTolerance(out1.n.N2 || 0, 5, 0.001, 'n_out1[N2]', test20Passed, test20Failed));
    
    // Check 2: n_out2 = 5 mol/s
    results.push(checkTolerance(out2.n.N2 || 0, 5, 0.001, 'n_out2[N2]', test20Passed, test20Failed));
    
    // Check 3: P preserved on both outlets
    results.push(checkTolerance(out1.P, 200000, 1, 'P_out1 [Pa]', test20Passed, test20Failed));
    
    // Check 4: T preserved (~400K on both outlets, PH flash for same specific h)
    results.push(checkTolerance(out1.T, 400, 1.0, 'T_out1 [K]', test20Passed, test20Failed));
    
    // Check 5: Enthalpy balance: H_out1 + H_out2 â‰ˆ H_in
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 400, P: 200000, n: { N2: 10 } });
    const H_out1 = thermo.getHdot_Jps(out1);
    const H_out2 = thermo.getHdot_Jps(out2);
    const hBalErr = Math.abs((H_out1 + H_out2) - H_in);
    const hBalTol = Math.max(Math.abs(H_in) * 5e-3, 1);
    results.push(checkTolerance(hBalErr, 0, hBalTol, 'H balance [J/s]', test20Passed, test20Failed));
    
    printResultsTable(results, null);
    recordTestResult(test20Name, test20Passed, test20Failed, 20);
    
  } catch (err) {
    recordTestError(test20Name, err.message, 5, 20);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 21: Splitter â€” Multi-Component 70/30 (CO2 + N2 mixture)
  // =================================================================
  testCount++;
  const test21Name = 'Splitter: CO2+N2 70/30';
  console.log(`\nTest ${testCount}: ${test21Name}`);
  console.log(`  Topology: Source(CO2) + Source(N2) â†’ Mixer â†’ Splitter(70%) â†’ Sink1 + Sink2`);
  console.log(`  Scenario: Asymmetric split preserving composition ratio`);
  
  try {
    clearScene();
    const test21Passed = [];
    const test21Failed = [];
    const results = [];
    
    // Build: 2 sources â†’ mixer â†’ splitter â†’ 2 sinks
    const srcCO2 = scene.placeUnit('source', 0, 0);
    const srcN2 = scene.placeUnit('source', 0, 3);
    const mixId = scene.placeUnit('mixer', 4, 1);
    const splId = scene.placeUnit('splitter', 8, 1);
    const snk1Id = scene.placeUnit('sink', 12, 0);
    const snk2Id = scene.placeUnit('sink', 12, 3);
    
    scene.units.get(srcCO2).params = { species: 'CO2', nDot: 10, T: 77, P: 200000, phaseConstraint: 'V' };  // 350K
    scene.units.get(srcN2).params = { species: 'N2', nDot: 30, T: 77, P: 200000, phaseConstraint: 'V' };    // 350K
    scene.units.get(splId).params = { splitPct: 70 };
    
    scene.connections.push({ id: 'c1', from: { unitId: srcCO2, portId: 'out' }, to: { unitId: mixId, portId: 'in1' } });
    scene.connections.push({ id: 'c2', from: { unitId: srcN2, portId: 'out' }, to: { unitId: mixId, portId: 'in2' } });
    scene.connections.push({ id: 'c3', from: { unitId: mixId, portId: 'out' }, to: { unitId: splId, portId: 'in' } });
    scene.connections.push({ id: 'c4', from: { unitId: splId, portId: 'out1' }, to: { unitId: snk1Id, portId: 'in' } });
    scene.connections.push({ id: 'c5', from: { unitId: splId, portId: 'out2' }, to: { unitId: snk2Id, portId: 'in' } });
    
    solveScene(scene);
    
    const splUD = scene.runtime.unitData.get(splId);
    const out1 = splUD?.ports?.out1;
    const out2 = splUD?.ports?.out2;
    if (!out1 || !out2) throw new Error('Missing splitter output streams');
    
    // Check 1-2: Out1 component flows (70% of mixer: CO2=7, N2=21)
    results.push(checkTolerance(out1.n.CO2 || 0, 7, 0.01, 'out1 n_CO2', test21Passed, test21Failed));
    results.push(checkTolerance(out1.n.N2 || 0, 21, 0.01, 'out1 n_N2', test21Passed, test21Failed));
    
    // Check 3-4: Out2 component flows (30% of mixer: CO2=3, N2=9)
    results.push(checkTolerance(out2.n.CO2 || 0, 3, 0.01, 'out2 n_CO2', test21Passed, test21Failed));
    results.push(checkTolerance(out2.n.N2 || 0, 9, 0.01, 'out2 n_N2', test21Passed, test21Failed));
    
    // Check 5: Composition ratio preserved (yCO2 = 0.25 in both outlets)
    const nTot1 = (out1.n.CO2 || 0) + (out1.n.N2 || 0);
    const yCO2_out1 = (out1.n.CO2 || 0) / nTot1;
    results.push(checkTolerance(yCO2_out1, 0.25, 0.001, 'y_CO2 preserved', test21Passed, test21Failed));
    
    // Check 6: Global mass balance (out1 + out2 = mixer input = 40 mol/s)
    const nTot2 = (out2.n.CO2 || 0) + (out2.n.N2 || 0);
    results.push(checkTolerance(nTot1 + nTot2, 40, 0.01, 'n_total [mol/s]', test21Passed, test21Failed));
    
    printResultsTable(results, null);
    recordTestResult(test21Name, test21Passed, test21Failed, 21);
    
  } catch (err) {
    recordTestError(test21Name, err.message, 6, 21);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 22: Splitter â€” Edge Cases (100% and 0%)
  // =================================================================
  testCount++;
  const test22Name = 'Splitter: Edge Cases 100%/0%';
  console.log(`\nTest ${testCount}: ${test22Name}`);
  console.log(`  Scenario: Boundary split fractions â€” all to one outlet`);
  
  try {
    clearScene();
    const test22Passed = [];
    const test22Failed = [];
    const results = [];
    
    // â”€â”€â”€ Case A: 100% to out1 â”€â”€â”€
    const srcA = scene.placeUnit('source', 0, 1);
    const splA = scene.placeUnit('splitter', 4, 1);
    const snkA1 = scene.placeUnit('sink', 8, 0);
    const snkA2 = scene.placeUnit('sink', 8, 3);
    
    scene.units.get(srcA).params = { species: 'H2O', nDot: 5, T: 27, P: 101325, phaseConstraint: 'L' };  // 300K liquid
    scene.units.get(splA).params = { splitPct: 100 };
    
    scene.connections.push({ id: 'c1', from: { unitId: srcA, portId: 'out' }, to: { unitId: splA, portId: 'in' } });
    scene.connections.push({ id: 'c2', from: { unitId: splA, portId: 'out1' }, to: { unitId: snkA1, portId: 'in' } });
    scene.connections.push({ id: 'c3', from: { unitId: splA, portId: 'out2' }, to: { unitId: snkA2, portId: 'in' } });
    
    solveScene(scene);
    
    const splAUD = scene.runtime.unitData.get(splA);
    const outA1 = splAUD?.ports?.out1;
    const outA2 = splAUD?.ports?.out2;
    if (!outA1 || !outA2) throw new Error('Missing outputs for 100% case');
    
    // Check 1: out1 gets everything
    results.push(checkTolerance(outA1.n.H2O || 0, 5, 0.001, '100%: out1 n_H2O', test22Passed, test22Failed));
    
    // Check 2: out2 gets nothing
    results.push(checkTolerance(outA2.n.H2O || 0, 0, 1e-10, '100%: out2 n_H2O', test22Passed, test22Failed));
    
    // â”€â”€â”€ Case B: 0% to out1 (everything to out2) â”€â”€â”€
    clearScene();
    
    const srcB = scene.placeUnit('source', 0, 1);
    const splB = scene.placeUnit('splitter', 4, 1);
    const snkB1 = scene.placeUnit('sink', 8, 0);
    const snkB2 = scene.placeUnit('sink', 8, 3);
    
    scene.units.get(srcB).params = { species: 'N2', nDot: 10, T: 127, P: 200000, phaseConstraint: 'V' };  // 400K
    scene.units.get(splB).params = { splitPct: 0 };
    
    scene.connections.push({ id: 'c1', from: { unitId: srcB, portId: 'out' }, to: { unitId: splB, portId: 'in' } });
    scene.connections.push({ id: 'c2', from: { unitId: splB, portId: 'out1' }, to: { unitId: snkB1, portId: 'in' } });
    scene.connections.push({ id: 'c3', from: { unitId: splB, portId: 'out2' }, to: { unitId: snkB2, portId: 'in' } });
    
    solveScene(scene);
    
    const splBUD = scene.runtime.unitData.get(splB);
    const outB1 = splBUD?.ports?.out1;
    const outB2 = splBUD?.ports?.out2;
    if (!outB1 || !outB2) throw new Error('Missing outputs for 0% case');
    
    // Check 3: out1 gets nothing
    results.push(checkTolerance(outB1.n.N2 || 0, 0, 1e-10, '0%: out1 n_N2', test22Passed, test22Failed));
    
    // Check 4: out2 gets everything
    results.push(checkTolerance(outB2.n.N2 || 0, 10, 0.001, '0%: out2 n_N2', test22Passed, test22Failed));
    
    printResultsTable(results, null);
    recordTestResult(test22Name, test22Passed, test22Failed, 22);
    
  } catch (err) {
    recordTestError(test22Name, err.message, 4, 22);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 23: Recycle Loop â€” Source + Mixer + Splitter
  // =================================================================
  testCount++;
  const test23Name = 'Recycle Loop: Mixer+Splitter';
  console.log(`\nTest ${testCount}: ${test23Name}`);
  console.log(`  Topology: Source(N2,10mol/s,400K,200kPa) â†’ Mixer â†’ Splitter(50%) â†’ Sink + Recycleâ†’Mixer`);
  console.log(`  Scenario: Steady-state recycle loop via successive substitution`);
  console.log(`  Analytical: At steady state M=F/Î±=10/0.5=20 mol/s through mixer`);
  
  try {
    clearScene();
    const test23Passed = [];
    const test23Failed = [];
    const results = [];
    
    // Build recycle topology:
    //   Source â”€â†’ Mixer.in1
    //             Mixer.out â”€â†’ Splitter.in
    //                          Splitter.out1 â”€â†’ Sink (product)
    //             Mixer.in2 â†â”€ Splitter.out2 (recycle)
    
    const srcId = scene.placeUnit('source', 0, 1);
    const mixId = scene.placeUnit('mixer', 4, 1);
    const splId = scene.placeUnit('splitter', 8, 1);
    const snkId = scene.placeUnit('sink', 12, 0);
    
    scene.units.get(srcId).params = { species: 'N2', nDot: 10, T: 127, P: 200000, phaseConstraint: 'V' };  // 400K
    scene.units.get(splId).params = { splitPct: 50 };
    
    // Forward connections
    scene.connections.push({ id: 'c1', from: { unitId: srcId, portId: 'out' }, to: { unitId: mixId, portId: 'in1' } });
    scene.connections.push({ id: 'c2', from: { unitId: mixId, portId: 'out' }, to: { unitId: splId, portId: 'in' } });
    scene.connections.push({ id: 'c3', from: { unitId: splId, portId: 'out1' }, to: { unitId: snkId, portId: 'in' } });
    // RECYCLE: splitter out2 â†’ mixer in2
    scene.connections.push({ id: 'c4', from: { unitId: splId, portId: 'out2' }, to: { unitId: mixId, portId: 'in2' } });
    
    const solveResult = solveScene(scene);
    
    console.log(`  Solver: ${scene.runtime.lastSolve.iterations} iterations, ok=${solveResult.ok}`);
    
    // Get mixer outlet and splitter outlets
    const mixUD = scene.runtime.unitData.get(mixId);
    const splUD = scene.runtime.unitData.get(splId);
    const mixOut = mixUD?.ports?.out;
    const splOut1 = splUD?.ports?.out1;
    const splOut2 = splUD?.ports?.out2;
    
    if (!mixOut) throw new Error('Mixer has no output â€” recycle bootstrap failed');
    if (!splOut1 || !splOut2) throw new Error('Splitter has no outputs');
    
    const nMix = Object.values(mixOut.n).reduce((a, b) => a + b, 0);
    const nProduct = Object.values(splOut1.n).reduce((a, b) => a + b, 0);
    const nRecycle = Object.values(splOut2.n).reduce((a, b) => a + b, 0);
    
    console.log(`  Mixer outlet: ${nMix.toFixed(4)} mol/s (target: 20.0)`);
    console.log(`  Product:      ${nProduct.toFixed(4)} mol/s (target: 10.0)`);
    console.log(`  Recycle:      ${nRecycle.toFixed(4)} mol/s (target: 10.0)`);
    console.log(`  T_mixer_out:  ${mixOut.T?.toFixed(2)} K (target: 400.0)`);
    
    // Check 1: Mixer outlet flow â‰ˆ 20 mol/s (F/Î± analytical solution)
    // With 20 iterations of geometric convergence: 20*(1-0.5^20) â‰ˆ 19.99998
    results.push(checkTolerance(nMix, 20, 0.1, 'M_mixer [mol/s]', test23Passed, test23Failed));
    
    // Check 2: Product flow â‰ˆ 10 mol/s (global mass balance: product = feed)
    results.push(checkTolerance(nProduct, 10, 0.1, 'n_product [mol/s]', test23Passed, test23Failed));
    
    // Check 3: Recycle flow â‰ˆ 10 mol/s
    results.push(checkTolerance(nRecycle, 10, 0.1, 'n_recycle [mol/s]', test23Passed, test23Failed));
    
    // Check 4: Temperature preserved (all N2 at same conditions â†’ T stays 400K)
    results.push(checkTolerance(mixOut.T, 400, 1.0, 'T_mixer_out [K]', test23Passed, test23Failed));
    
    // Check 5: Pressure preserved at 200 kPa
    results.push(checkTolerance(mixOut.P, 200000, 1, 'P_mixer_out [Pa]', test23Passed, test23Failed));
    
    // Check 6: Global mass balance â€” product â‰ˆ feed within tolerance
    // This is the fundamental check: what leaves = what enters
    results.push(checkTolerance(nProduct, 10, 0.1, 'Global balance', test23Passed, test23Failed));
    
    printResultsTable(results, null);
    recordTestResult(test23Name, test23Passed, test23Failed, 23);
    
  } catch (err) {
    recordTestError(test23Name, err.message, 6, 23);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 24: Heater â€” N2 Sensible Heating (Duty Mode)
  // =================================================================
  testCount++;
  const test24Name = 'Heater: N2 Sensible (T_out)';
  console.log(`\nTest ${testCount}: ${test24Name}`);
  console.log(`  Topology: Source(N2,300K,200kPa,10mol/s) â†’ Heater(T_out=127Â°C) â†’ Sink`);
  console.log(`  Scenario: Pure sensible heating to 400K, no phase change`);
  
  try {
    clearScene();
    const test24Passed = [];
    const test24Failed = [];
    const results = [];
    
    const srcId = scene.placeUnit('source', 0, 1);
    const htrId = scene.placeUnit('heater', 4, 1);
    const snkId = scene.placeUnit('sink', 8, 1);
    
    scene.units.get(srcId).params = { species: 'N2', nDot: 10, T: 27, P: 200000, phaseConstraint: 'V' };  // 300K
    scene.units.get(htrId).params = { T_out: 127 };  // 400K setpoint
    
    scene.connections.push({ id: 'c1', from: { unitId: srcId, portId: 'out' }, to: { unitId: htrId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: htrId, portId: 'mat_out' }, to: { unitId: snkId, portId: 'in' } });
    
    solveScene(scene);
    
    const htrUD = scene.runtime.unitData.get(htrId);
    const outS = htrUD?.ports?.mat_out;
    if (!outS) throw new Error('No heater outlet');
    
    // Reference: heater targets 400K
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 300, P: 200000, n: { N2: 10 } });
    const H_ref = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 400, P: 200000, n: { N2: 10 } });
    
    // Check 1: T_out matches setpoint
    results.push(checkTolerance(outS.T, 400, 1.0, 'T_out [K]', test24Passed, test24Failed));
    
    // Check 2: Phase = V (N2 stays vapor)
    const phasePass = outS.phase === 'V';
    results.push({ name: 'Phase', calc: outS.phase, ref: 'V', delta: phasePass ? 'match' : 'mismatch', tol: 'exact', status: phasePass ? 'âœ“' : 'âœ—', pass: phasePass });
    if (phasePass) { passCount++; test24Passed.push('Phase'); } else { failCount++; test24Failed.push('Phase'); }
    
    // Check 3: Enthalpy balance (H_out â‰ˆ H_ref at 400K)
    const H_out = thermo.getHdot_Jps(outS);
    const hBalErr = Math.abs(H_out - H_ref);
    results.push(checkTolerance(hBalErr, 0, Math.max(Math.abs(H_ref) * 5e-3, 1), 'H balance [J/s]', test24Passed, test24Failed));
    
    // Check 4: Q > 0 (heating)
    const Q_kW = (H_out - H_in) / 1000;
    const qPositive = Q_kW > 0;
    results.push({ name: 'Q > 0', calc: Q_kW.toFixed(1) + ' kW', ref: '>0', delta: qPositive ? 'yes' : 'NO', tol: 'check', status: qPositive ? 'âœ“' : 'âœ—', pass: qPositive });
    if (qPositive) { passCount++; test24Passed.push('Q-positive'); } else { failCount++; test24Failed.push('Q-positive'); }
    
    console.log(`  T_out: ${outS.T.toFixed(2)} K (setpoint 400K), Q: ${Q_kW.toFixed(2)} kW`);
    
    printResultsTable(results, null);
    recordTestResult(test24Name, test24Passed, test24Failed, 24);
    
  } catch (err) {
    recordTestError(test24Name, err.message, 4, 24);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 25: Heater â€” H2O Phase Change (Boiling, T_out Mode)
  // =================================================================
  testCount++;
  const test25Name = 'Heater: H2O Boiling';
  console.log(`\nTest ${testCount}: ${test25Name}`);
  console.log(`  Topology: Source(H2O,90Â°C,1atm,1mol/s,L) â†’ Heater(T_out=150Â°C) â†’ Sink`);
  console.log(`  Scenario: Liquidâ†’vapor phase change, latent heat must be included`);
  
  try {
    clearScene();
    const test25Passed = [];
    const test25Failed = [];
    const results = [];
    
    const srcId = scene.placeUnit('source', 0, 1);
    const htrId = scene.placeUnit('heater', 4, 1);
    const snkId = scene.placeUnit('sink', 8, 1);
    
    scene.units.get(srcId).params = { species: 'H2O', nDot: 1, T: 90, P: 101325, phaseConstraint: 'L' };
    scene.units.get(htrId).params = { T_out: 150 };  // 150Â°C â†’ 423.15K
    
    scene.connections.push({ id: 'c1', from: { unitId: srcId, portId: 'out' }, to: { unitId: htrId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: htrId, portId: 'mat_out' }, to: { unitId: snkId, portId: 'in' } });
    
    solveScene(scene);
    
    const htrUD = scene.runtime.unitData.get(htrId);
    const outS = htrUD?.ports?.mat_out;
    if (!outS) throw new Error('No heater outlet');
    
    // Check 1: T_out â‰ˆ 423.15K (150Â°C target)
    results.push(checkTolerance(outS.T, 423.15, 1.0, 'T_out [K]', test25Passed, test25Failed));
    
    // Check 2: Phase = V (superheated steam at 150Â°C, 1 atm)
    const phasePass = outS.phase === 'V';
    results.push({ name: 'Phase', calc: outS.phase, ref: 'V', delta: phasePass ? 'match' : 'mismatch', tol: 'exact', status: phasePass ? 'âœ“' : 'âœ—', pass: phasePass });
    if (phasePass) { passCount++; test25Passed.push('Phase'); } else { failCount++; test25Failed.push('Phase'); }
    
    // Check 3: Q includes latent heat â€” should be ~43.1 kW (753 sens + 40660 lat + ~1715 superheat)
    const Q_kW = (htrUD.last.Q_actual_W || 0) / 1000;  // Wâ†’kW
    const H2O_Hv = ComponentRegistry.get('H2O').Hv;  // 40660 J/mol
    // Q must be significantly above sensible-only heating: cpLiq*(150-90)=75.3*60=4518 J/mol = 4.5kW
    // With latent heat: ~43.1 kW
    const includesLatent = Q_kW > 40;  // Must be >> sensible-only 4.5 kW
    results.push({ name: 'Q includes Hv', calc: Q_kW.toFixed(1)+' kW', ref: '>40 kW', delta: includesLatent ? 'yes' : 'NO', tol: 'check', status: includesLatent ? 'âœ“' : 'âœ—', pass: includesLatent });
    if (includesLatent) { passCount++; test25Passed.push('Q-latent'); } else { failCount++; test25Failed.push('Q-latent'); }
    
    // Check 4: Enthalpy balance
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 363.15, P: 101325, n: { H2O: 1 } });
    const H_out = thermo.getHdot_Jps(outS);
    const Q_check = (H_out - H_in) / 1000;
    results.push(checkTolerance(Q_check, Q_kW, Math.max(Q_kW * 5e-3, 0.1), 'Q balance [kW]', test25Passed, test25Failed));
    
    console.log(`  T_out: ${outS.T.toFixed(2)} K, Q: ${Q_kW.toFixed(2)} kW (includes ${H2O_Hv} J/mol latent heat)`);
    
    printResultsTable(results, null);
    recordTestResult(test25Name, test25Passed, test25Failed, 25);
    
  } catch (err) {
    recordTestError(test25Name, err.message, 4, 25);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 26: HEX â€” Two-Stream Energy Balance (N2 Hot/Cold)
  // =================================================================
  testCount++;
  const test26Name = 'HEX: N2 Energy Balance';
  console.log(`\nTest ${testCount}: ${test26Name}`);
  console.log(`  Topology: Source(N2,500K) â†’ hot_in â†’ HEX â†’ hot_out â†’ Sink`);
  console.log(`            Source(N2,300K) â†’ cold_in â†’ HEX â†’ cold_out â†’ Sink`);
  console.log(`  Scenario: T_hot_out=350K specified, verify 1st law energy balance`);
  
  try {
    clearScene();
    const test26Passed = [];
    const test26Failed = [];
    const results = [];
    
    const srcHot = scene.placeUnit('source', 0, 2);
    const srcCold = scene.placeUnit('source', 3, 0);
    const hexId = scene.placeUnit('hex', 4, 2);
    const snkHot = scene.placeUnit('sink', 8, 2);
    const snkCold = scene.placeUnit('sink', 3, 5);
    
    scene.units.get(srcHot).params = { species: 'N2', nDot: 10, T: 227, P: 200000, phaseConstraint: 'V' };  // 500K
    scene.units.get(srcCold).params = { species: 'N2', nDot: 10, T: 27, P: 200000, phaseConstraint: 'V' };   // 300K
    scene.units.get(hexId).params = { T_hot_out: 77 };  // 350K target for hot outlet
    
    scene.connections.push({ id: 'c1', from: { unitId: srcHot, portId: 'out' }, to: { unitId: hexId, portId: 'hot_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: hexId, portId: 'hot_out' }, to: { unitId: snkHot, portId: 'in' } });
    scene.connections.push({ id: 'c3', from: { unitId: srcCold, portId: 'out' }, to: { unitId: hexId, portId: 'cold_in' } });
    scene.connections.push({ id: 'c4', from: { unitId: hexId, portId: 'cold_out' }, to: { unitId: snkCold, portId: 'in' } });
    
    solveScene(scene);
    
    const hexUD = scene.runtime.unitData.get(hexId);
    const hotOut = hexUD?.ports?.hot_out;
    const coldOut = hexUD?.ports?.cold_out;
    if (!hotOut || !coldOut) throw new Error('Missing HEX outlet streams');
    
    // Compute all four enthalpies
    const H_hot_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 500, P: 200000, n: { N2: 10 } });
    const H_cold_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 300, P: 200000, n: { N2: 10 } });
    const H_hot_out = thermo.getHdot_Jps(hotOut);
    const H_cold_out = thermo.getHdot_Jps(coldOut);
    
    // Check 1: Hot outlet T â‰ˆ 350K
    results.push(checkTolerance(hotOut.T, 350, 1.0, 'T_hot_out [K]', test26Passed, test26Failed));
    
    // Check 2: Cold outlet T > 300K (heated)
    const coldHeated = coldOut.T > 300;
    results.push({ name: 'T_cold_out > T_cold_in', calc: coldOut.T.toFixed(1), ref: '>300K', delta: coldHeated ? 'yes' : 'NO', tol: 'check', status: coldHeated ? 'âœ“' : 'âœ—', pass: coldHeated });
    if (coldHeated) { passCount++; test26Passed.push('T-cold-rise'); } else { failCount++; test26Failed.push('T-cold-rise'); }
    
    // Check 3: 1st Law â€” total enthalpy in = total enthalpy out
    const H_total_in = H_hot_in + H_cold_in;
    const H_total_out = H_hot_out + H_cold_out;
    const balErr = Math.abs(H_total_out - H_total_in);
    const balTol = Math.max(Math.abs(H_total_in) * 5e-3, 10);
    results.push(checkTolerance(balErr, 0, balTol, '1st Law [J/s]', test26Passed, test26Failed));
    
    // Check 4: Duty Q > 0
    const Q_hex = hexUD.last?.Q;  // kW
    const qPositive = Q_hex > 0;
    results.push({ name: 'Q > 0', calc: Q_hex?.toFixed(1) + ' kW', ref: '>0', delta: qPositive ? 'yes' : 'NO', tol: 'check', status: qPositive ? 'âœ“' : 'âœ—', pass: qPositive });
    if (qPositive) { passCount++; test26Passed.push('Q-positive'); } else { failCount++; test26Failed.push('Q-positive'); }
    
    // Check 5: Q hot = Q cold (energy exchanged)
    const Q_hot = (H_hot_in - H_hot_out) / 1000;
    const Q_cold = (H_cold_out - H_cold_in) / 1000;
    results.push(checkTolerance(Q_hot, Q_cold, Math.max(Math.abs(Q_hot) * 5e-3, 0.1), 'Q_hotâ‰ˆQ_cold [kW]', test26Passed, test26Failed));
    
    console.log(`  T_hot_out: ${hotOut.T.toFixed(2)}K, T_cold_out: ${coldOut.T.toFixed(2)}K, Q: ${Q_hex?.toFixed(2)} kW`);
    console.log(`  H_in: ${(H_total_in/1000).toFixed(2)} kW, H_out: ${(H_total_out/1000).toFixed(2)} kW`);
    
    printResultsTable(results, null);
    recordTestResult(test26Name, test26Passed, test26Failed, 26);
    
  } catch (err) {
    recordTestError(test26Name, err.message, 5, 26);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 27: Electric Heater Demand Chain
  // =================================================================
  testCount++;
  const test27Name = 'ElecHeater: Demand Propagation';
  console.log(`\nTest ${testCount}: ${test27Name}`);
  console.log(`  Topology: ElecSource(100kW) â†’ ElecHeater(Î·=0.99) â†’ Heater(T_out=200Â°C) â† Source(N2,27Â°C)`);
  console.log(`  Scenario: Heater computes Q~50kW â†’ demand propagates backward â†’ source not saturated`);
  
  try {
    clearScene();
    const test27Passed = [];
    const test27Failed = [];
    const results = [];
    
    const elSrcId = scene.placeUnit('battery', 0, 0);
    const ehId = scene.placeUnit('electric_heater', 3, 0);
    const srcId = scene.placeUnit('source', 0, 3);
    const htrId = scene.placeUnit('heater', 6, 1);
    const snkId = scene.placeUnit('sink', 10, 1);
    
    scene.units.get(elSrcId).params = { maxPower: 100 };
    scene.units.get(ehId).params = { eta: 0.99 };
    scene.units.get(htrId).params = { T_out: 200 };  // 473K setpoint â€” demands ~50 kW
    scene.units.get(srcId).params = { species: 'N2', nDot: 10, T: 27, P: 200000, phaseConstraint: 'V' };
    
    scene.connections.push({ id: 'c1', from: { unitId: elSrcId, portId: 'out' }, to: { unitId: ehId, portId: 'elec_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: ehId, portId: 'heat_out' }, to: { unitId: htrId, portId: 'heat_in' } });
    scene.connections.push({ id: 'c3', from: { unitId: srcId, portId: 'out' }, to: { unitId: htrId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c4', from: { unitId: htrId, portId: 'mat_out' }, to: { unitId: snkId, portId: 'in' } });
    
    solveScene(scene);
    
    const ehUD = scene.runtime.unitData.get(ehId);
    const htrUD = scene.runtime.unitData.get(htrId);
    const outS = htrUD?.ports?.mat_out;
    if (!outS) throw new Error('No heater outlet');
    
    // All internal values are now in W (P0.2) â€” convert to kW for test comparison
    const Q_demand = (htrUD?.last?.Q_demand_W || 0) / 1000;  // Wâ†’kW
    const Q_actual = (htrUD?.last?.Q_actual_W || 0) / 1000;  // Wâ†’kW
    
    // Check 1: T_out matches setpoint (supply is sufficient, so setpoint = actual)
    results.push(checkTolerance(outS.T, 473.15, 1.0, 'T_out [K]', test27Passed, test27Failed));
    
    // Check 2: Q_demand â‰ˆ Q_actual (no supply limitation)
    results.push(checkTolerance(Q_actual, Q_demand, 0.1, 'Q_actual=Q_demand', test27Passed, test27Failed));
    
    // Check 3: EH Q_heat = heater demand (from demand propagation)
    const ehQ = (ehUD?.last?.Q_heat_demand_W || 0) / 1000;  // Wâ†’kW
    results.push(checkTolerance(ehQ, Q_actual, 0.1, 'EH Q [kW]', test27Passed, test27Failed));
    
    // Check 4: EH electrical demand = Q/Î·
    const ehDemand = (ehUD?.powerDemand || 0) / 1000;  // Wâ†’kW
    results.push(checkTolerance(ehDemand, Q_actual / 0.99, 0.2, 'EH elec demand [kW]', test27Passed, test27Failed));
    
    // Check 5: Enthalpy balance
    const H_in = thermo.getHdot_Jps({ type: StreamType.MATERIAL, T: 300, P: 200000, n: { N2: 10 } });
    const H_out = thermo.getHdot_Jps(outS);
    const Q_check = (H_out - H_in) / 1000;  // J/s â†’ kW
    results.push(checkTolerance(Q_check, Q_actual, 1.0, 'H balance [kW]', test27Passed, test27Failed));
    
    console.log(`  Q_demand: ${Q_demand.toFixed(2)} kW, Q_actual: ${Q_actual.toFixed(2)} kW`);
    console.log(`  EH Q: ${ehQ.toFixed(2)} kW, EH elec demand: ${ehDemand.toFixed(2)} kW`);
    
    printResultsTable(results, null);
    recordTestResult(test27Name, test27Passed, test27Failed, 27);
    
  } catch (err) {
    recordTestError(test27Name, err.message, 5, 27);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 28: Motor + Compressor Demand Chain (H2O Reference Case)
  // =================================================================
  testCount++;
  const test28Name = 'Motor+Compressor Demand';
  console.log(`\nTest ${testCount}: ${test28Name}`);
  console.log(`  Topology: Source(H2O,125Â°C,1bar,1mol/s,VL) â†’ Compressor(5bar,Î·=0.75) â†’ Sink`);
  console.log(`            ElecSource(100kW) â†’ Motor(Î·=0.92) â†’ Compressor.power_in`);
  console.log(`  Scenario: Demand propagates Compâ†’Motorâ†’Source, ~8.7kW shaft, ~9.5kW elec`);
  
  try {
    clearScene();
    const test28Passed = [];
    const test28Failed = [];
    const results = [];
    
    const srcH2O = scene.placeUnit('source', 0, 3);
    const compId = scene.placeUnit('compressor', 4, 3);
    const snkId = scene.placeUnit('sink', 8, 3);
    const elSrcId = scene.placeUnit('battery', 0, 0);
    const motorId = scene.placeUnit('motor', 3, 0);
    
    scene.units.get(srcH2O).params = { species: 'H2O', nDot: 1, T: 125, P: 100000, phaseConstraint: 'VL' };  // 398.15K, 1bar
    scene.units.get(compId).params = { Pout: 500000, eta: 0.75 };  // 5bar
    scene.units.get(elSrcId).params = { maxPower: 100 };
    scene.units.get(motorId).params = { eta: 0.92 };
    
    // Material: source â†’ compressor â†’ sink
    scene.connections.push({ id: 'c1', from: { unitId: srcH2O, portId: 'out' }, to: { unitId: compId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: compId, portId: 'mat_out' }, to: { unitId: snkId, portId: 'in' } });
    // Power: elec_source â†’ motor â†’ compressor
    scene.connections.push({ id: 'c3', from: { unitId: elSrcId, portId: 'out' }, to: { unitId: motorId, portId: 'elec_in' } });
    scene.connections.push({ id: 'c4', from: { unitId: motorId, portId: 'mech_out' }, to: { unitId: compId, portId: 'power_in' } });
    
    solveScene(scene);
    
    const compUD = scene.runtime.unitData.get(compId);
    const motorUD = scene.runtime.unitData.get(motorId);
    const compUnit = scene.units.get(compId);
    
    // All internal values now in W (P0.2) â€” convert to kW for readable comparison
    const W_shaft = (compUnit.powerDemand || 0) / 1000;
    const W_motor = (motorUD?.powerDemand || 0) / 1000;
    
    console.log(`  W_shaft: ${W_shaft.toFixed(2)} kW, Motor demand: ${W_motor.toFixed(2)} kW`);
    
    // Check 1: W_shaft in plausible range for H2O 1barâ†’5bar (expect ~8.5â€“9 kW)
    const shaftInRange = W_shaft > 6 && W_shaft < 12;
    results.push({ name: 'W_shaft range', calc: W_shaft.toFixed(2) + ' kW', ref: '6â€“12 kW', delta: shaftInRange ? 'yes' : 'NO', tol: 'range', status: shaftInRange ? 'âœ“' : 'âœ—', pass: shaftInRange });
    if (shaftInRange) { passCount++; test28Passed.push('W-range'); } else { failCount++; test28Failed.push('W-range'); }
    
    // Check 2: Motor demand = W_shaft / Î·_motor (exact relationship)
    const motorRatio = W_motor / W_shaft;
    results.push(checkTolerance(motorRatio, 1 / 0.92, 0.01, 'Motor ratio W_elec/W_mech', test28Passed, test28Failed));
    
    // Check 3: Compressor outlet T > inlet T (compression heats gas)
    const compOut = compUD?.ports?.mat_out;
    const compHeated = compOut && compOut.T > 398;
    results.push({ name: 'T_out > T_in', calc: compOut?.T?.toFixed(1), ref: '>398K', delta: compHeated ? 'yes' : 'NO', tol: 'check', status: compHeated ? 'âœ“' : 'âœ—', pass: compHeated });
    if (compHeated) { passCount++; test28Passed.push('T-rise'); } else { failCount++; test28Failed.push('T-rise'); }
    
    printResultsTable(results, null);
    recordTestResult(test28Name, test28Passed, test28Failed, 28);
    
  } catch (err) {
    recordTestError(test28Name, err.message, 3, 28);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 29: Converter Without Electrical Input = No Output
  // =================================================================
  testCount++;
  const test29Name = 'Converters Need Elec Input';
  console.log(`\nTest ${testCount}: ${test29Name}`);
  console.log(`  Scenario: Motor and ElecHeater with no electrical source connected`);
  console.log(`  Rule: Converters must not produce output without power input`);
  
  try {
    clearScene();
    const test29Passed = [];
    const test29Failed = [];
    const results = [];
    
    // Case A: Motor without electrical source
    const motorId = scene.placeUnit('motor', 0, 0);
    
    // Case B: Electric heater without electrical source
    const ehId = scene.placeUnit('electric_heater', 0, 4);
    
    solveScene(scene);
    
    const motorUD = scene.runtime.unitData.get(motorId);
    const ehUD = scene.runtime.unitData.get(ehId);
    
    // Check 1: Motor has no mech_out
    const motorNoOutput = !motorUD?.ports?.mech_out;
    results.push({ name: 'Motor: no output', calc: motorNoOutput ? 'none' : 'HAS OUTPUT', ref: 'none', delta: motorNoOutput ? 'match' : 'FAIL', tol: 'exact', status: motorNoOutput ? 'âœ“' : 'âœ—', pass: motorNoOutput });
    if (motorNoOutput) { passCount++; test29Passed.push('motor-no-out'); } else { failCount++; test29Failed.push('motor-no-out'); }
    
    // Check 2: Electric heater has no heat_out
    const ehNoOutput = !ehUD?.ports?.heat_out;
    results.push({ name: 'ElecHeater: no output', calc: ehNoOutput ? 'none' : 'HAS OUTPUT', ref: 'none', delta: ehNoOutput ? 'match' : 'FAIL', tol: 'exact', status: ehNoOutput ? 'âœ“' : 'âœ—', pass: ehNoOutput });
    if (ehNoOutput) { passCount++; test29Passed.push('eh-no-out'); } else { failCount++; test29Failed.push('eh-no-out'); }
    
    // Check 3: Motor powerDemand = 0
    results.push(checkTolerance(motorUD?.powerDemand || 0, 0, 1e-10, 'Motor demand=0', test29Passed, test29Failed));
    
    // Check 4: Electric heater powerDemand = 0
    results.push(checkTolerance(ehUD?.powerDemand || 0, 0, 1e-10, 'EH demand=0', test29Passed, test29Failed));
    
    printResultsTable(results, null);
    recordTestResult(test29Name, test29Passed, test29Failed, 29);
    
  } catch (err) {
    recordTestError(test29Name, err.message, 4, 29);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 30: Heater Insufficient Heat Supply Warning
  // =================================================================
  testCount++;
  const test30Name = 'Heater: Supply Limited';
  console.log(`\nTest ${testCount}: ${test30Name}`);
  console.log(`  Topology: ElecSource(10kW) â†’ ElecHeater(Î·=0.99) â†’ Heater(T_out=200Â°C) â† Source(N2,27Â°C)`);
  console.log(`  Scenario: 9.9kW available << ~50kW needed â†’ T_actual << T_setpoint`);
  
  try {
    clearScene();
    const test30Passed = [];
    const test30Failed = [];
    const results = [];
    
    const elSrcId = scene.placeUnit('battery', 0, 0);
    const ehId = scene.placeUnit('electric_heater', 3, 0);
    const srcId = scene.placeUnit('source', 0, 3);
    const htrId = scene.placeUnit('heater', 6, 1);
    const snkId = scene.placeUnit('sink', 10, 1);
    
    scene.units.get(elSrcId).params = { maxPower: 10 };  // Only 10 kW!
    scene.units.get(ehId).params = { eta: 0.99 };
    scene.units.get(htrId).params = { T_out: 200 };  // 473K setpoint â€” demands ~50kW
    scene.units.get(srcId).params = { species: 'N2', nDot: 10, T: 27, P: 200000, phaseConstraint: 'V' };
    
    scene.connections.push({ id: 'c1', from: { unitId: elSrcId, portId: 'out' }, to: { unitId: ehId, portId: 'elec_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: ehId, portId: 'heat_out' }, to: { unitId: htrId, portId: 'heat_in' } });
    scene.connections.push({ id: 'c3', from: { unitId: srcId, portId: 'out' }, to: { unitId: htrId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c4', from: { unitId: htrId, portId: 'mat_out' }, to: { unitId: snkId, portId: 'in' } });
    
    solveScene(scene);
    
    const htrUD = scene.runtime.unitData.get(htrId);
    const outS = htrUD?.ports?.mat_out;
    
    // Check 1: Output stream produced (heater doesn't abort)
    const hasOutput = !!outS;
    results.push({ name: 'Output produced', calc: hasOutput ? 'yes' : 'NO', ref: 'yes', delta: hasOutput ? 'match' : 'FAIL', tol: 'exact', status: hasOutput ? 'âœ“' : 'âœ—', pass: hasOutput });
    if (hasOutput) { passCount++; test30Passed.push('output'); } else { failCount++; test30Failed.push('output'); }
    
    // Check 2: Supply-limited flag set
    const isLimited = htrUD?.last?.supplyLimited === true;
    results.push({ name: 'Supply limited', calc: isLimited ? 'yes' : 'no', ref: 'yes', delta: isLimited ? 'match' : 'FAIL', tol: 'exact', status: isLimited ? 'âœ“' : 'âœ—', pass: isLimited });
    if (isLimited) { passCount++; test30Passed.push('limited'); } else { failCount++; test30Failed.push('limited'); }
    
    // Check 3: Q_actual << Q_demand (supply limited to ~9.9 kW vs ~50 kW)
    const Q_actual = (htrUD?.last?.Q_actual_W || 0) / 1000;  // Wâ†’kW
    const Q_demand = (htrUD?.last?.Q_demand_W || 0) / 1000;  // Wâ†’kW
    const actualLimited = Q_actual < Q_demand * 0.5;
    results.push({ name: 'Q_actual << Q_demand', calc: `${Q_actual.toFixed(1)} vs ${Q_demand.toFixed(1)}`, ref: 'Q_a < Q_d/2', delta: actualLimited ? 'yes' : 'NO', tol: 'check', status: actualLimited ? 'âœ“' : 'âœ—', pass: actualLimited });
    if (actualLimited) { passCount++; test30Passed.push('Q-limited'); } else { failCount++; test30Failed.push('Q-limited'); }
    
    // Check 4: T_actual < T_setpoint (heater couldn't reach setpoint)
    const T_actual = outS ? outS.T : 0;
    const T_below = T_actual < 473 - 10;  // Well below 200Â°C setpoint
    results.push({ name: 'T_actual < T_set', calc: (T_actual-273.15).toFixed(1) + 'Â°C', ref: '<<200Â°C', delta: T_below ? 'yes' : 'NO', tol: 'check', status: T_below ? 'âœ“' : 'âœ—', pass: T_below });
    if (T_below) { passCount++; test30Passed.push('T-below'); } else { failCount++; test30Failed.push('T-below'); }
    
    console.log(`  Q_demand: ${Q_demand.toFixed(1)} kW, Q_actual: ${Q_actual.toFixed(1)} kW (limited by ${(10*0.99).toFixed(1)} kW supply)`);
    console.log(`  T_setpoint: 200Â°C, T_actual: ${outS ? (outS.T-273.15).toFixed(1) : 'N/A'}Â°C`);
    if (htrUD?.last?.error) console.log(`  Warning: ${htrUD.last.error.message}`);
    
    printResultsTable(results, null);
    recordTestResult(test30Name, test30Passed, test30Failed, 30);
    
  } catch (err) {
    recordTestError(test30Name, err.message, 4, 30);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 31: LV Separator â€” H2O Valve Flash (Single Component)
  // =================================================================
  testCount++;
  const test31Name = 'LV-Sep: H2O Valve Flash';
  console.log(`\nTest ${testCount}: ${test31Name}`);
  console.log(`  Topology: Source(H2O,150Â°C,5bar,L) â†’ Valve(1bar) â†’ Separator â†’ Sink_V + Sink_L`);
  console.log(`  Scenario: Isenthalpic flash produces VL â€” separator splits phases`);
  
  try {
    clearScene();
    const test31Passed = [];
    const test31Failed = [];
    const results = [];
    
    const srcId = scene.placeUnit('source', 0, 1);
    const vlvId = scene.placeUnit('valve', 3, 1);
    const sepId = scene.placeUnit('flash_drum', 6, 0);
    const snkV = scene.placeUnit('sink', 10, 0);
    const snkL = scene.placeUnit('sink', 10, 3);
    
    // H2O at 150Â°C, 5 bar, liquid (Psat at 150Â°C â‰ˆ 4.76 bar, so P>Psat â†’ liquid)
    scene.units.get(srcId).params = { species: 'H2O', nDot: 1, T: 150, P: 500000, phaseConstraint: 'L' };
    scene.units.get(vlvId).params = { Pout: 100000 };  // Flash to 1 bar
    
    scene.connections.push({ id: 'c1', from: { unitId: srcId, portId: 'out' }, to: { unitId: vlvId, portId: 'in' } });
    scene.connections.push({ id: 'c2', from: { unitId: vlvId, portId: 'out' }, to: { unitId: sepId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c3', from: { unitId: sepId, portId: 'vap_out' }, to: { unitId: snkV, portId: 'in' } });
    scene.connections.push({ id: 'c4', from: { unitId: sepId, portId: 'liq_out' }, to: { unitId: snkL, portId: 'in' } });
    
    solveScene(scene);
    
    const sepUD = scene.runtime.unitData.get(sepId);
    const vapS = sepUD?.ports?.vap_out;
    const liqS = sepUD?.ports?.liq_out;
    const valveUD = scene.runtime.unitData.get(vlvId);
    const valveOut = valveUD?.ports?.out;
    
    if (!vapS || !liqS) throw new Error('Missing separator outlets');
    
    // Check 1: Inlet is two-phase
    const phaseVL = sepUD?.last?.phase === 'VL';
    results.push({ name: 'Inlet VL', calc: sepUD?.last?.phase, ref: 'VL', delta: phaseVL ? 'match' : 'FAIL', tol: 'exact', status: phaseVL ? 'âœ“' : 'âœ—', pass: phaseVL });
    if (phaseVL) { passCount++; test31Passed.push('VL'); } else { failCount++; test31Failed.push('VL'); }
    
    // Check 2: beta between 0 and 1 (partial vaporization)
    const beta = sepUD?.last?.beta;
    const betaOK = beta !== null && beta > 0.01 && beta < 0.99;
    results.push({ name: 'beta âˆˆ (0,1)', calc: beta?.toFixed(4), ref: '(0,1)', delta: betaOK ? 'yes' : 'NO', tol: 'range', status: betaOK ? 'âœ“' : 'âœ—', pass: betaOK });
    if (betaOK) { passCount++; test31Passed.push('beta'); } else { failCount++; test31Failed.push('beta'); }
    
    // Check 3: Mass balance (nV + nL = 1 mol/s)
    const nV_H2O = vapS.n?.H2O || 0;
    const nL_H2O = liqS.n?.H2O || 0;
    results.push(checkTolerance(nV_H2O + nL_H2O, 1.0, 1e-6, 'Mass balance [mol/s]', test31Passed, test31Failed));
    
    // Check 4: Both outlets at ~100Â°C (Tsat of H2O at 1 bar)
    const Tsat_H2O = 373.15;  // 100Â°C at 1 bar
    results.push(checkTolerance(vapS.T, Tsat_H2O, 2.0, 'T_vap [K]', test31Passed, test31Failed));
    results.push(checkTolerance(liqS.T, Tsat_H2O, 2.0, 'T_liq [K]', test31Passed, test31Failed));
    
    // Check 5: Vapor outlet is pure vapor, liquid is pure liquid
    const vapPhase = vapS.phase === 'V';
    const liqPhase = liqS.phase === 'L';
    results.push({ name: 'Vap phase=V', calc: vapS.phase, ref: 'V', delta: vapPhase ? 'match' : 'FAIL', tol: 'exact', status: vapPhase ? 'âœ“' : 'âœ—', pass: vapPhase });
    if (vapPhase) { passCount++; test31Passed.push('V-phase'); } else { failCount++; test31Failed.push('V-phase'); }
    results.push({ name: 'Liq phase=L', calc: liqS.phase, ref: 'L', delta: liqPhase ? 'match' : 'FAIL', tol: 'exact', status: liqPhase ? 'âœ“' : 'âœ—', pass: liqPhase });
    if (liqPhase) { passCount++; test31Passed.push('L-phase'); } else { failCount++; test31Failed.push('L-phase'); }
    
    // Check 6: Energy balance (H_valve_out â‰ˆ H_vap + H_liq)
    const H_valve = thermo.getHdot_Jps(valveOut);
    const H_vap = thermo.getHdot_Jps(vapS);
    const H_liq = thermo.getHdot_Jps(liqS);
    const H_err_pct = Math.abs((H_vap + H_liq - H_valve) / H_valve) * 100;
    results.push(checkTolerance(H_err_pct, 0, 0.5, 'H balance error [%]', test31Passed, test31Failed));
    
    console.log(`  Î²=${beta?.toFixed(4)}, nV=${nV_H2O.toFixed(4)}, nL=${nL_H2O.toFixed(4)}`);
    console.log(`  T_vap=${vapS.T?.toFixed(1)}K, T_liq=${liqS.T?.toFixed(1)}K`);
    console.log(`  H_in=${(H_valve/1000).toFixed(2)} kW, H_V+H_L=${((H_vap+H_liq)/1000).toFixed(2)} kW`);
    
    printResultsTable(results, null);
    recordTestResult(test31Name, test31Passed, test31Failed, 31);
    
  } catch (err) {
    recordTestError(test31Name, err.message, 8, 31);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 32: LV Separator â€” N2/O2 Air Separation (Rachford-Rice)
  // =================================================================
  testCount++;
  const test32Name = 'LV-Sep: N2/O2 Multicomponent';
  console.log(`\nTest ${testCount}: ${test32Name}`);
  console.log(`  Topology: Source_N2(V) + Source_O2(L) â†’ Mixer â†’ Separator â†’ Sink_V + Sink_L`);
  console.log(`  Scenario: 79% N2(V) + 21% O2(L) at 80K, 1 bar â€” Rachford-Rice VLE`);
  
  try {
    clearScene();
    const test32Passed = [];
    const test32Failed = [];
    const results = [];
    
    const srcN2 = scene.placeUnit('source', 0, 0);
    const srcO2 = scene.placeUnit('source', 0, 3);
    const mixId = scene.placeUnit('mixer', 4, 1);
    const sepId = scene.placeUnit('flash_drum', 8, 0);
    const snkV = scene.placeUnit('sink', 12, 0);
    const snkL = scene.placeUnit('sink', 12, 3);
    
    // Air at 80K, 1 bar: N2 as vapor (Tb=77K, above Tb), O2 as liquid (Tb=90K, below Tb)
    scene.units.get(srcN2).params = { species: 'N2', nDot: 0.79, T: -193.15, P: 100000, phaseConstraint: 'V' };
    scene.units.get(srcO2).params = { species: 'O2', nDot: 0.21, T: -193.15, P: 100000, phaseConstraint: 'L' };
    
    scene.connections.push({ id: 'c1', from: { unitId: srcN2, portId: 'out' }, to: { unitId: mixId, portId: 'in1' } });
    scene.connections.push({ id: 'c2', from: { unitId: srcO2, portId: 'out' }, to: { unitId: mixId, portId: 'in2' } });
    scene.connections.push({ id: 'c3', from: { unitId: mixId, portId: 'out' }, to: { unitId: sepId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c4', from: { unitId: sepId, portId: 'vap_out' }, to: { unitId: snkV, portId: 'in' } });
    scene.connections.push({ id: 'c5', from: { unitId: sepId, portId: 'liq_out' }, to: { unitId: snkL, portId: 'in' } });
    
    solveScene(scene);
    
    const sepUD = scene.runtime.unitData.get(sepId);
    const vapS = sepUD?.ports?.vap_out;
    const liqS = sepUD?.ports?.liq_out;
    
    if (!vapS || !liqS) throw new Error('Missing separator outlets');
    
    const nV_N2 = vapS.n?.N2 || 0;
    const nV_O2 = vapS.n?.O2 || 0;
    const nL_N2 = liqS.n?.N2 || 0;
    const nL_O2 = liqS.n?.O2 || 0;
    
    // Check 1: Two-phase inlet
    const phaseVL = sepUD?.last?.phase === 'VL';
    results.push({ name: 'Inlet VL', calc: sepUD?.last?.phase, ref: 'VL', delta: phaseVL ? 'match' : 'FAIL', tol: 'exact', status: phaseVL ? 'âœ“' : 'âœ—', pass: phaseVL });
    if (phaseVL) { passCount++; test32Passed.push('VL'); } else { failCount++; test32Failed.push('VL'); }
    
    // Check 2: N2 mass balance (nV_N2 + nL_N2 = 0.79)
    results.push(checkTolerance(nV_N2 + nL_N2, 0.79, 1e-4, 'N2 balance [mol/s]', test32Passed, test32Failed));
    
    // Check 3: O2 mass balance (nV_O2 + nL_O2 = 0.21)
    results.push(checkTolerance(nV_O2 + nL_O2, 0.21, 1e-4, 'O2 balance [mol/s]', test32Passed, test32Failed));
    
    // Check 4: Vapor enriched in N2 (y_N2 > z_N2 = 0.79)
    const nV_total = nV_N2 + nV_O2;
    const y_N2 = nV_total > 0 ? nV_N2 / nV_total : 0;
    const vapEnriched = y_N2 > 0.79;
    results.push({ name: 'Vap enrich N2', calc: (y_N2*100).toFixed(1)+'%', ref: '>79%', delta: vapEnriched ? 'yes' : 'NO', tol: 'check', status: vapEnriched ? 'âœ“' : 'âœ—', pass: vapEnriched });
    if (vapEnriched) { passCount++; test32Passed.push('vap-N2'); } else { failCount++; test32Failed.push('vap-N2'); }
    
    // Check 5: Liquid enriched in O2 (x_O2 > z_O2 = 0.21)
    const nL_total = nL_N2 + nL_O2;
    const x_O2 = nL_total > 0 ? nL_O2 / nL_total : 0;
    const liqEnriched = x_O2 > 0.21;
    results.push({ name: 'Liq enrich O2', calc: (x_O2*100).toFixed(1)+'%', ref: '>21%', delta: liqEnriched ? 'yes' : 'NO', tol: 'check', status: liqEnriched ? 'âœ“' : 'âœ—', pass: liqEnriched });
    if (liqEnriched) { passCount++; test32Passed.push('liq-O2'); } else { failCount++; test32Failed.push('liq-O2'); }
    
    // Check 6: beta consistent with diagnostics
    const beta = sepUD?.last?.beta;
    const betaFromFlow = nV_total / (nV_total + nL_total);
    results.push(checkTolerance(beta || 0, betaFromFlow, 0.01, 'beta consistency', test32Passed, test32Failed));
    
    // Check 7: Both outlets have flow
    const bothFlow = nV_total > 0.01 && nL_total > 0.01;
    results.push({ name: 'Both outlets flow', calc: bothFlow ? 'yes' : 'NO', ref: 'yes', delta: bothFlow ? 'match' : 'FAIL', tol: 'check', status: bothFlow ? 'âœ“' : 'âœ—', pass: bothFlow });
    if (bothFlow) { passCount++; test32Passed.push('both-flow'); } else { failCount++; test32Failed.push('both-flow'); }
    
    console.log(`  Î²=${beta?.toFixed(4)}, V: ${nV_total.toFixed(3)} mol/s (y_N2=${(y_N2*100).toFixed(1)}%), L: ${nL_total.toFixed(3)} mol/s (x_O2=${(x_O2*100).toFixed(1)}%)`);
    
    printResultsTable(results, null);
    recordTestResult(test32Name, test32Passed, test32Failed, 32);
    
  } catch (err) {
    recordTestError(test32Name, err.message, 7, 32);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 33: LV Separator â€” Edge Cases (All V / All L)
  // =================================================================
  testCount++;
  const test33Name = 'LV-Sep: Edge Cases';
  console.log(`\nTest ${testCount}: ${test33Name}`);
  console.log(`  Scenario A: N2 at 300K, 1bar â†’ Separator (all vapor)`);
  console.log(`  Scenario B: H2O at 25Â°C, 1bar â†’ Separator (all liquid)`);
  
  try {
    clearScene();
    const test33Passed = [];
    const test33Failed = [];
    const results = [];
    
    // â”€â”€ Scenario A: All vapor (N2 at 300K) â”€â”€
    const srcA = scene.placeUnit('source', 0, 0);
    const sepA = scene.placeUnit('flash_drum', 4, 0);
    const snkVA = scene.placeUnit('sink', 8, 0);
    const snkLA = scene.placeUnit('sink', 8, 3);
    
    scene.units.get(srcA).params = { species: 'N2', nDot: 5, T: 27, P: 100000, phaseConstraint: 'V' };
    
    scene.connections.push({ id: 'a1', from: { unitId: srcA, portId: 'out' }, to: { unitId: sepA, portId: 'mat_in' } });
    scene.connections.push({ id: 'a2', from: { unitId: sepA, portId: 'vap_out' }, to: { unitId: snkVA, portId: 'in' } });
    scene.connections.push({ id: 'a3', from: { unitId: sepA, portId: 'liq_out' }, to: { unitId: snkLA, portId: 'in' } });
    
    // â”€â”€ Scenario B: All liquid (H2O at 25Â°C) â”€â”€
    const srcB = scene.placeUnit('source', 0, 6);
    const sepB = scene.placeUnit('flash_drum', 4, 6);
    const snkVB = scene.placeUnit('sink', 8, 6);
    const snkLB = scene.placeUnit('sink', 8, 9);
    
    scene.units.get(srcB).params = { species: 'H2O', nDot: 3, T: 25, P: 100000, phaseConstraint: 'L' };
    
    scene.connections.push({ id: 'b1', from: { unitId: srcB, portId: 'out' }, to: { unitId: sepB, portId: 'mat_in' } });
    scene.connections.push({ id: 'b2', from: { unitId: sepB, portId: 'vap_out' }, to: { unitId: snkVB, portId: 'in' } });
    scene.connections.push({ id: 'b3', from: { unitId: sepB, portId: 'liq_out' }, to: { unitId: snkLB, portId: 'in' } });
    
    solveScene(scene);
    
    const sepAUD = scene.runtime.unitData.get(sepA);
    const vapA = sepAUD?.ports?.vap_out;
    const liqA = sepAUD?.ports?.liq_out;
    
    const sepBUD = scene.runtime.unitData.get(sepB);
    const vapB = sepBUD?.ports?.vap_out;
    const liqB = sepBUD?.ports?.liq_out;
    
    // Check A1: All N2 in vapor outlet
    const nV_A = Object.values(vapA?.n || {}).reduce((a,b) => a+b, 0);
    results.push(checkTolerance(nV_A, 5.0, 1e-6, 'A: Vap flow [mol/s]', test33Passed, test33Failed));
    
    // Check A2: Liquid outlet empty
    const nL_A = Object.values(liqA?.n || {}).reduce((a,b) => a+b, 0);
    const liqEmpty = nL_A < 1e-10;
    results.push({ name: 'A: Liq empty', calc: nL_A.toFixed(6), ref: 'â‰ˆ0', delta: liqEmpty ? 'match' : 'FAIL', tol: 'exact', status: liqEmpty ? 'âœ“' : 'âœ—', pass: liqEmpty });
    if (liqEmpty) { passCount++; test33Passed.push('A-liq-empty'); } else { failCount++; test33Failed.push('A-liq-empty'); }
    
    // Check A3: Phase diagnostics
    const phaseA = sepAUD?.last?.phase === 'V';
    results.push({ name: 'A: phase=V', calc: sepAUD?.last?.phase, ref: 'V', delta: phaseA ? 'match' : 'FAIL', tol: 'exact', status: phaseA ? 'âœ“' : 'âœ—', pass: phaseA });
    if (phaseA) { passCount++; test33Passed.push('A-V'); } else { failCount++; test33Failed.push('A-V'); }
    
    // Check B1: All H2O in liquid outlet
    const nL_B = Object.values(liqB?.n || {}).reduce((a,b) => a+b, 0);
    results.push(checkTolerance(nL_B, 3.0, 1e-6, 'B: Liq flow [mol/s]', test33Passed, test33Failed));
    
    // Check B2: Vapor outlet empty
    const nV_B = Object.values(vapB?.n || {}).reduce((a,b) => a+b, 0);
    const vapEmpty = nV_B < 1e-10;
    results.push({ name: 'B: Vap empty', calc: nV_B.toFixed(6), ref: 'â‰ˆ0', delta: vapEmpty ? 'match' : 'FAIL', tol: 'exact', status: vapEmpty ? 'âœ“' : 'âœ—', pass: vapEmpty });
    if (vapEmpty) { passCount++; test33Passed.push('B-vap-empty'); } else { failCount++; test33Failed.push('B-vap-empty'); }
    
    // Check B3: Phase diagnostics
    const phaseB = sepBUD?.last?.phase === 'L';
    results.push({ name: 'B: phase=L', calc: sepBUD?.last?.phase, ref: 'L', delta: phaseB ? 'match' : 'FAIL', tol: 'exact', status: phaseB ? 'âœ“' : 'âœ—', pass: phaseB });
    if (phaseB) { passCount++; test33Passed.push('B-L'); } else { failCount++; test33Failed.push('B-L'); }
    
    console.log(`  A (N2 300K): V=${nV_A.toFixed(3)}, L=${nL_A.toFixed(6)} â†’ all vapor âœ“`);
    console.log(`  B (H2O 25Â°C): V=${nV_B.toFixed(6)}, L=${nL_B.toFixed(3)} â†’ all liquid âœ“`);
    
    printResultsTable(results, null);
    recordTestResult(test33Name, test33Passed, test33Failed, 33);
    
  } catch (err) {
    recordTestError(test33Name, err.message, 6, 33);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 34: Flash Drum â€” H2O/CO2 Binary VLE (Practical Conditions)
  // =================================================================
  testCount++;
  const test34Name = 'Flash Drum: H2O/CO2 VLE';
  console.log(`\nTest ${testCount}: ${test34Name}`);
  console.log(`  Topology: Source(H2O,25Â°C,5bar,L) + Source(CO2,25Â°C,5bar,V) â†’ Mixer â†’ FlashDrum â†’ V + L`);
  console.log(`  Scenario: CO2 mostly vapor, H2O mostly liquid â€” practical CO2 separation`);
  
  try {
    clearScene();
    const test34Passed = [];
    const test34Failed = [];
    const results = [];
    
    const srcH2O = scene.placeUnit('source', 0, 0);
    const srcCO2 = scene.placeUnit('source', 0, 3);
    const mixId = scene.placeUnit('mixer', 4, 1);
    const sepId = scene.placeUnit('flash_drum', 8, 0);
    const snkV = scene.placeUnit('sink', 12, 0);
    const snkL = scene.placeUnit('sink', 12, 3);
    
    scene.units.get(srcH2O).params = { species: 'H2O', nDot: 5, T: 25, P: 500000, phaseConstraint: 'L' };
    scene.units.get(srcCO2).params = { species: 'CO2', nDot: 5, T: 25, P: 500000, phaseConstraint: 'V' };
    
    scene.connections.push({ id: 'c1', from: { unitId: srcH2O, portId: 'out' }, to: { unitId: mixId, portId: 'in1' } });
    scene.connections.push({ id: 'c2', from: { unitId: srcCO2, portId: 'out' }, to: { unitId: mixId, portId: 'in2' } });
    scene.connections.push({ id: 'c3', from: { unitId: mixId, portId: 'out' }, to: { unitId: sepId, portId: 'mat_in' } });
    scene.connections.push({ id: 'c4', from: { unitId: sepId, portId: 'vap_out' }, to: { unitId: snkV, portId: 'in' } });
    scene.connections.push({ id: 'c5', from: { unitId: sepId, portId: 'liq_out' }, to: { unitId: snkL, portId: 'in' } });
    
    solveScene(scene);
    
    const sepUD = scene.runtime.unitData.get(sepId);
    const mixUD = scene.runtime.unitData.get(mixId);
    const vapS = sepUD?.ports?.vap_out;
    const liqS = sepUD?.ports?.liq_out;
    const feedS = mixUD?.ports?.out;
    
    if (!vapS || !liqS) throw new Error('Missing flash drum outlets');
    
    const nV_H2O = vapS.n?.H2O || 0;
    const nV_CO2 = vapS.n?.CO2 || 0;
    const nL_H2O = liqS.n?.H2O || 0;
    const nL_CO2 = liqS.n?.CO2 || 0;
    
    // Check 1: H2O mass balance
    results.push(checkTolerance(nV_H2O + nL_H2O, 5.0, 1e-4, 'H2O balance [mol/s]', test34Passed, test34Failed));
    
    // Check 2: CO2 mass balance
    results.push(checkTolerance(nV_CO2 + nL_CO2, 5.0, 1e-4, 'CO2 balance [mol/s]', test34Passed, test34Failed));
    
    // Check 3: CO2 enriched in vapor (y_CO2 > z_CO2 = 0.5)
    const nV_total = nV_H2O + nV_CO2;
    const y_CO2 = nV_total > 0 ? nV_CO2 / nV_total : 0;
    const vapEnriched = y_CO2 > 0.5;
    results.push({ name: 'Vap enrich CO2', calc: (y_CO2*100).toFixed(1)+'%', ref: '>50%', delta: vapEnriched ? 'yes' : 'NO', tol: 'check', status: vapEnriched ? 'âœ“' : 'âœ—', pass: vapEnriched });
    if (vapEnriched) { passCount++; test34Passed.push('vap-CO2'); } else { failCount++; test34Failed.push('vap-CO2'); }
    
    // Check 4: H2O enriched in liquid (x_H2O > z_H2O = 0.5)
    const nL_total = nL_H2O + nL_CO2;
    const x_H2O = nL_total > 0 ? nL_H2O / nL_total : 0;
    const liqEnriched = x_H2O > 0.5;
    results.push({ name: 'Liq enrich H2O', calc: (x_H2O*100).toFixed(1)+'%', ref: '>50%', delta: liqEnriched ? 'yes' : 'NO', tol: 'check', status: liqEnriched ? 'âœ“' : 'âœ—', pass: liqEnriched });
    if (liqEnriched) { passCount++; test34Passed.push('liq-H2O'); } else { failCount++; test34Failed.push('liq-H2O'); }
    
    // Check 5: Two-phase inlet
    const phaseVL = sepUD?.last?.phase === 'VL';
    results.push({ name: 'Inlet VL', calc: sepUD?.last?.phase, ref: 'VL', delta: phaseVL ? 'match' : 'FAIL', tol: 'exact', status: phaseVL ? 'âœ“' : 'âœ—', pass: phaseVL });
    if (phaseVL) { passCount++; test34Passed.push('VL'); } else { failCount++; test34Failed.push('VL'); }
    
    // Check 6: Enthalpy balance (H_feed â‰ˆ H_vap + H_liq)
    const H_feed = feedS ? thermo.getHdot_Jps(feedS) : 0;
    const H_vap = thermo.getHdot_Jps(vapS);
    const H_liq = thermo.getHdot_Jps(liqS);
    const H_sum = H_vap + H_liq;
    const H_err_pct = H_feed !== 0 ? Math.abs((H_sum - H_feed) / H_feed) * 100 : 0;
    results.push(checkTolerance(H_err_pct, 0, 2.0, 'H balance err [%]', test34Passed, test34Failed));
    
    // Check 7: Both outlets have flow
    const bothFlow = nV_total > 0.01 && nL_total > 0.01;
    results.push({ name: 'Both outlets flow', calc: bothFlow ? 'yes' : 'NO', ref: 'yes', delta: bothFlow ? 'match' : 'FAIL', tol: 'check', status: bothFlow ? 'âœ“' : 'âœ—', pass: bothFlow });
    if (bothFlow) { passCount++; test34Passed.push('both-flow'); } else { failCount++; test34Failed.push('both-flow'); }
    
    const beta = sepUD?.last?.beta;
    console.log(`  Î²=${beta?.toFixed(4)}, V: ${nV_total.toFixed(3)} mol/s (y_CO2=${(y_CO2*100).toFixed(1)}%), L: ${nL_total.toFixed(3)} mol/s (x_H2O=${(x_H2O*100).toFixed(1)}%)`);
    console.log(`  H_feed=${(H_feed/1000).toFixed(2)} kW, H_V+H_L=${(H_sum/1000).toFixed(2)} kW, err=${H_err_pct.toFixed(2)}%`);
    
    printResultsTable(results, null);
    recordTestResult(test34Name, test34Passed, test34Failed, 34);
    
  } catch (err) {
    recordTestError(test34Name, err.message, 7, 34);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 35: Power Hub â€” Input Aggregation (MultiConnect)
  // =================================================================
  testCount++;
  const test35Name = 'Hub: Input Aggregation';
  console.log(`\nTest ${testCount}: ${test35Name}`);
  console.log(`  Topology: BattA(50kW) + BattB(30kW) â†’ Hub.firm_in`);
  console.log(`            BattC(20kW) â†’ Hub.battery_in`);
  console.log(`  Scenario: Hub sums multiConnect inputs correctly`);
  
  try {
    clearScene();
    const test35Passed = [];
    const test35Failed = [];
    const results = [];
    
    const battA = scene.placeUnit('battery', 0, 0);
    const battB = scene.placeUnit('battery', 0, 3);
    const battC = scene.placeUnit('battery', 0, 6);
    const hubId = scene.placeUnit('power_hub', 4, 2);
    const sinkId = scene.placeUnit('sink_electrical', 8, 5);
    
    scene.units.get(battA).params = { maxPower: 50 };
    scene.units.get(battB).params = { maxPower: 30 };
    scene.units.get(battC).params = { maxPower: 20 };
    
    // Two connections to firm_in (multiConnect)
    scene.connections.push({ id: 'c1', from: { unitId: battA, portId: 'out' }, to: { unitId: hubId, portId: 'firm_in' } });
    scene.connections.push({ id: 'c2', from: { unitId: battB, portId: 'out' }, to: { unitId: hubId, portId: 'firm_in' } });
    // One connection to battery_in (multiConnect)
    scene.connections.push({ id: 'c3', from: { unitId: battC, portId: 'out' }, to: { unitId: hubId, portId: 'battery_in' } });
    // Surplus to sink
    scene.connections.push({ id: 'c4', from: { unitId: hubId, portId: 'surplus_out' }, to: { unitId: sinkId, portId: 'in' } });
    
    solveScene(scene);
    
    const hubUD = scene.runtime.unitData.get(hubId);
    const hubUnit = scene.units.get(hubId);
    
    // Check 1: Firm supply = 50 + 30 = 80 kW = 80000 W
    results.push(checkTolerance(hubUnit.last.firmSupply_W, 80000, 1, 'Firm supply [W]', test35Passed, test35Failed));
    
    // Check 2: Battery max = 20 kW = 20000 W
    results.push(checkTolerance(hubUnit.last.batteryMax_W, 20000, 1, 'Battery max [W]', test35Passed, test35Failed));
    
    // Check 3: Total capacity = 100 kW = 100000 W (firm + battery max)
    results.push(checkTolerance(hubUnit.last.totalCapacity_W, 100000, 1, 'Total capacity [W]', test35Passed, test35Failed));
    
    // Check 4: dist_out available reflects dispatched supply (no consumers â†’ battery draws 0)
    // With 0 demand, battery contributes 0, so dist_out = firm only = 80000 W
    const distOut = hubUD?.ports?.dist_out;
    results.push(checkTolerance(distOut?.available || 0, 80000, 1, 'dist_out dispatched [W]', test35Passed, test35Failed));
    
    // Check 5: Connection validation â€” scene.connect allows multiConnect
    // Create a fresh scene to test connect() validation path
    const testScene = new Scene();
    const tb1 = testScene.placeUnit('battery', 0, 0);
    const tb2 = testScene.placeUnit('battery', 0, 3);
    const th = testScene.placeUnit('power_hub', 4, 1);
    const conn1 = testScene.connect(
      { unitId: tb1, portId: 'out' }, { unitId: th, portId: 'firm_in' }
    );
    const conn2 = testScene.connect(
      { unitId: tb2, portId: 'out' }, { unitId: th, portId: 'firm_in' }
    );
    const multiOK = conn1 !== null && conn2 !== null;
    results.push({ name: 'connect() multiConnect', calc: multiOK ? 'yes' : 'NO', ref: 'yes', delta: multiOK ? 'match' : 'FAIL', tol: 'exact', status: multiOK ? 'âœ“' : 'âœ—', pass: multiOK });
    if (multiOK) { passCount++; test35Passed.push('multi-connect'); } else { failCount++; test35Failed.push('multi-connect'); }
    
    // Check 6: Connection validation â€” normal IN port rejects second connection
    const tb3 = testScene.placeUnit('battery', 0, 6);
    const tsnk = testScene.placeUnit('sink_electrical', 8, 1);
    const connSnk1 = testScene.connect(
      { unitId: th, portId: 'surplus_out' }, { unitId: tsnk, portId: 'in' }
    );
    const connSnk2 = testScene.connect(
      { unitId: tb3, portId: 'out' }, { unitId: tsnk, portId: 'in' }
    );
    const singleOK = connSnk1 !== null && connSnk2 === null;
    results.push({ name: 'connect() single rejects', calc: singleOK ? 'yes' : 'NO', ref: 'yes', delta: singleOK ? 'match' : 'FAIL', tol: 'exact', status: singleOK ? 'âœ“' : 'âœ—', pass: singleOK });
    if (singleOK) { passCount++; test35Passed.push('single-reject'); } else { failCount++; test35Failed.push('single-reject'); }
    
    console.log(`  Hub: firm=${(hubUnit.last.firmSupply_W/1000).toFixed(0)}kW, batt=${(hubUnit.last.batteryMax_W/1000).toFixed(0)}kW, capacity=${(hubUnit.last.totalCapacity_W/1000).toFixed(0)}kW`);
    
    printResultsTable(results, null);
    recordTestResult(test35Name, test35Passed, test35Failed, 35);
    
  } catch (err) {
    recordTestError(test35Name, err.message, 6, 35);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 36: Hub Balancing â€” Sufficient Supply + Battery Dispatch
  // =================================================================
  testCount++;
  const test36Name = 'Hub: Sufficient Supply';
  console.log(`\nTest ${testCount}: ${test36Name}`);
  console.log(`  Topology: Firm(50kW) â†’ Hub.firm_in, Batt(30kW) â†’ Hub.battery_in`);
  console.log(`            Hub.dist_out â†’ Motor(Î·=0.92) â†’ Compressor(N2 1â†’3bar,Î·=0.75) â† Source(N2)`);
  console.log(`            Hub.surplus_out â†’ ElecSink`);
  console.log(`  Scenario: Compressor needs ~3kW shaft â†’ ~3.3kW elec. Firm covers it, battery idle.`);
  
  try {
    clearScene();
    const test36Passed = [];
    const test36Failed = [];
    const results = [];
    
    // Power sources
    const firmId = scene.placeUnit('battery', 0, 0);
    const battId = scene.placeUnit('battery', 0, 6);
    scene.units.get(firmId).params = { maxPower: 50 };
    scene.units.get(battId).params = { maxPower: 30 };
    
    // Hub
    const hubId = scene.placeUnit('power_hub', 4, 1);
    
    // Consumer chain
    const motorId = scene.placeUnit('motor', 8, 0);
    const srcN2   = scene.placeUnit('source', 0, 10);
    const compId  = scene.placeUnit('compressor', 12, 3);
    const snkMat  = scene.placeUnit('sink', 16, 3);
    const snkElec = scene.placeUnit('sink_electrical', 8, 6);
    
    scene.units.get(motorId).params = { eta: 0.92 };
    scene.units.get(srcN2).params = { species: 'N2', nDot: 1, T: 25, P: 100000, phaseConstraint: 'V' };
    scene.units.get(compId).params = { Pout: 300000, eta: 0.75 };
    
    // Wire power: firm â†’ hub.firm_in, batt â†’ hub.battery_in
    scene.connections.push({ id: 'p1', from: { unitId: firmId, portId: 'out' }, to: { unitId: hubId, portId: 'firm_in' } });
    scene.connections.push({ id: 'p2', from: { unitId: battId, portId: 'out' }, to: { unitId: hubId, portId: 'battery_in' } });
    // Hub â†’ motor â†’ compressor
    scene.connections.push({ id: 'p3', from: { unitId: hubId, portId: 'dist_out' }, to: { unitId: motorId, portId: 'elec_in' } });
    scene.connections.push({ id: 'p4', from: { unitId: motorId, portId: 'mech_out' }, to: { unitId: compId, portId: 'power_in' } });
    // Hub surplus â†’ sink
    scene.connections.push({ id: 'p5', from: { unitId: hubId, portId: 'surplus_out' }, to: { unitId: snkElec, portId: 'in' } });
    // Material: source â†’ compressor â†’ sink
    scene.connections.push({ id: 'm1', from: { unitId: srcN2, portId: 'out' }, to: { unitId: compId, portId: 'mat_in' } });
    scene.connections.push({ id: 'm2', from: { unitId: compId, portId: 'mat_out' }, to: { unitId: snkMat, portId: 'in' } });
    
    solveScene(scene);
    
    const hubUnit = scene.units.get(hubId);
    const hubUD   = scene.runtime.unitData.get(hubId);
    const sinkUD  = scene.runtime.unitData.get(snkElec);
    const sinkUnit = scene.units.get(snkElec);
    const motorUD = scene.runtime.unitData.get(motorId);
    
    const demand_kW  = (hubUnit.last.totalDemand_W || 0) / 1000;
    const surplus_kW = (hubUnit.last.surplus_W || 0) / 1000;
    const battDraw_kW = (hubUnit.last.batteryDraw_W || 0) / 1000;
    const curtail     = hubUnit.last.curtailmentFactor;
    const sinkAbs_kW  = (sinkUnit.last.absorbed_W || 0) / 1000;
    
    console.log(`  Hub: demand=${demand_kW.toFixed(2)}kW, surplus=${surplus_kW.toFixed(2)}kW, battDraw=${battDraw_kW.toFixed(2)}kW, curtail=${curtail}`);
    console.log(`  Sink absorbed: ${sinkAbs_kW.toFixed(2)} kW`);
    
    // Check 1: Hub demand > 0 (compressor needs power)
    const demandOK = demand_kW > 1 && demand_kW < 20;
    results.push({ name: 'Hub demand > 0', calc: demand_kW.toFixed(2) + ' kW', ref: '1â€“20 kW', delta: demandOK ? 'yes' : 'NO', tol: 'range', status: demandOK ? 'âœ“' : 'âœ—', pass: demandOK });
    if (demandOK) { passCount++; test36Passed.push('demand'); } else { failCount++; test36Failed.push('demand'); }
    
    // Check 2: Curtailment = 1.0 (sufficient supply)
    results.push(checkTolerance(curtail, 1.0, 0.001, 'Curtailment factor', test36Passed, test36Failed));
    
    // Check 3: Battery draw = 0 (firm covers demand)
    results.push(checkTolerance(battDraw_kW, 0, 0.1, 'Battery draw [kW]', test36Passed, test36Failed));
    
    // Check 4: Surplus â‰ˆ firm_supply - demand (all firm, no battery)
    const expectedSurplus_kW = 50 - demand_kW;
    results.push(checkTolerance(surplus_kW, expectedSurplus_kW, 0.5, 'Surplus [kW]', test36Passed, test36Failed));
    
    // Check 5: Sink absorbed = surplus
    results.push(checkTolerance(sinkAbs_kW, surplus_kW, 0.5, 'Sink = surplus', test36Passed, test36Failed));
    
    printResultsTable(results, null);
    recordTestResult(test36Name, test36Passed, test36Failed, 36);
    
  } catch (err) {
    recordTestError(test36Name, err.message, 5, 36);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // TEST 37: Hub Balancing â€” Undersupply + Curtailment
  // =================================================================
  testCount++;
  const test37Name = 'Hub: Curtailment';
  console.log(`\nTest ${testCount}: ${test37Name}`);
  console.log(`  Topology: Firm(1kW) â†’ Hub.firm_in, Batt(1kW) â†’ Hub.battery_in`);
  console.log(`            Hub.dist_out â†’ Motor(Î·=0.92) â†’ Compressor(N2 1â†’3bar,Î·=0.75) â† Source(N2)`);
  console.log(`            Hub.surplus_out â†’ ElecSink`);
  console.log(`  Scenario: Only 2kW total but compressor needs ~3kW. Curtailment < 1.`);
  
  try {
    clearScene();
    const test37Passed = [];
    const test37Failed = [];
    const results = [];
    
    // Very limited power sources
    const firmId = scene.placeUnit('battery', 0, 0);
    const battId = scene.placeUnit('battery', 0, 6);
    scene.units.get(firmId).params = { maxPower: 1 };   // 1 kW
    scene.units.get(battId).params = { maxPower: 1 };   // 1 kW
    
    const hubId = scene.placeUnit('power_hub', 4, 1);
    
    const motorId = scene.placeUnit('motor', 8, 0);
    const srcN2   = scene.placeUnit('source', 0, 10);
    const compId  = scene.placeUnit('compressor', 12, 3);
    const snkMat  = scene.placeUnit('sink', 16, 3);
    const snkElec = scene.placeUnit('sink_electrical', 8, 6);
    
    scene.units.get(motorId).params = { eta: 0.92 };
    scene.units.get(srcN2).params = { species: 'N2', nDot: 1, T: 25, P: 100000, phaseConstraint: 'V' };
    scene.units.get(compId).params = { Pout: 300000, eta: 0.75 };
    
    // Same wiring as test 36
    scene.connections.push({ id: 'p1', from: { unitId: firmId, portId: 'out' }, to: { unitId: hubId, portId: 'firm_in' } });
    scene.connections.push({ id: 'p2', from: { unitId: battId, portId: 'out' }, to: { unitId: hubId, portId: 'battery_in' } });
    scene.connections.push({ id: 'p3', from: { unitId: hubId, portId: 'dist_out' }, to: { unitId: motorId, portId: 'elec_in' } });
    scene.connections.push({ id: 'p4', from: { unitId: motorId, portId: 'mech_out' }, to: { unitId: compId, portId: 'power_in' } });
    scene.connections.push({ id: 'p5', from: { unitId: hubId, portId: 'surplus_out' }, to: { unitId: snkElec, portId: 'in' } });
    scene.connections.push({ id: 'm1', from: { unitId: srcN2, portId: 'out' }, to: { unitId: compId, portId: 'mat_in' } });
    scene.connections.push({ id: 'm2', from: { unitId: compId, portId: 'mat_out' }, to: { unitId: snkMat, portId: 'in' } });
    
    solveScene(scene);
    
    const hubUnit = scene.units.get(hubId);
    const sinkUnit = scene.units.get(snkElec);
    
    const demand_kW   = (hubUnit.last.totalDemand_W || 0) / 1000;
    const surplus_kW  = (hubUnit.last.surplus_W || 0) / 1000;
    const battDraw_kW = (hubUnit.last.batteryDraw_W || 0) / 1000;
    const curtail     = hubUnit.last.curtailmentFactor;
    const supply_kW   = (hubUnit.last.totalSupply_W || 0) / 1000;
    const sinkAbs_kW  = (sinkUnit.last.absorbed_W || 0) / 1000;
    
    console.log(`  Hub: demand=${demand_kW.toFixed(2)}kW, supply=${supply_kW.toFixed(2)}kW, curtail=${curtail?.toFixed(3)}`);
    console.log(`  BattDraw=${battDraw_kW.toFixed(2)}kW, surplus=${surplus_kW.toFixed(2)}kW, sink=${sinkAbs_kW.toFixed(2)}kW`);
    
    // Check 1: Curtailment < 1 (undersupplied)
    const curtailOK = curtail < 1.0 && curtail > 0;
    results.push({ name: 'Curtailment < 1', calc: curtail?.toFixed(4), ref: '0 < c < 1', delta: curtailOK ? 'yes' : 'NO', tol: 'range', status: curtailOK ? 'âœ“' : 'âœ—', pass: curtailOK });
    if (curtailOK) { passCount++; test37Passed.push('curtail'); } else { failCount++; test37Failed.push('curtail'); }
    
    // Check 2: Battery fully drawn (gap > battery capacity, so draws all)
    results.push(checkTolerance(battDraw_kW, 1.0, 0.01, 'Battery fully drawn [kW]', test37Passed, test37Failed));
    
    // Check 3: Total supply = firm + battery = 2 kW
    results.push(checkTolerance(supply_kW, 2.0, 0.01, 'Total supply [kW]', test37Passed, test37Failed));
    
    // Check 4: Surplus = 0 (all consumed)
    results.push(checkTolerance(surplus_kW, 0, 0.01, 'Surplus = 0', test37Passed, test37Failed));
    
    // Check 5: Sink absorbed = 0
    results.push(checkTolerance(sinkAbs_kW, 0, 0.01, 'Sink absorbed = 0', test37Passed, test37Failed));
    
    printResultsTable(results, null);
    recordTestResult(test37Name, test37Passed, test37Failed, 37);
    
  } catch (err) {
    recordTestError(test37Name, err.message, 5, 37);
    debugLog('Stack trace:', err.stack);
  }

  // =================================================================
  // SUMMARY
  // =================================================================
  console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('  SUMMARY');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  
  // Show individual test results
  testResults.forEach((result, idx) => {
    const status = result.success ? 'âœ“' : 'âœ—';
    const checks = `(${result.passed}/${result.passed + result.failed})`;
    console.log(`  ${status} Test ${idx + 1}: ${result.name.padEnd(32)} ${checks}`);
    if (result.error) {
      console.log(`      Error: ${result.error}`);
    }
  });
  
  console.log(`\n  Total: ${passCount}/${passCount + failCount} checks passed`);
  
  const allTestsPassed = testResults.every(t => t.success);
  const success = allTestsPassed && (passCount > 0);
  
  if (success) {
    console.log('\n  âœ“ ALL TESTS PASSED');
  } else {
    console.log(`\n  âœ— ${failCount} CHECK(S) FAILED`);
  }
  
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
  
  return { 
    tests: testCount,
    passed: passCount, 
    failed: failCount,
    success: success
  };
}

// Make test function globally available
window.runPHFlashTests = runPHFlashTests;

console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('  END-TO-END TEST SUITE LOADED');
console.log('  Auto-running tests in 500ms...');
console.log('  (Manual run: runPHFlashTests())');
console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

// Auto-run tests after scene is fully initialized
setTimeout(() => {
  console.log('Starting automated test execution...\n');
  try {
    const result = runPHFlashTests();
    console.log('\n--- Test execution completed ---');
    console.log(`Result: ${result.success ? 'SUCCESS' : 'FAILURE'}`);
  } catch (err) {
    console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.error('TEST EXECUTION ERROR:');
    console.error(err.message);
    console.error(err.stack);
    console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  }
}, 500);  // Longer delay to ensure full initialization

</script>
</body>
</html>
